<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>VIGRA - VIGRA: Region Segmentation Algorithms</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Region Segmentation Algorithms
</td>
<td align=right><a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif"></a></td></tr>
</table><p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1SeedRgDirectValueFunctor.html">SeedRgDirectValueFunctor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Statistics functor to be used for seeded region growing.  <a href="classvigra_1_1SeedRgDirectValueFunctor.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SeededRegionGrowing.html#gd236be19d1ef7ff0ee2af08182f76dc0">seededRegionGrowing</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Region Segmentation by means of Seeded Region Growing.  <a href="#gd236be19d1ef7ff0ee2af08182f76dc0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SeededRegionGrowing.html#gd07f44d3bf8492d70058b3e8cea541a3">seededRegionGrowing3D</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Three-dimensional Region Segmentation by means of Seeded Region Growing.  <a href="#gd07f44d3bf8492d70058b3e8cea541a3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SeededRegionGrowing.html#g3b5e1e5125417d96ec2ce5c082403998">watersheds</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Region Segmentation by means of the watershed algorithm.  <a href="#g3b5e1e5125417d96ec2ce5c082403998"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SeededRegionGrowing.html#gfb49a165a60ea64cd5f89d23c48883ee">watersheds3D</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Region Segmentation by means of the watershed algorithm.  <a href="#gfb49a165a60ea64cd5f89d23c48883ee"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2 class="details_section">Detailed Description</h2>
Region growing, watersheds, and voronoi tesselation<p>
Region segmentation and voronoi tesselation <hr><h2>Function Documentation</h2>
<a class="anchor" name="gd236be19d1ef7ff0ee2af08182f76dc0"></a><!-- doxytag: member="vigra::seededRegionGrowing" ref="gd236be19d1ef7ff0ee2af08182f76dc0" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::seededRegionGrowing           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Region Segmentation by means of Seeded Region Growing. 
<p>
This algorithm implements seeded region growing as described in<p>
R. Adams, L. Bischof: "&lt;em&gt; Seeded Region Growing&lt;/em&gt;", IEEE Trans. on Pattern Analysis and Maschine Intelligence, vol 16, no 6, 1994, and<p>
Ullrich K&ouml;the: <em><a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/papers/#primary">Primary Image Segmentation</a></em>, in: G. Sagerer, S. Posch, F. Kummert (eds.): Mustererkennung 1995, Proc. 17. DAGM-Symposium, Springer 1995<p>
The seed image is a partly segmented image which contains uniquely labeled regions (the seeds) and unlabeled pixels (the candidates, label 0). Seed regions can be as large as you wish and as small as one pixel. If there are no candidates, the algorithm will simply copy the seed image into the output image. Otherwise it will aggregate the candidates into the existing regions so that a cost function is minimized. This works as follows:<p>
<ol>
<li>
Find all candidate pixels that are 4-adjacent to a seed region. Calculate the cost for aggregating each candidate into its adajacent region and put the candidates into a priority queue.<p>
</li>
<li>
While( priority queue is not empty)<p>
<ol>
<li>
Take the candidate with least cost from the queue. If it has not already been merged, merge it with it's adjacent region.<p>
</li>
<li>
Put all candidates that are 4-adjacent to the pixel just processed into the priority queue.<p>
</li>
</ol>
<p>
</li>
</ol>
<p>
If <code>SRGType == CompleteGrow</code> (the default), this algorithm will produce a complete 4-connected tesselation of the image. If <code>SRGType == KeepContours</code>, a one-pixel-wide border will be left between the regions. The border pixels get label 0 (zero).<p>
The cost is determined jointly by the source image and the region statistics functor. The source image contains feature values for each pixel which will be used by the region statistics functor to calculate and update statistics for each region and to calculate the cost for each candidate. The <code>RegionStatisticsArray</code> must be compatible to the <a class="el" href="classvigra_1_1ArrayOfRegionStatistics.html">ArrayOfRegionStatistics</a> functor and contains an <em> array</em> of statistics objects for each region. The indices must correspond to the labels of the seed regions. The statistics for the initial regions must have been calculated prior to calling <code><a class="el" href="group__SeededRegionGrowing.html#gd236be19d1ef7ff0ee2af08182f76dc0" title="Region Segmentation by means of Seeded Region Growing.">seededRegionGrowing()</a></code> (for example by means of <a class="el" href="group__InspectAlgo.html#g08f63d65ccdfca7e4193f3616f0e69c0">inspectTwoImagesIf()</a>).<p>
For each candidate <code>x</code> that is adjacent to region <code>i</code>, the algorithm will call <code>stats[i].cost(as(x))</code> to get the cost (where <code>x</code> is a <code>SrcImageIterator</code> and <code>as</code> is the SrcAccessor). When a candidate has been merged with a region, the statistics are updated by calling <code>stats[i].operator()(as(x))</code>. Since the <code>RegionStatisticsArray</code> is passed by reference, this will overwrite the original statistics.<p>
If a candidate could be merged into more than one regions with identical cost, the algorithm will favour the nearest region.<p>
In some cases, the cost only depends on the feature value of the current pixel. Then the update operation will simply be a no-op, and the <code>cost()</code> function returns its argument. This behavior is implemented by the <a class="el" href="classvigra_1_1SeedRgDirectValueFunctor.html">SeedRgDirectValueFunctor</a>. With <code>SRGType == KeepContours</code>, this is equivalent to the watershed algorithm.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>SeedImageIterator, <span class="keyword">class </span>SeedAccessor,
                  <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>RegionStatisticsArray&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__SeededRegionGrowing.html#gd236be19d1ef7ff0ee2af08182f76dc0" title="Region Segmentation by means of Seeded Region Growing.">seededRegionGrowing</a>(SrcImageIterator srcul,
                                 SrcImageIterator srclr, SrcAccessor as,
                                 SeedImageIterator seedsul, SeedAccessor aseeds,
                                 DestImageIterator destul, DestAccessor ad,
                                 RegionStatisticsArray &amp; stats,
                                 SRGType srgType = CompleteGrow);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>SeedImageIterator, <span class="keyword">class </span>SeedAccessor,
                  <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>RegionStatisticsArray&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__SeededRegionGrowing.html#gd236be19d1ef7ff0ee2af08182f76dc0" title="Region Segmentation by means of Seeded Region Growing.">seededRegionGrowing</a>(triple&lt;SrcImageIterator, SrcImageIterator, SrcAccessor&gt; img1,
                            pair&lt;SeedImageIterator, SeedAccessor&gt; img3,
                            pair&lt;DestImageIterator, DestAccessor&gt; img4,
                            RegionStatisticsArray &amp; stats,
                            SRGType srgType = CompleteGrow);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="seededregiongrowing_8hxx-source.html">vigra/seededregiongrowing.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
Example: implementation of the voronoi tesselation<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::BImage</a> points(w,h);
    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FImage</a> dist(x,y);

    <span class="comment">// empty edge image</span>
    points = 0;
    dist = 0;

    <span class="keywordtype">int</span> max_region_label = 100;

    <span class="comment">// throw in some random points:</span>
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt;= max_region_label; ++i)
           points(w * rand() / RAND_MAX , h * rand() / RAND_MAX) = i;

    <span class="comment">// calculate Euclidean distance transform</span>
    <a class="code" href="group__DistanceTransform.html#g4c3a954c8547e2b63c342e234a1f695d">vigra::distanceTransform</a>(srcImageRange(points), destImage(dist), 2);

    <span class="comment">// init statistics functor</span>
    <a class="code" href="classvigra_1_1ArrayOfRegionStatistics.html" title="Calculate statistics for all regions of a labeled image.">vigra::ArrayOfRegionStatistics&lt;vigra::SeedRgDirectValueFunctor&lt;float&gt;</a> &gt;
                                              stats(max_region_label);

    <span class="comment">// find voronoi region of each point</span>
   <a class="code" href="group__SeededRegionGrowing.html#gd236be19d1ef7ff0ee2af08182f76dc0" title="Region Segmentation by means of Seeded Region Growing.">vigra:: seededRegionGrowing</a>(srcImageRange(dist), srcImage(points),
                               destImage(points), stats);
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcImageIterator src_upperleft, src_lowerright;
    SeedImageIterator seed_upperleft;
    DestImageIterator dest_upperleft;

    SrcAccessor src_accessor;
    SeedAccessor seed_accessor;
    DestAccessor dest_accessor;

    RegionStatisticsArray stats;

    <span class="comment">// calculate costs</span>
    RegionStatisticsArray::value_type::cost_type cost =
        stats[seed_accessor(seed_upperleft)].cost(src_accessor(src_upperleft));

    <span class="comment">// compare costs</span>
    cost &lt; cost;

    <span class="comment">// update statistics</span>
    stats[seed_accessor(seed_upperleft)](src_accessor(src_upperleft));

    <span class="comment">// set result</span>
    dest_accessor.set(seed_accessor(seed_upperleft), dest_upperleft);
</pre></div><p>
Further requirements are determined by the <code>RegionStatisticsArray</code>. 
</div>
</div><p>
<a class="anchor" name="gd07f44d3bf8492d70058b3e8cea541a3"></a><!-- doxytag: member="vigra::seededRegionGrowing3D" ref="gd07f44d3bf8492d70058b3e8cea541a3" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::seededRegionGrowing3D           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Three-dimensional Region Segmentation by means of Seeded Region Growing. 
<p>
This algorithm implements seeded region growing as described in<p>
The seed image is a partly segmented multi-dimensional array which contains uniquely labeled regions (the seeds) and unlabeled voxels (the candidates, label 0). Seed regions can be as large as you wish and as small as one voxel. If there are no candidates, the algorithm will simply copy the seed array into the output array. Otherwise it will aggregate the candidates into the existing regions so that a cost function is minimized. This works as follows:<p>
<ol>
<li>
Find all candidate pixels that are 6-adjacent to a seed region. Calculate the cost for aggregating each candidate into its adajacent region and put the candidates into a priority queue.<p>
</li>
<li>
While( priority queue is not empty)<p>
<ol>
<li>
Take the candidate with least cost from the queue. If it has not already been merged, merge it with it's adjacent region.<p>
</li>
<li>
Put all candidates that are 4-adjacent to the pixel just processed into the priority queue.<p>
</li>
</ol>
<p>
</li>
</ol>
<p>
If <code>SRGType == CompleteGrow</code> (the default), this algorithm will produce a complete 6-connected tesselation of the array. Other grow types (such as keeping contours for watersheds) are currently not supported<p>
The cost is determined jointly by the source array and the region statistics functor. The source array contains feature values for each pixel which will be used by the region statistics functor to calculate and update statistics for each region and to calculate the cost for each candidate. The <code>RegionStatisticsArray</code> must be compatible to the <a class="el" href="classvigra_1_1ArrayOfRegionStatistics.html">ArrayOfRegionStatistics</a> functor and contains an <em> array</em> of statistics objects for each region. The indices must correspond to the labels of the seed regions. The statistics for the initial regions must have been calculated prior to calling <code><a class="el" href="group__SeededRegionGrowing.html#gd07f44d3bf8492d70058b3e8cea541a3" title="Three-dimensional Region Segmentation by means of Seeded Region Growing.">seededRegionGrowing3D()</a></code><p>
For each candidate <code>x</code> that is adjacent to region <code>i</code>, the algorithm will call <code>stats[i].cost(as(x))</code> to get the cost (where <code>x</code> is a <code>SrcImageIterator</code> and <code>as</code> is the SrcAccessor). When a candidate has been merged with a region, the statistics are updated by calling <code>stats[i].operator()(as(x))</code>. Since the <code>RegionStatisticsArray</code> is passed by reference, this will overwrite the original statistics.<p>
If a candidate could be merged into more than one regions with identical cost, the algorithm will favour the nearest region. If, at any point in the algorithm, the cost of the current candidate exceeds the optional <code>max_cost</code> value (which defaults to <code>-1</code>), region growing is aborted, and all voxels not yet assigned to a region remain unlabeled.<p>
In some cases, the cost only depends on the feature value of the current voxel. Then the update operation will simply be a no-op, and the <code>cost()</code> function returns its argument. This behavior is implemented by the <a class="el" href="classvigra_1_1SeedRgDirectValueFunctor.html">SeedRgDirectValueFunctor</a>.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>Diff_type, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>SeedImageIterator, <span class="keyword">class </span>SeedAccessor,
                  <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>RegionStatisticsArray, <span class="keyword">class </span>CostThresholdType &gt;
        <span class="keywordtype">void</span> <a class="code" href="group__SeededRegionGrowing.html#gd07f44d3bf8492d70058b3e8cea541a3" title="Three-dimensional Region Segmentation by means of Seeded Region Growing.">seededRegionGrowing3D</a>(SrcImageIterator srcul, Diff_type shape,
                                 SrcAccessor as,
                                 SeedImageIterator seedsul, SeedAccessor aseeds,
                                 DestImageIterator destul, DestAccessor ad,
                                 RegionStatisticsArray &amp; stats, 
                                 CostThresholdType max_cost = -1.0,
                                 <span class="keyword">const</span> SRGType srgType == CompleteGrow);

        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>Diff_type, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>SeedImageIterator, <span class="keyword">class </span>SeedAccessor,
                  <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>RegionStatisticsArray&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__SeededRegionGrowing.html#gd07f44d3bf8492d70058b3e8cea541a3" title="Three-dimensional Region Segmentation by means of Seeded Region Growing.">seededRegionGrowing3D</a>(SrcImageIterator srcul, Diff_type shape,
                                 SrcAccessor as,
                                 SeedImageIterator seedsul, SeedAccessor aseeds,
                                 DestImageIterator destul, DestAccessor ad,
                                 RegionStatisticsArray &amp; stats, 
                                 <span class="keyword">const</span> SRGType srgType == CompleteGrow);

       }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
            <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>Shape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>SeedImageIterator, <span class="keyword">class </span>SeedAccessor,
                  <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>RegionStatisticsArray, <span class="keyword">class </span>CostThresholdType&gt;
            <span class="keywordtype">void</span>
            <a class="code" href="group__SeededRegionGrowing.html#gd07f44d3bf8492d70058b3e8cea541a3" title="Three-dimensional Region Segmentation by means of Seeded Region Growing.">seededRegionGrowing3D</a>(triple&lt;SrcImageIterator, Shape, SrcAccessor&gt; img1,
                            pair&lt;SeedImageIterator, SeedAccessor&gt; img3,
                            pair&lt;DestImageIterator, DestAccessor&gt; img4,
                            RegionStatisticsArray &amp; stats, 
                            CostThresholdType max_cost = -1.0,
                            <span class="keyword">const</span> SRGType srgType == CompleteGrow);

            <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>Shape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>SeedImageIterator, <span class="keyword">class </span>SeedAccessor,
                  <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>RegionStatisticsArray&gt;
            <span class="keywordtype">void</span>
            <a class="code" href="group__SeededRegionGrowing.html#gd07f44d3bf8492d70058b3e8cea541a3" title="Three-dimensional Region Segmentation by means of Seeded Region Growing.">seededRegionGrowing3D</a>(triple&lt;SrcImageIterator, Shape, SrcAccessor&gt; img1,
                            pair&lt;SeedImageIterator, SeedAccessor&gt; img3,
                            pair&lt;DestImageIterator, DestAccessor&gt; img4,
                            RegionStatisticsArray &amp; stats, 
                            <span class="keyword">const</span> SRGType srgType == CompleteGrow);
    }
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g3b5e1e5125417d96ec2ce5c082403998"></a><!-- doxytag: member="vigra::watersheds" ref="g3b5e1e5125417d96ec2ce5c082403998" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">unsigned int vigra::watersheds           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Region Segmentation by means of the watershed algorithm. 
<p>
This function implements the union-find version of the watershed algorithms as described in<p>
J. Roerdink, R. Meijster: "<em>The watershed transform: definitions, algorithms, and parallelization stretegies</em>", Fundamenta Informaticae, 41:187-228, 2000<p>
The source image is a boundary indicator such as the gradient magnitude of the trace of the <a class="el" href="group__TensorImaging.html#g3f60d75d3f938c3805544c28e5aa0053">boundaryTensor()</a>. Local minima of the boundary indicator are used as region seeds, and all other pixels are recursively assigned to the same region as their lowest neighbor. Pass <a class="el" href="group__PixelNeighborhood.html#g04897760f5b7969c9811a3c258f5981d">vigra::EightNeighborCode</a> or <a class="el" href="group__PixelNeighborhood.html#g58cb45fb133eb7c1d63fd14f65b8320f">vigra::FourNeighborCode</a> to determine the neighborhood where pixel values are compared. The pixel type of the input image must be <code>LessThanComparable</code>. The function uses accessors.<p>
Note that VIGRA provides an alternative implementaion of the watershed transform via <a class="el" href="group__SeededRegionGrowing.html#gd236be19d1ef7ff0ee2af08182f76dc0">seededRegionGrowing()</a>. It is slower, but handles plateaus better and allows to keep a one pixel wide boundary between regions.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>Neighborhood = <a class="code" href="group__PixelNeighborhood.html#g04897760f5b7969c9811a3c258f5981d">EightNeighborCode</a>&gt;
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> 
        <a class="code" href="group__SeededRegionGrowing.html#g3b5e1e5125417d96ec2ce5c082403998" title="Region Segmentation by means of the watershed algorithm.">watersheds</a>(SrcIterator upperlefts, SrcIterator lowerrights, SrcAccessor sa,
                   DestIterator upperleftd, DestAccessor da, 
                   Neighborhood neighborhood = <a class="code" href="group__PixelNeighborhood.html#g04897760f5b7969c9811a3c258f5981d">EightNeighborCode</a>())
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>Neighborhood = <a class="code" href="group__PixelNeighborhood.html#g04897760f5b7969c9811a3c258f5981d">EightNeighborCode</a>&gt;
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> 
        <a class="code" href="group__SeededRegionGrowing.html#g3b5e1e5125417d96ec2ce5c082403998" title="Region Segmentation by means of the watershed algorithm.">watersheds</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
                   pair&lt;DestIterator, DestAccessor&gt; dest, 
                   Neighborhood neighborhood = <a class="code" href="group__PixelNeighborhood.html#g04897760f5b7969c9811a3c258f5981d">EightNeighborCode</a>())
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="watersheds_8hxx-source.html">vigra/watersheds.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
Example: watersheds of the gradient magnitude.<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::BImage</a> in(w,h);
    ... <span class="comment">// read input data</span>
    
    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FImage</a> gradx(x,y), grady(x,y), gradMag(x,y);
    <a class="code" href="group__CommonConvolutionFilters.html#g45f3ac60c35b246600df26492e0a538e" title="Calculate the gradient vector by means of a 1st derivatives of Gaussian filter.">gaussianGradient</a>(srcImageRange(src), destImage(gradx), destImage(grady), 3.0);
    <a class="code" href="group__CombineAlgo.html#g661f03fd38fff21c75ef98b7020fe0a8" title="Combine two source images into destination image.">combineTwoImages</a>(srcImageRange(gradx), srcImage(grady), destImage(gradMag),
                     <a class="code" href="classvigra_1_1MagnitudeFunctor.html">vigra::MagnitudeFunctor&lt;float&gt;</a>());
    
    <span class="comment">// the pixel type of the destination image must be large enough to hold</span>
    <span class="comment">// numbers up to 'max_region_label' to prevent overflow</span>
    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::IImage</a> labeling(x,y);
    <span class="keywordtype">int</span> max_region_label = <a class="code" href="group__SeededRegionGrowing.html#g3b5e1e5125417d96ec2ce5c082403998" title="Region Segmentation by means of the watershed algorithm.">watersheds</a>(srcImageRange(gradMag), destImage(labeling));
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcImageIterator src_upperleft, src_lowerright;
    DestImageIterator dest_upperleft;

    SrcAccessor src_accessor;
    DestAccessor dest_accessor;
    
    <span class="comment">// compare src values</span>
    src_accessor(src_upperleft) &lt;= src_accessor(src_upperleft)

    <span class="comment">// set result</span>
    int label;
    dest_accessor.set(label, dest_upperleft);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="gfb49a165a60ea64cd5f89d23c48883ee"></a><!-- doxytag: member="vigra::watersheds3D" ref="gfb49a165a60ea64cd5f89d23c48883ee" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">unsigned int vigra::watersheds3D           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Region Segmentation by means of the watershed algorithm. 
<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,<span class="keyword">class </span>SrcShape,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>Neighborhood3D&gt;
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="group__SeededRegionGrowing.html#gfb49a165a60ea64cd5f89d23c48883ee" title="Region Segmentation by means of the watershed algorithm.">watersheds3D</a>(SrcIterator s_Iter, SrcShape srcShape, SrcAccessor sa,
                                  DestIterator d_Iter, DestAccessor da,
                                  Neighborhood3D neighborhood3D);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,<span class="keyword">class </span>SrcShape,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>Neighborhood3D&gt;
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="group__SeededRegionGrowing.html#gfb49a165a60ea64cd5f89d23c48883ee" title="Region Segmentation by means of the watershed algorithm.">watersheds3D</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; src,
                                  pair&lt;DestIterator, DestAccessor&gt; dest,
                                  Neighborhood3D neighborhood3D);
    }
</pre></div><p>
use with 3D-Six-Neighborhood: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {    
    
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,<span class="keyword">class </span>SrcShape,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> watersheds3DSix(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; src,
                                     pair&lt;DestIterator, DestAccessor&gt; dest);
                                    
    }
</pre></div><p>
use with 3D-TwentySix-Neighborhood: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {    
    
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,<span class="keyword">class </span>SrcShape,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> watersheds3DTwentySix(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; src,
                                           pair&lt;DestIterator, DestAccessor&gt; dest);
                                    
    }
</pre></div><p>
This function implements the union-find version of the watershed algorithms as described in<p>
J. Roerdink, R. Meijster: "<em>The watershed transform: definitions, algorithms, and parallelization stretegies</em>", Fundamenta Informaticae, 41:187-228, 2000<p>
The source volume is a boundary indicator such as the gradient magnitude of the trace of the <a class="el" href="group__TensorImaging.html#g3f60d75d3f938c3805544c28e5aa0053">boundaryTensor()</a>. Local minima of the boundary indicator are used as region seeds, and all other voxels are recursively assigned to the same region as their lowest neighbor. Pass <a class="el" href="group__VoxelNeighborhood.html#gae23891fb489f969e6deff00b8d76b8a">vigra::NeighborCode3DSix</a> or <a class="el" href="group__VoxelNeighborhood.html#g89b6c2a18b23d145b3bc2fe983803f08">vigra::NeighborCode3DTwentySix</a> to determine the neighborhood where voxel values are compared. The voxel type of the input volume must be <code>LessThanComparable</code>. The function uses accessors.<p>
...probably soon in VIGRA: Note that VIGRA provides an alternative implementaion of the watershed transform via <a class="el" href="group__SeededRegionGrowing.html#gd07f44d3bf8492d70058b3e8cea541a3">seededRegionGrowing3D()</a>. It is slower, but handles plateaus better and allows to keep a one pixel wide boundary between regions.<p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="watersheds3D_8hxx-source.html">vigra/watersheds3D.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
Example: watersheds3D of the gradient magnitude.<p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3,int&gt;</a> IntVolume;
    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3,double&gt;</a> DVolume;
    DVolume src(DVolume::difference_type(w,h,d));
    IntVolume dest(IntVolume::difference_type(w,h,d));

    <span class="keywordtype">float</span> gauss=1;

    <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, vigra::TinyVector&lt;float,3&gt;</a> &gt; temp(IntVolume::difference_type(w,h,d));
    <a class="code" href="group__MultiArrayConvolutionFilters.html#g2da85c26a08c9fba7e7a44ffcd981e7a" title="Calculate Gaussian gradient of a multi-dimensional arrays.">vigra::gaussianGradientMultiArray</a>(srcMultiArrayRange(vol),destMultiArray(temp),gauss);

    IntVolume::iterator temp_iter=temp.begin();
    <span class="keywordflow">for</span>(DVolume::iterator iter=src.begin(); iter!=src.end(); ++iter, ++temp_iter)
        *iter = <a class="code" href="group__FFTWComplexOperators.html#g4dd6e72ef816031458ece2315e520694" title="norm (= magnitude)">norm</a>(*temp_iter);
    
    <span class="comment">// find 6-connected regions</span>
    <span class="keywordtype">int</span> max_region_label = vigra::watersheds3DSix(srcMultiArrayRange(src), destMultiArray(dest));

    <span class="comment">// find 26-connected regions</span>
    max_region_label = vigra::watersheds3DTwentySix(srcMultiArrayRange(src), destMultiArray(dest));
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcIterator src_begin;
    SrcShape src_shape;
    DestIterator dest_begin;

    SrcAccessor src_accessor;
    DestAccessor dest_accessor;
    
    <span class="comment">// compare src values</span>
    src_accessor(src_begin) &lt;= src_accessor(src_begin)

    <span class="comment">// set result</span>
    int label;
    dest_accessor.set(label, dest_begin);
</pre></div> 
</div>
</div><p>
</div>
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
VIGRA 1.6.0 (13 Aug 2008)
</i>
</tr>
</table>


</BODY>
</HTML>
