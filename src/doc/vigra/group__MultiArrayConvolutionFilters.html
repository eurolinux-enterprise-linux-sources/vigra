<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>VIGRA - VIGRA: Convolution filters for multi-dimensional arrays.</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Convolution filters for multi-dimensional arrays.
</td>
<td align=right><a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif"></a></td></tr>
</table><p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#g28ecfad8f9bf2f5bbb9b700195d19247">convolveMultiArrayOneDimension</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convolution along a single dimension of a multi-dimensional arrays.  <a href="#g28ecfad8f9bf2f5bbb9b700195d19247"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#g2da85c26a08c9fba7e7a44ffcd981e7a">gaussianGradientMultiArray</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> gradient of a multi-dimensional arrays.  <a href="#g2da85c26a08c9fba7e7a44ffcd981e7a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#g1fb13ce06a51da4c3bc001415a7c3a07">gaussianSmoothMultiArray</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Isotropic <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> smoothing of a multi-dimensional arrays.  <a href="#g1fb13ce06a51da4c3bc001415a7c3a07"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#g7245a227c77d8d91c99e4fcd68fbad7d">separableConvolveMultiArray</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Separated convolution on multi-dimensional arrays.  <a href="#g7245a227c77d8d91c99e4fcd68fbad7d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiArrayConvolutionFilters.html#g62814e9cd26b8aab742bb87d5e0e75d9">symmetricGradientMultiArray</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate gradient of a multi-dimensional arrays using symmetric difference filters.  <a href="#g62814e9cd26b8aab742bb87d5e0e75d9"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2 class="details_section">Detailed Description</h2>
These functions realize a separable convolution on an arbitrary dimensional array that is specified by iterators (compatible to <a class="el" href="MultiIteratorPage.html">Multi-dimensional Array Iterators</a>) and shape objects. It can therefore be applied to a wide range of data structures (<a class="el" href="classvigra_1_1MultiArrayView.html">vigra::MultiArrayView</a>, <a class="el" href="classvigra_1_1MultiArray.html">vigra::MultiArray</a> etc.). <hr><h2>Function Documentation</h2>
<a class="anchor" name="g7245a227c77d8d91c99e4fcd68fbad7d"></a><!-- doxytag: member="vigra::separableConvolveMultiArray" ref="g7245a227c77d8d91c99e4fcd68fbad7d" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::separableConvolveMultiArray           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Separated convolution on multi-dimensional arrays. 
<p>
This function computes a separated convolution on all dimensions of the given multi-dimensional array. Both source and destination arrays are represented by iterators, shape objects and accessors. The destination array is required to already have the correct size.<p>
There are two variants of this functions: one takes a single kernel of type <a class="el" href="classvigra_1_1Kernel1D.html">vigra::Kernel1D</a> which is then applied to all dimensions, whereas the other requires an iterator referencing a sequence of <a class="el" href="classvigra_1_1Kernel1D.html">vigra::Kernel1D</a> objects, one for every dimension of the data. Then the first kernel in this sequence is applied to the innermost dimension (e.g. the x-dimension of an image), while the last is applied to the outermost dimension (e.g. the z-dimension in a 3D image).<p>
This function may work in-place, which means that <code>siter == diter</code> is allowed. A full-sized internal array is only allocated if working on the destination array directly would cause round-off errors (i.e. if <code>typeid(typename NumericTraits&lt;typename DestAccessor::value_type&gt;::RealPromote) != typeid(typename DestAccessor::value_type)</code>.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="comment">// apply the same kernel to all dimensions</span>
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>T&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#g7245a227c77d8d91c99e4fcd68fbad7d" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                                    DestIterator diter, DestAccessor dest,
                                    Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kernel);

        <span class="comment">// apply each kernel from the sequence `kernels³ in turn</span>
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>KernelIterator&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#g7245a227c77d8d91c99e4fcd68fbad7d" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                                    DestIterator diter, DestAccessor dest,
                                    KernelIterator kernels);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="comment">// apply the same kernel to all dimensions</span>
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>T&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#g7245a227c77d8d91c99e4fcd68fbad7d" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,
                                    pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,
                                    Kernel1D&lt;T&gt; <span class="keyword">const</span> &amp; kernel);

        <span class="comment">// apply each kernel from the sequence `kernels³ in turn</span>
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>KernelIterator&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#g7245a227c77d8d91c99e4fcd68fbad7d" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,
                                    pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,
                                    KernelIterator kernels);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="multi__convolution_8hxx-source.html">vigra/multi_convolution.hxx</a>&gt;<p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;3, unsigned char&gt;::size_type shape(width, height, depth);
    MultiArray&lt;3, unsigned char&gt; source(shape);
    MultiArray&lt;3, float&gt; dest(shape);
    ...
    Kernel1D&lt;float&gt; gauss;
    gauss.initGaussian(sigma);
    <span class="comment">// create 3 Gauss kernels, one for each dimension</span>
    ArrayVector&lt;Kernel1D&lt;float&gt; &gt; kernels(3, gauss);

    <span class="comment">// perform Gaussian smoothing on all dimensions</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#g7245a227c77d8d91c99e4fcd68fbad7d" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray</a>(srcMultiArrayRange(source), destMultiArray(dest), 
                                kernels.begin());
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D</a>, <a class="el" href="group__SeparableConvolution.html#g9df3ccf94198b698d55e3b33fbae8591" title="Performs a 1-dimensional convolution of the source signal using the given kernel...">convolveLine()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g28ecfad8f9bf2f5bbb9b700195d19247"></a><!-- doxytag: member="vigra::convolveMultiArrayOneDimension" ref="g28ecfad8f9bf2f5bbb9b700195d19247" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::convolveMultiArrayOneDimension           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convolution along a single dimension of a multi-dimensional arrays. 
<p>
This function computes a convolution along one dimension (specified by the parameter <code>dim</code> of the given multi-dimensional array with the given <code>kernel</code>. Both source and destination arrays are represented by iterators, shape objects and accessors. The destination array is required to already have the correct size.<p>
This function may work in-place, which means that <code>siter == diter</code> is allowed.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>T&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#g28ecfad8f9bf2f5bbb9b700195d19247" title="Convolution along a single dimension of a multi-dimensional arrays.">convolveMultiArrayOneDimension</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                                       DestIterator diter, DestAccessor dest,
                                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <a class="code" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D&lt;T&gt;</a> <span class="keyword">const</span> &amp; kernel);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>T&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#g28ecfad8f9bf2f5bbb9b700195d19247" title="Convolution along a single dimension of a multi-dimensional arrays.">convolveMultiArrayOneDimension</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,
                                       pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,
                                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <a class="code" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D&lt;T&gt;</a> <span class="keyword">const</span> &amp; kernel);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="multi__convolution_8hxx-source.html">vigra/multi_convolution.hxx</a>&gt;<p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;3, unsigned char&gt;::size_type shape(width, height, depth);
    MultiArray&lt;3, unsigned char&gt; source(shape);
    MultiArray&lt;3, float&gt; dest(shape);
    ...
    Kernel1D&lt;float&gt; gauss;
    gauss.initGaussian(sigma);

    <span class="comment">// perform Gaussian smoothing along dimensions 1 (height)</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#g28ecfad8f9bf2f5bbb9b700195d19247" title="Convolution along a single dimension of a multi-dimensional arrays.">convolveMultiArrayOneDimension</a>(srcMultiArrayRange(source), destMultiArray(dest), 1, gauss);
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#g7245a227c77d8d91c99e4fcd68fbad7d" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1fb13ce06a51da4c3bc001415a7c3a07"></a><!-- doxytag: member="vigra::gaussianSmoothMultiArray" ref="g1fb13ce06a51da4c3bc001415a7c3a07" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::gaussianSmoothMultiArray           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Isotropic <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> smoothing of a multi-dimensional arrays. 
<p>
This function computes an isotropic convolution of the given multi-dimensional array with a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter at the given standard deviation <code>sigma</code>. Both source and destination arrays are represented by iterators, shape objects and accessors. The destination array is required to already have the correct size. This function may work in-place, which means that <code>siter == diter</code> is allowed. It is implemented by a call to <a class="el" href="group__MultiArrayConvolutionFilters.html#g7245a227c77d8d91c99e4fcd68fbad7d">separableConvolveMultiArray()</a> with the appropriate kernel. If the data are anisotropic (different pixel size along different dimensions) you should call <a class="el" href="group__MultiArrayConvolutionFilters.html#g7245a227c77d8d91c99e4fcd68fbad7d">separableConvolveMultiArray()</a> directly with the appropriate anisotropic Gaussians.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#g1fb13ce06a51da4c3bc001415a7c3a07" title="Isotropic Gaussian smoothing of a multi-dimensional arrays.">gaussianSmoothMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                                 DestIterator diter, DestAccessor dest,
                                 <span class="keywordtype">double</span> sigma);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#g1fb13ce06a51da4c3bc001415a7c3a07" title="Isotropic Gaussian smoothing of a multi-dimensional arrays.">gaussianSmoothMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,
                                 pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,
                                 <span class="keywordtype">double</span> sigma);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="multi__convolution_8hxx-source.html">vigra/multi_convolution.hxx</a>&gt;<p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;3, unsigned char&gt;::size_type shape(width, height, depth);
    MultiArray&lt;3, unsigned char&gt; source(shape);
    MultiArray&lt;3, float&gt; dest(shape);
    ...
    <span class="comment">// perform isotropic Gaussian smoothing at scale `sigma³</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#g1fb13ce06a51da4c3bc001415a7c3a07" title="Isotropic Gaussian smoothing of a multi-dimensional arrays.">gaussianSmoothMultiArray</a>(srcMultiArrayRange(source), destMultiArray(dest), sigma);
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#g7245a227c77d8d91c99e4fcd68fbad7d" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2da85c26a08c9fba7e7a44ffcd981e7a"></a><!-- doxytag: member="vigra::gaussianGradientMultiArray" ref="g2da85c26a08c9fba7e7a44ffcd981e7a" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::gaussianGradientMultiArray           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> gradient of a multi-dimensional arrays. 
<p>
This function computes the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> gradient of the given multi-dimensional array with a sequence of first-derivative-of-Gaussian filters at the given standard deviation <code>sigma</code> (differentiation is applied to each dimension in turn, starting with the innermost dimension). Both source and destination arrays are represented by iterators, shape objects and accessors. The destination array is required to have a vector valued pixel type with as many elements as the number of dimensions. This function is implemented by calls to <a class="el" href="group__MultiArrayConvolutionFilters.html#g7245a227c77d8d91c99e4fcd68fbad7d">separableConvolveMultiArray()</a> with the appropriate kernels. If the data are anisotropic (different pixel size along different dimensions) you should call <a class="el" href="group__MultiArrayConvolutionFilters.html#g7245a227c77d8d91c99e4fcd68fbad7d">separableConvolveMultiArray()</a> directly with the appropriate anisotropic <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivatives.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#g2da85c26a08c9fba7e7a44ffcd981e7a" title="Calculate Gaussian gradient of a multi-dimensional arrays.">gaussianGradientMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                                   DestIterator diter, DestAccessor dest,
                                   <span class="keywordtype">double</span> sigma);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#g2da85c26a08c9fba7e7a44ffcd981e7a" title="Calculate Gaussian gradient of a multi-dimensional arrays.">gaussianGradientMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,
                                   pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest,
                                   <span class="keywordtype">double</span> sigma);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="multi__convolution_8hxx-source.html">vigra/multi_convolution.hxx</a>&gt;<p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;3, unsigned char&gt;::size_type shape(width, height, depth);
    MultiArray&lt;3, unsigned char&gt; source(shape);
    MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; dest(shape);
    ...
    <span class="comment">// compute Gaussian gradient at scale sigma</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#g2da85c26a08c9fba7e7a44ffcd981e7a" title="Calculate Gaussian gradient of a multi-dimensional arrays.">gaussianGradientMultiArray</a>(srcMultiArrayRange(source), destMultiArray(dest), sigma);
</pre></div><p>
<b> Required Interface:</b><p>
see <a class="el" href="group__CommonConvolutionFilters.html#g4c1308148e93b0ad69932c352f17b67e">convolveImage()</a>, in addition:<p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> dimension = 0;
    VectorElementAccessor&lt;DestAccessor&gt; elementAccessor(0, dest);
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#g7245a227c77d8d91c99e4fcd68fbad7d" title="Separated convolution on multi-dimensional arrays.">separableConvolveMultiArray()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g62814e9cd26b8aab742bb87d5e0e75d9"></a><!-- doxytag: member="vigra::symmetricGradientMultiArray" ref="g62814e9cd26b8aab742bb87d5e0e75d9" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::symmetricGradientMultiArray           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate gradient of a multi-dimensional arrays using symmetric difference filters. 
<p>
This function computes the gradient of the given multi-dimensional array with a sequence of symmetric difference filters a (differentiation is applied to each dimension in turn, starting with the innermost dimension). Both source and destination arrays are represented by iterators, shape objects and accessors. The destination array is required to have a vector valued pixel type with as many elements as the number of dimensions. This function is implemented by calls to <a class="el" href="group__MultiArrayConvolutionFilters.html#g28ecfad8f9bf2f5bbb9b700195d19247">convolveMultiArrayOneDimension()</a> with the symmetric difference kernel.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#g62814e9cd26b8aab742bb87d5e0e75d9" title="Calculate gradient of a multi-dimensional arrays using symmetric difference filters...">symmetricGradientMultiArray</a>(SrcIterator siter, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                                    DestIterator diter, DestAccessor dest);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiArrayConvolutionFilters.html#g62814e9cd26b8aab742bb87d5e0e75d9" title="Calculate gradient of a multi-dimensional arrays using symmetric difference filters...">symmetricGradientMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; source,
                                    pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="multi__convolution_8hxx-source.html">vigra/multi_convolution.hxx</a>&gt;<p>
<div class="fragment"><pre class="fragment">    MultiArray&lt;3, unsigned char&gt;::size_type shape(width, height, depth);
    MultiArray&lt;3, unsigned char&gt; source(shape);
    MultiArray&lt;3, TinyVector&lt;float, 3&gt; &gt; dest(shape);
    ...
    <span class="comment">// compute gradient</span>
    <a class="code" href="group__MultiArrayConvolutionFilters.html#g62814e9cd26b8aab742bb87d5e0e75d9" title="Calculate gradient of a multi-dimensional arrays using symmetric difference filters...">symmetricGradientMultiArray</a>(srcMultiArrayRange(source), destMultiArray(dest));
</pre></div><p>
<b> Required Interface:</b><p>
see <a class="el" href="group__CommonConvolutionFilters.html#g4c1308148e93b0ad69932c352f17b67e">convolveImage()</a>, in addition:<p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> dimension = 0;
    VectorElementAccessor&lt;DestAccessor&gt; elementAccessor(0, dest);
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__MultiArrayConvolutionFilters.html#g28ecfad8f9bf2f5bbb9b700195d19247" title="Convolution along a single dimension of a multi-dimensional arrays.">convolveMultiArrayOneDimension()</a> </dd></dl>

</div>
</div><p>
</div>
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
VIGRA 1.6.0 (13 Aug 2008)
</i>
</tr>
</table>


</BODY>
</HTML>
