<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>VIGRA - VIGRA: Fast Fourier Transform</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Fast Fourier Transform
</td>
<td align=right><a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif"></a></td></tr>
</table><p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FourierTransform.html#g17b002839f4a650ab309ec55475db6fc">applyFourierFilter</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply a filter (defined in the frequency domain) to an image.  <a href="#g17b002839f4a650ab309ec55475db6fc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FourierTransform.html#gb701decb1fb80640b440d9c323d1c08d">applyFourierFilterFamily</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Apply an array of filters (defined in the frequency domain) to an image.  <a href="#gb701decb1fb80640b440d9c323d1c08d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FourierTransform.html#g7c5685189df1b4468fb89cf38740c117">fourierTransform</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute forward and inverse Fourier transforms.  <a href="#g7c5685189df1b4468fb89cf38740c117"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__FourierTransform.html#g6a42d9c7d695d6d58fa4e3a3da29e5e3">fourierTransformInverse</a> (FFTWComplexImage::const_traverser sul, FFTWComplexImage::const_traverser slr, FFTWComplexImage::ConstAccessor src, FFTWComplexImage::traverser dul, FFTWComplexImage::Accessor dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute inverse Fourier transforms.  <a href="#g6a42d9c7d695d6d58fa4e3a3da29e5e3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FourierTransform.html#g551140282b99d1f656839625b38cf509">fourierTransformReal</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Real Fourier transforms for even and odd boundary conditions (aka. cosine and sine transforms).  <a href="#g551140282b99d1f656839625b38cf509"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FourierTransform.html#g1e9b3e9a0fd15683b59d0a8687bb8b9a">moveDCToCenter</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rearrange the quadrants of a Fourier image so that the origin is in the image center.  <a href="#g1e9b3e9a0fd15683b59d0a8687bb8b9a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__FourierTransform.html#g1b3270b463603b5ec5641d10555030da">moveDCToUpperLeft</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rearrange the quadrants of a Fourier image so that the origin is in the image's upper left.  <a href="#g1b3270b463603b5ec5641d10555030da"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2 class="details_section">Detailed Description</h2>
This documentation describes the VIGRA interface to FFTW version 3. The interface to the old FFTW version 2 (file "vigra/fftw.hxx") is deprecated.<p>
VIGRA uses the <a href="http://www.fftw.org/">FFTW Fast Fourier Transform</a> package to perform Fourier transformations. VIGRA provides a wrapper for FFTW's complex number type (<a class="el" href="classvigra_1_1FFTWComplex.html" title="Wrapper class for the FFTW type &#39;fftw_complex&#39;.">FFTWComplex</a>), but FFTW's functions are used verbatim. If the image is stored as a FFTWComplexImage, the simplest call to an FFT function is like this:<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FFTWComplexImage</a> spatial(width,height), fourier(width,height);
    ... <span class="comment">// fill image with data</span>

    <span class="comment">// create a plan with estimated performance optimization</span>
    fftw_plan forwardPlan = fftw_plan_dft_2d(height, width,
                                (fftw_complex *)spatial.begin(), (fftw_complex *)fourier.begin(),
                                FFTW_FORWARD, FFTW_ESTIMATE );
    <span class="comment">// calculate FFT (this can be repeated as often as needed,</span>
    <span class="comment">//                with fresh data written into the source array)</span>
    fftw_execute(forwardPlan);

    <span class="comment">// release the plan memory</span>
    fftw_destroy_plan(forwardPlan);

    <span class="comment">// likewise for the inverse transform</span>
    fftw_plan backwardPlan = fftw_plan_dft_2d(height, width,
                                 (fftw_complex *)fourier.begin(), (fftw_complex *)spatial.begin(),
                                 FFTW_BACKWARD, FFTW_ESTIMATE);
    fftw_execute(backwardPlan);
    fftw_destroy_plan(backwardPlan);

    <span class="comment">// do not forget to normalize the result according to the image size</span>
    <a class="code" href="group__TransformAlgo.html#ge8b0baa0dd68bf6af88faf6b9ac7925c" title="Apply unary point transformation to each pixel.">transformImage</a>(srcImageRange(spatial), destImage(spatial),
                   std::bind1st(std::multiplies&lt;FFTWComplex&gt;(), 1.0 / width / height));
</pre></div><p>
Note that in the creation of a plan, the height must be given first. Note also that <code>spatial.begin()</code> may only be passed to <code>fftw_plan_dft_2d</code> if the transform shall be applied to the entire image. When you want to restrict operation to an ROI, you can create a copy of the ROI in an image of appropriate size, or you may use the Guru interface to FFTW.<p>
More information on using FFTW can be found <a href="http://www.fftw.org/doc/">here</a>.<p>
FFTW produces fourier images that have the DC component (the origin of the Fourier space) in the upper left corner. Often, one wants the origin in the center of the image, so that frequencies always increase towards the border of the image. This can be achieved by calling <a class="el" href="group__FourierTransform.html#g1e9b3e9a0fd15683b59d0a8687bb8b9a">moveDCToCenter()</a>. The inverse transformation is done by <a class="el" href="group__FourierTransform.html#g1b3270b463603b5ec5641d10555030da">moveDCToUpperLeft()</a>.<p>
<b>#include</b> &lt;<a href="fftw3_8hxx-source.html">vigra/fftw3.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> <hr><h2>Function Documentation</h2>
<a class="anchor" name="g1e9b3e9a0fd15683b59d0a8687bb8b9a"></a><!-- doxytag: member="vigra::moveDCToCenter" ref="g1e9b3e9a0fd15683b59d0a8687bb8b9a" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::moveDCToCenter           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rearrange the quadrants of a Fourier image so that the origin is in the image center. 
<p>
FFTW produces fourier images where the DC component (origin of fourier space) is located in the upper left corner of the image. The quadrants are placed like this (using a 4x4 image for example):<p>
<div class="fragment"><pre class="fragment">            DC 4 3 3
             4 4 3 3
             1 1 2 2
             1 1 2 2
</pre></div><p>
After applying the function, the quadrants are at their usual places:<p>
<div class="fragment"><pre class="fragment">            2 2  1 1
            2 2  1 1
            3 3 DC 4
            3 3  4 4
</pre></div><p>
This transformation can be reversed by <a class="el" href="group__FourierTransform.html#g1b3270b463603b5ec5641d10555030da">moveDCToUpperLeft()</a>. Note that the transformation must not be executed in place - input and output images must be different.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
          <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__FourierTransform.html#g1e9b3e9a0fd15683b59d0a8687bb8b9a" title="Rearrange the quadrants of a Fourier image so that the origin is in the image center...">moveDCToCenter</a>(SrcImageIterator src_upperleft,
                               SrcImageIterator src_lowerright, SrcAccessor sa,
                               DestImageIterator dest_upperleft, DestAccessor da);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__FourierTransform.html#g1e9b3e9a0fd15683b59d0a8687bb8b9a" title="Rearrange the quadrants of a Fourier image so that the origin is in the image center...">moveDCToCenter</a>(
            triple&lt;SrcImageIterator, SrcImageIterator, SrcAccessor&gt; src,
            pair&lt;DestImageIterator, DestAccessor&gt; dest);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="fftw3_8hxx-source.html">vigra/fftw3.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FFTWComplexImage</a> spatial(width,height), fourier(width,height);
    ... <span class="comment">// fill image with data</span>

    <span class="comment">// create a plan with estimated performance optimization</span>
    fftw_plan forwardPlan = fftw_plan_dft_2d(height, width,
                                (fftw_complex *)spatial.begin(), (fftw_complex *)fourier.begin(),
                                FFTW_FORWARD, FFTW_ESTIMATE );
    <span class="comment">// calculate FFT</span>
    fftw_execute(forwardPlan);

    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FFTWComplexImage</a> rearrangedFourier(width, height);
    <a class="code" href="group__FourierTransform.html#g1e9b3e9a0fd15683b59d0a8687bb8b9a" title="Rearrange the quadrants of a Fourier image so that the origin is in the image center...">moveDCToCenter</a>(srcImageRange(fourier), destImage(rearrangedFourier));

    <span class="comment">// delete the plan</span>
    fftw_destroy_plan(forwardPlan);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g1b3270b463603b5ec5641d10555030da"></a><!-- doxytag: member="vigra::moveDCToUpperLeft" ref="g1b3270b463603b5ec5641d10555030da" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::moveDCToUpperLeft           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rearrange the quadrants of a Fourier image so that the origin is in the image's upper left. 
<p>
This function is the inversion of <a class="el" href="group__FourierTransform.html#g1e9b3e9a0fd15683b59d0a8687bb8b9a">moveDCToCenter()</a>. See there for declarations and a usage example.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">        <span class="keyword">namespace </span>vigra {
            <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
                      <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor&gt;
            <span class="keywordtype">void</span> <a class="code" href="group__FourierTransform.html#g1b3270b463603b5ec5641d10555030da" title="Rearrange the quadrants of a Fourier image so that the origin is in the image&amp;#39;s...">moveDCToUpperLeft</a>(SrcImageIterator src_upperleft,
                                   SrcImageIterator src_lowerright, SrcAccessor sa,
                                   DestImageIterator dest_upperleft, DestAccessor da);
        }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">        <span class="keyword">namespace </span>vigra {
            <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
                      <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor&gt;
            <span class="keywordtype">void</span> <a class="code" href="group__FourierTransform.html#g1b3270b463603b5ec5641d10555030da" title="Rearrange the quadrants of a Fourier image so that the origin is in the image&amp;#39;s...">moveDCToUpperLeft</a>(
                triple&lt;SrcImageIterator, SrcImageIterator, SrcAccessor&gt; src,
                pair&lt;DestImageIterator, DestAccessor&gt; dest);
        }
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g7c5685189df1b4468fb89cf38740c117"></a><!-- doxytag: member="vigra::fourierTransform" ref="g7c5685189df1b4468fb89cf38740c117" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::fourierTransform           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute forward and inverse Fourier transforms. 
<p>
In the forward direction, the input image may be scalar or complex, and the output image is always complex. In the inverse direction, both input and output must be complex.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> SrcImageIterator, <span class="keyword">class</span> SrcAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__FourierTransform.html#g7c5685189df1b4468fb89cf38740c117" title="Compute forward and inverse Fourier transforms.">fourierTransform</a>(SrcImageIterator srcUpperLeft,
                              SrcImageIterator srcLowerRight, SrcAccessor src,
                              <a class="code" href="classvigra_1_1BasicImage.html#94032047b4445f0822d7508a3ffff034">FFTWComplexImage::traverser</a> destUpperLeft, <a class="code" href="classvigra_1_1BasicImage.html#28a41780fa37a19501034e86747e45b7">FFTWComplexImage::Accessor</a> dest);

        <span class="keywordtype">void</span>
        <a class="code" href="group__FourierTransform.html#g6a42d9c7d695d6d58fa4e3a3da29e5e3" title="Compute inverse Fourier transforms.">fourierTransformInverse</a>(<a class="code" href="classvigra_1_1BasicImage.html#0e56cb0f6842d3f9f30361ca669a3b15">FFTWComplexImage::const_traverser</a> sul,
                                <a class="code" href="classvigra_1_1BasicImage.html#0e56cb0f6842d3f9f30361ca669a3b15">FFTWComplexImage::const_traverser</a> slr, <a class="code" href="classvigra_1_1BasicImage.html#65676f5294c2039d907f09346c4c2b4c">FFTWComplexImage::ConstAccessor</a> src,
                                <a class="code" href="classvigra_1_1BasicImage.html#94032047b4445f0822d7508a3ffff034">FFTWComplexImage::traverser</a> dul, <a class="code" href="classvigra_1_1BasicImage.html#28a41780fa37a19501034e86747e45b7">FFTWComplexImage::Accessor</a> dest)
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> SrcImageIterator, <span class="keyword">class</span> SrcAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__FourierTransform.html#g7c5685189df1b4468fb89cf38740c117" title="Compute forward and inverse Fourier transforms.">fourierTransform</a>(triple&lt;SrcImageIterator, SrcImageIterator, SrcAccessor&gt; src,
                              pair&lt;FFTWComplexImage::traverser, FFTWComplexImage::Accessor&gt; dest);

        <span class="keywordtype">void</span>
        <a class="code" href="group__FourierTransform.html#g6a42d9c7d695d6d58fa4e3a3da29e5e3" title="Compute inverse Fourier transforms.">fourierTransformInverse</a>(triple&lt;<a class="code" href="classvigra_1_1BasicImage.html#0e56cb0f6842d3f9f30361ca669a3b15">FFTWComplexImage::const_traverser</a>,
                                       <a class="code" href="classvigra_1_1BasicImage.html#0e56cb0f6842d3f9f30361ca669a3b15">FFTWComplexImage::const_traverser</a>, <a class="code" href="classvigra_1_1BasicImage.html#65676f5294c2039d907f09346c4c2b4c">FFTWComplexImage::ConstAccessor</a>&gt; src,
                                pair&lt;FFTWComplexImage::traverser, FFTWComplexImage::Accessor&gt; dest);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="fftw3_8hxx-source.html">vigra/fftw3.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <span class="comment">// compute complex Fourier transform of a real image</span>
    <a class="code" href="classvigra_1_1BasicImage.html">vigra::DImage</a> src(w, h);
    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FFTWComplexImage</a> fourier(w, h);

    <a class="code" href="group__FourierTransform.html#g7c5685189df1b4468fb89cf38740c117" title="Compute forward and inverse Fourier transforms.">fourierTransform</a>(srcImageRange(src), destImage(fourier));

    <span class="comment">// compute inverse Fourier transform</span>
    <span class="comment">// note that both source and destination image must be of type vigra::FFTWComplexImage</span>
    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FFTWComplexImage</a> inverseFourier(w, h);

    <a class="code" href="group__FourierTransform.html#g7c5685189df1b4468fb89cf38740c117" title="Compute forward and inverse Fourier transforms.">fourierTransform</a>(srcImageRange(fourier), destImage(inverseFourier));
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g6a42d9c7d695d6d58fa4e3a3da29e5e3"></a><!-- doxytag: member="vigra::fourierTransformInverse" ref="g6a42d9c7d695d6d58fa4e3a3da29e5e3" args="(FFTWComplexImage::const_traverser sul, FFTWComplexImage::const_traverser slr, FFTWComplexImage::ConstAccessor src, FFTWComplexImage::traverser dul, FFTWComplexImage::Accessor dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vigra::fourierTransformInverse           </td>
          <td>(</td>
          <td class="paramtype">FFTWComplexImage::const_traverser&nbsp;</td>
          <td class="paramname"> <em>sul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FFTWComplexImage::const_traverser&nbsp;</td>
          <td class="paramname"> <em>slr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FFTWComplexImage::ConstAccessor&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FFTWComplexImage::traverser&nbsp;</td>
          <td class="paramname"> <em>dul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FFTWComplexImage::Accessor&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute inverse Fourier transforms. 
<p>
See <a class="el" href="group__FourierTransform.html#g7c5685189df1b4468fb89cf38740c117">fourierTransform()</a> for details. 
</div>
</div><p>
<a class="anchor" name="g17b002839f4a650ab309ec55475db6fc"></a><!-- doxytag: member="vigra::applyFourierFilter" ref="g17b002839f4a650ab309ec55475db6fc" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::applyFourierFilter           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply a filter (defined in the frequency domain) to an image. 
<p>
After transferring the image into the frequency domain, it is multiplied pixel-wise with the filter and transformed back. The result is put into the given destination image which must have the right size. The result will be normalized to compensate for the two FFTs.<p>
If the destination image is scalar, only the real part of the result image is retained. In this case, you are responsible for choosing a filter image which ensures a zero imaginary part of the result (e.g. use a real, even symmetric filter image, or a purely imaginary, odd symmetric on).<p>
The DC entry of the filter must be in the upper left, which is the position where FFTW expects it (see <a class="el" href="group__FourierTransform.html#g1b3270b463603b5ec5641d10555030da">moveDCToUpperLeft()</a>).<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>FilterImageIterator, <span class="keyword">class </span>FilterAccessor,
                  <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__FourierTransform.html#g17b002839f4a650ab309ec55475db6fc" title="Apply a filter (defined in the frequency domain) to an image.">applyFourierFilter</a>(SrcImageIterator srcUpperLeft,
                                SrcImageIterator srcLowerRight, SrcAccessor sa,
                                FilterImageIterator filterUpperLeft, FilterAccessor fa,
                                DestImageIterator destUpperLeft, DestAccessor da);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>FilterImageIterator, <span class="keyword">class </span>FilterAccessor,
                  <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__FourierTransform.html#g17b002839f4a650ab309ec55475db6fc" title="Apply a filter (defined in the frequency domain) to an image.">applyFourierFilter</a>(triple&lt;SrcImageIterator, SrcImageIterator, SrcAccessor&gt; src,
                                pair&lt;FilterImageIterator, FilterAccessor&gt; filter,
                                pair&lt;DestImageIterator, DestAccessor&gt; dest);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="fftw3_8hxx-source.html">vigra/fftw3.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <span class="comment">// create a Gaussian filter in Fourier space</span>
    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FImage</a> gaussFilter(w, h), filter(w, h);
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;h; ++y)
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;w; ++x)
        {
            xx = float(x - w / 2) / w;
            yy = float(y - h / 2) / h;

            gaussFilter(x,y) = <a class="code" href="group__LinearAlgebraFunctions.html#ga8a2c8c6b2788a5b01d093bda22587b4">std::exp</a>(-(xx*xx + yy*yy) / 2.0 * scale);
        }

    <span class="comment">// applyFourierFilter() expects the filter's DC in the upper left</span>
    <a class="code" href="group__FourierTransform.html#g1b3270b463603b5ec5641d10555030da" title="Rearrange the quadrants of a Fourier image so that the origin is in the image&amp;#39;s...">moveDCToUpperLeft</a>(srcImageRange(gaussFilter), destImage(filter));

    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FFTWComplexImage</a> result(w, h);

    <a class="code" href="group__FourierTransform.html#g17b002839f4a650ab309ec55475db6fc" title="Apply a filter (defined in the frequency domain) to an image.">vigra::applyFourierFilter</a>(srcImageRange(image), srcImage(filter), result);
</pre></div><p>
For inspection of the result, <a class="el" href="classvigra_1_1FFTWMagnitudeAccessor.html">FFTWMagnitudeAccessor</a> might be useful. If you want to apply the same filter repeatedly, it may be more efficient to use the FFTW functions directly with FFTW plans optimized for good performance. 
</div>
</div><p>
<a class="anchor" name="gb701decb1fb80640b440d9c323d1c08d"></a><!-- doxytag: member="vigra::applyFourierFilterFamily" ref="gb701decb1fb80640b440d9c323d1c08d" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::applyFourierFilterFamily           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply an array of filters (defined in the frequency domain) to an image. 
<p>
This provides the same functionality as <a class="el" href="group__FourierTransform.html#g17b002839f4a650ab309ec55475db6fc">applyFourierFilter()</a>, but applying several filters at once allows to avoid repeated Fourier transforms of the source image.<p>
Filters and result images must be stored in <a class="el" href="classvigra_1_1ImageArray.html">vigra::ImageArray</a> data structures. In contrast to <a class="el" href="group__FourierTransform.html#g17b002839f4a650ab309ec55475db6fc">applyFourierFilter()</a>, this function adjusts the size of the result images and the the length of the array.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> SrcImageIterator, <span class="keyword">class</span> SrcAccessor, <span class="keyword">class</span> FilterType&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__FourierTransform.html#gb701decb1fb80640b440d9c323d1c08d" title="Apply an array of filters (defined in the frequency domain) to an image.">applyFourierFilterFamily</a>(SrcImageIterator srcUpperLeft,
                                      SrcImageIterator srcLowerRight, SrcAccessor sa,
                                      <span class="keyword">const</span> ImageArray&lt;FilterType&gt; &amp;filters,
                                      ImageArray&lt;FFTWComplexImage&gt; &amp;results)
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> SrcImageIterator, <span class="keyword">class</span> SrcAccessor, <span class="keyword">class</span> FilterType&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__FourierTransform.html#gb701decb1fb80640b440d9c323d1c08d" title="Apply an array of filters (defined in the frequency domain) to an image.">applyFourierFilterFamily</a>(triple&lt;SrcImageIterator, SrcImageIterator, SrcAccessor&gt; src,
                                      <span class="keyword">const</span> ImageArray&lt;FilterType&gt; &amp;filters,
                                      ImageArray&lt;FFTWComplexImage&gt; &amp;results)
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="fftw3_8hxx-source.html">vigra/fftw3.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <span class="comment">// assuming the presence of a real-valued image named "image" to</span>
    <span class="comment">// be filtered in this example</span>

    <a class="code" href="classvigra_1_1ImageArray.html" title="Fundamental class template for arrays of equal-sized images.">vigra::ImageArray&lt;vigra::FImage&gt;</a> filters(16, image.size());

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;filters.size(); i++)
         <span class="comment">// create some meaningful filters here</span>
         createMyFilterOfScale(i, destImage(filters[i]));

    <a class="code" href="classvigra_1_1ImageArray.html" title="Fundamental class template for arrays of equal-sized images.">vigra::ImageArray&lt;vigra::FFTWComplexImage&gt;</a> results();

    <a class="code" href="group__FourierTransform.html#gb701decb1fb80640b440d9c323d1c08d" title="Apply an array of filters (defined in the frequency domain) to an image.">vigra::applyFourierFilterFamily</a>(srcImageRange(image), filters, results);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g551140282b99d1f656839625b38cf509"></a><!-- doxytag: member="vigra::fourierTransformReal" ref="g551140282b99d1f656839625b38cf509" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::fourierTransformReal           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Real Fourier transforms for even and odd boundary conditions (aka. cosine and sine transforms). 
<p>
If the image is real and has even symmetry, its Fourier transform is also real and has even symmetry. The Fourier transform of a real image with odd symmetry is imaginary and has odd symmetry. In either case, only about a quarter of the pixels need to be stored because the rest can be calculated from the symmetry properties. This is especially useful, if the original image is implicitly assumed to have reflective or anti-reflective boundary conditions. Then the "negative" pixel locations are defined as<p>
<div class="fragment"><pre class="fragment">    even (reflective boundary conditions):      f[-x] = f[x]     (x = 1,...,N-1)
    odd (anti-reflective boundary conditions):  f[-1] = 0
                                                f[-x] = -f[x-2]  (x = 2,...,N-1)
</pre></div><p>
end similar at the other boundary (see the FFTW documentation for details). This has the advantage that more efficient Fourier transforms that use only real numbers can be implemented. These are also known as cosine and sine transforms respectively.<p>
If you use the odd transform it is important to note that in the Fourier domain, the DC component is always zero and is therefore dropped from the data structure. This means that index 0 in an odd symmetric Fourier domain image refers to the <em>first</em> harmonic. This is especially important if an image is first cosine transformed (even symmetry), then in the Fourier domain multiplied with an odd symmetric filter (e.g. a first derivative) and finally transformed back to the spatial domain with a sine transform (odd symmetric). For this to work properly the image must be shifted left or up by one pixel (depending on whether the x- or y-axis is odd symmetric) before the inverse transform can be applied. (see example below).<p>
The real Fourier transform functions are named <code>fourierTransformReal??</code> where the questions marks stand for either <code>E</code> or <code>O</code> indicating whether the x- and y-axis is to be transformed using even or odd symmetry. The same functions can be used for both the forward and inverse transforms, only the normalization changes. For signal processing, the following normalization factors are most appropriate:<p>
<div class="fragment"><pre class="fragment">                          forward             <a class="code" href="group__MatrixAlgebra.html#g5242a832201b32d3a1db1386a0c97d97">inverse</a>
    ------------------------------------------------------------
    X even, Y even           1.0         4.0 * (w-1) * (h-1)
    X even, Y odd           -1.0        -4.0 * (w-1) * (h+1)
    X odd,  Y even          -1.0        -4.0 * (w+1) * (h-1)
    X odd,  Y odd            1.0         4.0 * (w+1) * (h+1)
</pre></div><p>
where <code>w</code> and <code>h</code> denote the image width and height.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcTraverser, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestTraverser, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        fourierTransformRealEE(SrcTraverser sul, SrcTraverser slr, SrcAccessor src,
                               DestTraverser dul, DestAccessor dest, fftw_real <a class="code" href="group__FFTWComplexOperators.html#g4dd6e72ef816031458ece2315e520694" title="norm (= magnitude)">norm</a>);

        fourierTransformRealEO, fourierTransformRealOE, fourierTransformRealOO likewise
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcTraverser, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestTraverser, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        fourierTransformRealEE(triple&lt;SrcTraverser, SrcTraverser, SrcAccessor&gt; src,
                               pair&lt;DestTraverser, DestAccessor&gt; dest, fftw_real <a class="code" href="group__FFTWComplexOperators.html#g4dd6e72ef816031458ece2315e520694" title="norm (= magnitude)">norm</a>);

        fourierTransformRealEO, fourierTransformRealOE, fourierTransformRealOO likewise
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="fftw3_8hxx-source.html">vigra/fftw3.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FImage</a> spatial(width,height), fourier(width,height);
    ... <span class="comment">// fill image with data</span>

    <span class="comment">// forward cosine transform == reflective boundary conditions</span>
    fourierTransformRealEE(srcImageRange(spatial), destImage(fourier), (fftw_real)1.0);

    <span class="comment">// multiply with a first derivative of Gaussian in x-direction</span>
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y = 0; y &lt; height; ++y)
    {
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> x = 1; x &lt; width; ++x)
        {
            <span class="keywordtype">double</span> dx = x * M_PI / (width - 1);
            <span class="keywordtype">double</span> dy = y * M_PI / (height - 1);
            fourier(x-1, y) = fourier(x, y) * dx * <a class="code" href="group__LinearAlgebraFunctions.html#ga8a2c8c6b2788a5b01d093bda22587b4">std::exp</a>(-(dx*dx + dy*dy) * scale*scale / 2.0);
        }
        fourier(width-1, y) = 0.0;
    }

    <span class="comment">// inverse transform -- odd symmetry in x-direction, even in y,</span>
    <span class="comment">//                      due to symmetry of the filter</span>
    fourierTransformRealOE(srcImageRange(fourier), destImage(spatial),
                           (fftw_real)-4.0 * (width+1) * (height-1));
</pre></div> 
</div>
</div><p>
</div>
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
VIGRA 1.6.0 (13 Aug 2008)
</i>
</tr>
</table>


</BODY>
</HTML>
