<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>VIGRA - VIGRA: Tensor Image Processing</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%">Tensor Image Processing
</td>
<td align=right><a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif"></a></td></tr>
</table><p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorImaging.html#g3f60d75d3f938c3805544c28e5aa0053">boundaryTensor</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the boundary tensor for a scalar valued image.  <a href="#g3f60d75d3f938c3805544c28e5aa0053"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorImaging.html#gff224e8e3128d9634daff97e5b880123">boundaryTensor1</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Boundary tensor variant.  <a href="#gff224e8e3128d9634daff97e5b880123"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorImaging.html#g9f3d267d141dc95bfdd47afae43a2c12">gradientEnergyTensor</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the gradient energy tensor for a scalar valued image.  <a href="#g9f3d267d141dc95bfdd47afae43a2c12"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorImaging.html#gfc744b33345f5ed70eb6ab035f803de0">hourGlassFilter</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Anisotropic tensor smoothing with the hourglass filter.  <a href="#gfc744b33345f5ed70eb6ab035f803de0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorImaging.html#gda3e358fe5b3958d47d231b29989a974">tensorEigenRepresentation</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate eigen representation of a symmetric 2x2 tensor.  <a href="#gda3e358fe5b3958d47d231b29989a974"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorImaging.html#g7b5fa205db15363e5dd698bad8fa31e3">tensorToEdgeCorner</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decompose a symmetric 2x2 tensor into its edge and corner parts.  <a href="#g7b5fa205db15363e5dd698bad8fa31e3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorImaging.html#ge017cadd131dffa36d424c4a179c9d4b">tensorTrace</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the trace of a 2x2 tensor.  <a href="#ge017cadd131dffa36d424c4a179c9d4b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TensorImaging.html#g4b6a3d8bb2712314c8f35549e6ed64aa">vectorToTensor</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the tensor (outer) product of a 2D vector with itself.  <a href="#g4b6a3d8bb2712314c8f35549e6ed64aa"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g3f60d75d3f938c3805544c28e5aa0053"></a><!-- doxytag: member="vigra::boundaryTensor" ref="g3f60d75d3f938c3805544c28e5aa0053" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::boundaryTensor           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the boundary tensor for a scalar valued image. 
<p>
These functions calculate a spatial domain approximation of the boundary tensor as described in<p>
U. K&ouml;the: <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/papers/abstracts/polarfilters.html"><em>"Integrated Edge and Junction Detection with the Boundary Tensor"</em></a>, in: ICCV 03, Proc. of 9th Intl. Conf. on Computer Vision, Nice 2003, vol. 1, pp. 424-431, Los Alamitos: IEEE Computer Society, 2003<p>
with the Laplacian of <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> as the underlying bandpass filter (see <a class="el" href="group__CommonConvolutionFilters.html#g067b2f50f0b34ee834d93c71a2a1f056">rieszTransformOfLOG()</a>). The output image must have 3 bands which will hold the tensor components in the order t11, t12 (== t21), t22. The function <a class="el" href="group__TensorImaging.html#gff224e8e3128d9634daff97e5b880123">boundaryTensor1()</a> with the same interface implements a variant of the boundary tensor where the 0th-order Riesz transform has been dropped, so that the tensor is no longer sensitive to blobs.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__TensorImaging.html#g3f60d75d3f938c3805544c28e5aa0053" title="Calculate the boundary tensor for a scalar valued image.">boundaryTensor</a>(SrcIterator supperleft, SrcIterator slowerright, SrcAccessor src,
                            DestIterator dupperleft, DestAccessor dest,
                            <span class="keywordtype">double</span> scale);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__TensorImaging.html#g3f60d75d3f938c3805544c28e5aa0053" title="Calculate the boundary tensor for a scalar valued image.">boundaryTensor</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
                            pair&lt;DestIterator, DestAccessor&gt; dest,
                            <span class="keywordtype">double</span> scale);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="boundarytensor_8hxx-source.html">vigra/boundarytensor.hxx</a>&gt;<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__StandardImageTypes.html#g1170a9252f2ce52a075238e327ec78f0">FImage</a> img(w,h);
    <a class="code" href="group__StandardImageTypes.html#gf1f737b060f00b6e0f9dad8d75cb0740">FVector3Image</a> bt(w,h);
    ...
    <a class="code" href="group__TensorImaging.html#g3f60d75d3f938c3805544c28e5aa0053" title="Calculate the boundary tensor for a scalar valued image.">boundaryTensor</a>(srcImageRange(img), destImage(bt), 2.0);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="gff224e8e3128d9634daff97e5b880123"></a><!-- doxytag: member="vigra::boundaryTensor1" ref="gff224e8e3128d9634daff97e5b880123" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::boundaryTensor1           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Boundary tensor variant. 
<p>
This function implements a variant of the boundary tensor where the 0th-order Riesz transform has been dropped, so that the tensor is no longer sensitive to blobs. See <a class="el" href="group__TensorImaging.html#g3f60d75d3f938c3805544c28e5aa0053">boundaryTensor()</a> for more detailed documentation.<p>
<b> Declarations:</b><p>
<b>#include</b> &lt;<a href="boundarytensor_8hxx-source.html">vigra/boundarytensor.hxx</a>&gt;<p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__TensorImaging.html#gff224e8e3128d9634daff97e5b880123" title="Boundary tensor variant.">boundaryTensor1</a>(SrcIterator supperleft, SrcIterator slowerright, SrcAccessor src,
                             DestIterator dupperleft, DestAccessor dest,
                             <span class="keywordtype">double</span> scale);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__TensorImaging.html#gff224e8e3128d9634daff97e5b880123" title="Boundary tensor variant.">boundaryTensor1</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
                             pair&lt;DestIterator, DestAccessor&gt; dest,
                             <span class="keywordtype">double</span> scale);
    }
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g9f3d267d141dc95bfdd47afae43a2c12"></a><!-- doxytag: member="vigra::gradientEnergyTensor" ref="g9f3d267d141dc95bfdd47afae43a2c12" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::gradientEnergyTensor           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the gradient energy tensor for a scalar valued image. 
<p>
These function calculates the gradient energy tensor (GET operator) as described in<p>
M. Felsberg, U. K&ouml;the: <em>"GET: The Connection Between Monogenic Scale-Space and Gaussian Derivatives"</em>, in: R. Kimmel, N. Sochen, J. Weickert (Eds.): Scale Space and PDE Methods in Computer Vision, Proc. of Scale-Space 2005, Lecture Notes in Computer Science 3459, pp. 192-203, Heidelberg: Springer, 2005.<p>
U. K&ouml;the, M. Felsberg: <em>"Riesz-Transforms Versus Derivatives: On the Relationship Between the Boundary Tensor and the Energy Tensor"</em>, in: ditto, pp. 179-191.<p>
with the given filters: The derivative filter <em>derivKernel</em> is applied to the appropriate image dimensions in turn (see the papers above for details), and the other dimension is smoothed with <em>smoothKernel</em>. The kernels can be as small as 3x1, e.g. [0.5, 0, -0.5] and [3.0/16.0, 10.0/16.0, 3.0/16.0] respectively. The output image must have 3 bands which will hold the tensor components in the order t11, t12 (== t21), t22. The signs of the output are adjusted for a right-handed coordinate system. Thus, orientations derived from the tensor will be in counter-clockwise (mathematically positive) order, with the x-axis at zero degrees (this is the standard in all VIGRA functions that deal with orientation).<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__TensorImaging.html#g9f3d267d141dc95bfdd47afae43a2c12" title="Calculate the gradient energy tensor for a scalar valued image.">gradientEnergyTensor</a>(SrcIterator supperleft, SrcIterator slowerright, SrcAccessor src,
                                  DestIterator dupperleft, DestAccessor dest,
                                  Kernel1D&lt;double&gt; <span class="keyword">const</span> &amp; derivKernel, Kernel1D&lt;double&gt; <span class="keyword">const</span> &amp; smoothKernel);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__TensorImaging.html#g9f3d267d141dc95bfdd47afae43a2c12" title="Calculate the gradient energy tensor for a scalar valued image.">gradientEnergyTensor</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
                                  pair&lt;DestIterator, DestAccessor&gt; dest,
                                  Kernel1D&lt;double&gt; <span class="keyword">const</span> &amp; derivKernel, Kernel1D&lt;double&gt; <span class="keyword">const</span> &amp; smoothKernel);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="gradient__energy__tensor_8hxx-source.html">vigra/gradient_energy_tensor.hxx</a>&gt;<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__StandardImageTypes.html#g1170a9252f2ce52a075238e327ec78f0">FImage</a> img(w,h);
    <a class="code" href="group__StandardImageTypes.html#gf1f737b060f00b6e0f9dad8d75cb0740">FVector3Image</a> <span class="keyword">get</span>(w,h);
    Kernel1D&lt;double&gt; grad, smooth;
    grad.initGaussianDerivative(0.7, 1);
    smooth.initGaussian(0.7);
    ...
    <a class="code" href="group__TensorImaging.html#g9f3d267d141dc95bfdd47afae43a2c12" title="Calculate the gradient energy tensor for a scalar valued image.">gradientEnergyTensor</a>(srcImageRange(img), destImage(<span class="keyword">get</span>), grad, smooth);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="gfc744b33345f5ed70eb6ab035f803de0"></a><!-- doxytag: member="vigra::hourGlassFilter" ref="gfc744b33345f5ed70eb6ab035f803de0" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::hourGlassFilter           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Anisotropic tensor smoothing with the hourglass filter. 
<p>
This function implements anisotropic tensor smoothing by an hourglass-shaped filters as described in<p>
U. K&ouml;the: <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/papers/abstracts/structureTensor.html"><em>"Edge and Junction Detection with an Improved Structure Tensor"</em></a>, in: Proc. of 25th DAGM Symposium, Magdeburg 2003, Lecture Notes in Computer Science 2781, pp. 25-32, Heidelberg: Springer, 2003<p>
It is closely related to the structure tensor (see <a class="el" href="group__CommonConvolutionFilters.html#g8ab2163bf1d340be1e5e026e4dfd83a5">structureTensor()</a>), but replaces the linear tensor smoothing with a smoothing along edges only. Smoothing accross edges is largely suppressed. This means that the image structure is preserved much better because nearby features such as parallel edges are not blended into each other.<p>
The hourglass filter is typically applied to a gradient tensor, i.e. the Euclidean product of the gradient with itself, which can be obtained by a gradient operator followed with <a class="el" href="group__TensorImaging.html#g4b6a3d8bb2712314c8f35549e6ed64aa">vectorToTensor()</a>, see example below. The hourglass shape of the filter can be interpreted as indicating the likely continuations of a local edge element. The parameter <code>sigma</code> determines the radius of the hourglass (i.e. how far the influence of the edge element reaches), and <code>rho</code> controls its opening angle (i.e. how narrow the edge orientation os followed). Recommended values are <code>sigma = 1.4</code> (or, more generally, two to three times the scale of the gradient operator used in the first step), and <code>rho = 0.4</code> which corresponds to an opening angle of 22.5 degrees to either side of the edge.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__TensorImaging.html#gfc744b33345f5ed70eb6ab035f803de0" title="Anisotropic tensor smoothing with the hourglass filter.">hourGlassFilter</a>(SrcIterator sul, SrcIterator slr, SrcAccessor src,
                             DestIterator dul, DestAccessor dest,
                             <span class="keywordtype">double</span> sigma, <span class="keywordtype">double</span> rho);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keyword">inline</span>
        <span class="keywordtype">void</span> <a class="code" href="group__TensorImaging.html#gfc744b33345f5ed70eb6ab035f803de0" title="Anisotropic tensor smoothing with the hourglass filter.">hourGlassFilter</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; s,
                             pair&lt;DestIterator, DestAccessor&gt; d,
                             <span class="keywordtype">double</span> sigma, <span class="keywordtype">double</span> rho);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="orientedtensorfilters_8hxx-source.html">vigra/orientedtensorfilters.hxx</a>&gt;<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__StandardImageTypes.html#g1170a9252f2ce52a075238e327ec78f0">FImage</a> img(w,h);
    <a class="code" href="group__StandardImageTypes.html#g1d1599adb292403c7766a7ffa099323e">FVector2Image</a> gradient(w,h);
    <a class="code" href="group__StandardImageTypes.html#gf1f737b060f00b6e0f9dad8d75cb0740">FVector3Image</a> tensor(w,h), smoothedTensor(w,h);
    
    <a class="code" href="group__CommonConvolutionFilters.html#g45f3ac60c35b246600df26492e0a538e" title="Calculate the gradient vector by means of a 1st derivatives of Gaussian filter.">gaussianGradient</a>(srcImageRange(img), destImage(gradient), 1.0);
    <a class="code" href="group__TensorImaging.html#g4b6a3d8bb2712314c8f35549e6ed64aa" title="Calculate the tensor (outer) product of a 2D vector with itself.">vectorToTensor</a>(srcImageRange(gradient), destImage(tensor));
    <a class="code" href="group__TensorImaging.html#gfc744b33345f5ed70eb6ab035f803de0" title="Anisotropic tensor smoothing with the hourglass filter.">hourGlassFilter</a>(srcImageRange(tensor), destImage(smoothedTensor), 2.0, 0.4);
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__TensorImaging.html#g4b6a3d8bb2712314c8f35549e6ed64aa" title="Calculate the tensor (outer) product of a 2D vector with itself.">vectorToTensor()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4b6a3d8bb2712314c8f35549e6ed64aa"></a><!-- doxytag: member="vigra::vectorToTensor" ref="g4b6a3d8bb2712314c8f35549e6ed64aa" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::vectorToTensor           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the tensor (outer) product of a 2D vector with itself. 
<p>
This function is useful to transform vector images into a tensor representation that can be used as input to tensor based processing and analysis functions (e.g. tensor smoothing). The imput pixel type must be vectors of length 2, whereas the output must contain vectors of length 3 which will represent the tensor components in the order t11, t12 (== t21 due to symmetry), t22.<p>
<b>Note:</b> By default, this function negates the second component of the vector in order to turn a left handed vector (the usual resul of convolution, e.g. a gradient filter, because <code>y</code> runs from top to bottom) into a right handed tensor (as is required by all tensor function in VIGRA). This behavior can be switched off by setting <code>negateComponent2 = false</code>.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__TensorImaging.html#g4b6a3d8bb2712314c8f35549e6ed64aa" title="Calculate the tensor (outer) product of a 2D vector with itself.">vectorToTensor</a>(SrcIterator sul, SrcIterator slr, SrcAccessor src,
                            DestIterator dul, DestAccessor dest,
                            <span class="keywordtype">bool</span> negateComponent2 = <span class="keyword">true</span>);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__TensorImaging.html#g4b6a3d8bb2712314c8f35549e6ed64aa" title="Calculate the tensor (outer) product of a 2D vector with itself.">vectorToTensor</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; s,
                            pair&lt;DestIterator, DestAccessor&gt; d,
                            <span class="keywordtype">bool</span> negateComponent2 = <span class="keyword">true</span>);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="tensorutilities_8hxx-source.html">vigra/tensorutilities.hxx</a>&gt;<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__StandardImageTypes.html#g1170a9252f2ce52a075238e327ec78f0">FImage</a> img(w,h);
    <a class="code" href="group__StandardImageTypes.html#g1d1599adb292403c7766a7ffa099323e">FVector2Image</a> gradient(w,h);
    <a class="code" href="group__StandardImageTypes.html#gf1f737b060f00b6e0f9dad8d75cb0740">FVector3Image</a> tensor(w,h);
    
    <a class="code" href="group__CommonConvolutionFilters.html#g45f3ac60c35b246600df26492e0a538e" title="Calculate the gradient vector by means of a 1st derivatives of Gaussian filter.">gaussianGradient</a>(srcImageRange(img), destImage(gradient), 2.0);
    <a class="code" href="group__TensorImaging.html#g4b6a3d8bb2712314c8f35549e6ed64aa" title="Calculate the tensor (outer) product of a 2D vector with itself.">vectorToTensor</a>(srcImageRange(gradient), destImage(tensor));
</pre></div> 
</div>
</div><p>
<a class="anchor" name="gda3e358fe5b3958d47d231b29989a974"></a><!-- doxytag: member="vigra::tensorEigenRepresentation" ref="gda3e358fe5b3958d47d231b29989a974" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::tensorEigenRepresentation           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate eigen representation of a symmetric 2x2 tensor. 
<p>
This function turns a 3-band image representing the tensor components t11, t12 (== t21 due to symmetry), t22 into the a 3-band image holding the eigen representation e1, e2, and angle, where e1 &gt; e2. The original tensor must be defined in a right-handed coordinate system, and the angle of the tensor will then be given in mathematical positive (counter-clockwise) orientation, starting at the x-axis.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__TensorImaging.html#gda3e358fe5b3958d47d231b29989a974" title="Calculate eigen representation of a symmetric 2x2 tensor.">tensorEigenRepresentation</a>(SrcIterator sul, SrcIterator slr, SrcAccessor src,
                                       DestIterator dul, DestAccessor dest);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__TensorImaging.html#gda3e358fe5b3958d47d231b29989a974" title="Calculate eigen representation of a symmetric 2x2 tensor.">tensorEigenRepresentation</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; s,
                                       pair&lt;DestIterator, DestAccessor&gt; d);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="tensorutilities_8hxx-source.html">vigra/tensorutilities.hxx</a>&gt;<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__StandardImageTypes.html#gf1f737b060f00b6e0f9dad8d75cb0740">FVector3Image</a> tensor(w,h);
    <a class="code" href="group__StandardImageTypes.html#gf1f737b060f00b6e0f9dad8d75cb0740">FVector3Image</a> eigen(w,h);
    
    <a class="code" href="group__TensorImaging.html#gda3e358fe5b3958d47d231b29989a974" title="Calculate eigen representation of a symmetric 2x2 tensor.">tensorEigenRepresentation</a>(srcImageRange(tensor), destImage(eigen));
</pre></div> 
</div>
</div><p>
<a class="anchor" name="ge017cadd131dffa36d424c4a179c9d4b"></a><!-- doxytag: member="vigra::tensorTrace" ref="ge017cadd131dffa36d424c4a179c9d4b" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::tensorTrace           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the trace of a 2x2 tensor. 
<p>
This function turns a 3-band image representing the tensor components t11, t12 (== t21 due to symmetry), t22 into the a 1-band image holding the tensor trace t11 + t22.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__TensorImaging.html#ge017cadd131dffa36d424c4a179c9d4b" title="Calculate the trace of a 2x2 tensor.">tensorTrace</a>(SrcIterator sul, SrcIterator slr, SrcAccessor src,
                         DestIterator dul, DestAccessor dest);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__TensorImaging.html#ge017cadd131dffa36d424c4a179c9d4b" title="Calculate the trace of a 2x2 tensor.">tensorTrace</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; s,
                         pair&lt;DestIterator, DestAccessor&gt; d);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="tensorutilities_8hxx-source.html">vigra/tensorutilities.hxx</a>&gt;<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__StandardImageTypes.html#gf1f737b060f00b6e0f9dad8d75cb0740">FVector3Image</a> tensor(w,h);
    <a class="code" href="group__StandardImageTypes.html#g1170a9252f2ce52a075238e327ec78f0">FImage</a> trace(w,h);
    
    <a class="code" href="group__TensorImaging.html#ge017cadd131dffa36d424c4a179c9d4b" title="Calculate the trace of a 2x2 tensor.">tensorTrace</a>(srcImageRange(tensor), destImage(trace));
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g7b5fa205db15363e5dd698bad8fa31e3"></a><!-- doxytag: member="vigra::tensorToEdgeCorner" ref="g7b5fa205db15363e5dd698bad8fa31e3" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::tensorToEdgeCorner           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Decompose a symmetric 2x2 tensor into its edge and corner parts. 
<p>
This function turns a 3-band image representing the tensor components t11, t12 (== t21 due to symmetry), t22 into the a 2-band image holding the tensor's edgeness (difference of the tensor's eigenvalues) and orientation, and a 1-band image representing its corner part (equal to the twice the small eigen value). The original tensor must be positive definite and defined in a right-handed coordinate system (e.g. the tensor resulting from <a class="el" href="group__TensorImaging.html#g3f60d75d3f938c3805544c28e5aa0053">boundaryTensor()</a>).<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator1, <span class="keyword">class </span>DestAccessor1,
                  <span class="keyword">class </span>DestIterator2, <span class="keyword">class </span>DestAccessor2&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__TensorImaging.html#g7b5fa205db15363e5dd698bad8fa31e3" title="Decompose a symmetric 2x2 tensor into its edge and corner parts.">tensorToEdgeCorner</a>(SrcIterator sul, SrcIterator slr, SrcAccessor src,
                                DestIterator1 edgeul, DestAccessor1 edge,
                                DestIterator2 cornerul, DestAccessor2 corner);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator1, <span class="keyword">class </span>DestAccessor1,
                  <span class="keyword">class </span>DestIterator2, <span class="keyword">class </span>DestAccessor2&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__TensorImaging.html#g7b5fa205db15363e5dd698bad8fa31e3" title="Decompose a symmetric 2x2 tensor into its edge and corner parts.">tensorToEdgeCorner</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; s,
                                pair&lt;DestIterator1, DestAccessor1&gt; edge,
                                pair&lt;DestIterator2, DestAccessor2&gt; corner);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="tensorutilities_8hxx-source.html">vigra/tensorutilities.hxx</a>&gt;<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__StandardImageTypes.html#gf1f737b060f00b6e0f9dad8d75cb0740">FVector3Image</a> tensor(w,h);
    <a class="code" href="group__StandardImageTypes.html#g1d1599adb292403c7766a7ffa099323e">FVector2Image</a> edgePart(w,h);
    <a class="code" href="group__StandardImageTypes.html#g1170a9252f2ce52a075238e327ec78f0">FImage</a> cornerPart(w,h);
    
    <a class="code" href="group__TensorImaging.html#ge017cadd131dffa36d424c4a179c9d4b" title="Calculate the trace of a 2x2 tensor.">tensorTrace</a>(srcImageRange(tensor), destImage(edgePart), destImage(cornerPart));
</pre></div> 
</div>
</div><p>
</div>
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
VIGRA 1.6.0 (13 Aug 2008)
</i>
</tr>
</table>


</BODY>
</HTML>
