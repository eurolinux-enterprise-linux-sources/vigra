<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>VIGRA - VIGRA: Two-dimensional convolution functions</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Two-dimensional convolution functions
</td>
<td align=right><a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif"></a></td></tr>
</table><p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class SrcIterator, class SrcAccessor, class DestIterator, class DestAccessor, class KernelIterator, class KernelAccessor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__StandardConvolution.html#gc147d74c0f049bb206e264dd8baed2fc">convolveImage</a> (SrcIterator src_ul, SrcIterator src_lr, SrcAccessor src_acc, DestIterator dest_ul, DestAccessor dest_acc, KernelIterator ki, KernelAccessor ak, Diff2D kul, Diff2D klr, BorderTreatmentMode border)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a 2 dimensional convolution of the source image using the given kernel.  <a href="#gc147d74c0f049bb206e264dd8baed2fc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__StandardConvolution.html#g684765dd3aa358959da2051dbb9ee4d1">convolveImageWithMask</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deprecated name of 2-dimensional normalized convolution, i.e. convolution with a mask image.  <a href="#g684765dd3aa358959da2051dbb9ee4d1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__StandardConvolution.html#gda968281f4992ffb636914bb4545ff87">normalizedConvolveImage</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a 2-dimensional normalized convolution, i.e. convolution with a mask image.  <a href="#gda968281f4992ffb636914bb4545ff87"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2 class="details_section">Detailed Description</h2>
Perform 2D non-separable convolution, with and without ROI mask.<p>
These generic convolution functions implement the standard 2D convolution operation for images that fit into the required interface. Arbitrary ROI's are supported by the mask version of the algorithm. The functions need a suitable 2D kernel to operate. <hr><h2>Function Documentation</h2>
<a class="anchor" name="gc147d74c0f049bb206e264dd8baed2fc"></a><!-- doxytag: member="vigra::convolveImage" ref="gc147d74c0f049bb206e264dd8baed2fc" args="(SrcIterator src_ul, SrcIterator src_lr, SrcAccessor src_acc, DestIterator dest_ul, DestAccessor dest_acc, KernelIterator ki, KernelAccessor ak, Diff2D kul, Diff2D klr, BorderTreatmentMode border)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class SrcIterator, class SrcAccessor, class DestIterator, class DestAccessor, class KernelIterator, class KernelAccessor&gt; </td></tr><tr>
          <td class="memname">void vigra::convolveImage           </td>
          <td>(</td>
          <td class="paramtype">SrcIterator&nbsp;</td>
          <td class="paramname"> <em>src_ul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SrcIterator&nbsp;</td>
          <td class="paramname"> <em>src_lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SrcAccessor&nbsp;</td>
          <td class="paramname"> <em>src_acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DestIterator&nbsp;</td>
          <td class="paramname"> <em>dest_ul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DestAccessor&nbsp;</td>
          <td class="paramname"> <em>dest_acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KernelIterator&nbsp;</td>
          <td class="paramname"> <em>ki</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KernelAccessor&nbsp;</td>
          <td class="paramname"> <em>ak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Diff2D&nbsp;</td>
          <td class="paramname"> <em>kul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Diff2D&nbsp;</td>
          <td class="paramname"> <em>klr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BorderTreatmentMode&nbsp;</td>
          <td class="paramname"> <em>border</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a 2 dimensional convolution of the source image using the given kernel. 
<p>
The KernelIterator must point to the center of the kernel, and the kernel's size is given by its upper left (x and y of distance &lt;= 0) and lower right (distance &gt;= 0) corners. The image must always be larger than the kernel. At those positions where the kernel does not completely fit into the image, the specified <a class="el" href="BorderTreatmentMode.html">BorderTreatmentMode</a> is applied. You can choice between following BorderTreatmentModes: <ul>
<li>
BORDER_TREATMENT_CLIP </li>
<li>
BORDER_TREATMENT_AVOID </li>
<li>
BORDER_TREATMENT_WRAP </li>
<li>
BORDER_TREATMENT_REFLECT </li>
<li>
BORDER_TREATMENT_REPEAT </li>
</ul>
<br>
 The images's pixel type (SrcAccessor::value_type) must be a linear space over the kernel's value_type (KernelAccessor::value_type), i.e. addition of source values, multiplication with kernel values, and NumericTraits must be defined. The kernel's value_type must be an algebraic field, i.e. the arithmetic operations (+, -, *, /) and NumericTraits must be defined.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>KernelAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__CommonConvolutionFilters.html#g4c1308148e93b0ad69932c352f17b67e" title="Apply two separable filters successively, the first in x-direction, the second in...">convolveImage</a>(SrcIterator src_ul, SrcIterator src_lr, SrcAccessor src_acc,
                           DestIterator dest_ul, DestAccessor dest_acc,
                           KernelIterator ki, KernelAccessor ak,
                           Diff2D kul, Diff2D klr, BorderTreatmentMode border);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>KernelAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__CommonConvolutionFilters.html#g4c1308148e93b0ad69932c352f17b67e" title="Apply two separable filters successively, the first in x-direction, the second in...">convolveImage</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
                           pair&lt;DestIterator, DestAccessor&gt; dest,
                           tuple5&lt;KernelIterator, KernelAccessor, Diff2D, Diff2D,
                           BorderTreatmentMode&gt; kernel);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="stdconvolution_8hxx-source.html">vigra/stdconvolution.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FImage</a> src(w,h), dest(w,h);
    ...

    <span class="comment">// define horizontal Sobel filter</span>
    <a class="code" href="classvigra_1_1Kernel2D.html" title="Generic 2 dimensional convolution kernel.">vigra::Kernel2D&lt;float&gt;</a> sobel;

    sobel.<a class="code" href="classvigra_1_1Kernel2D.html#655f2e66826607be6901a295d1216c9f">initExplicitly</a>(Diff2D(-1,-1), Diff2D(1,1)) =  <span class="comment">// upper left and lower right</span>
                         0.125, 0.0, -0.125,
                         0.25,  0.0, -0.25,
                         0.125, 0.0, -0.125;
    sobel.<a class="code" href="classvigra_1_1Kernel2D.html#647df9e68cc4da54a5c9d2ba13768c9a">setBorderTreatment</a>(vigra::BORDER_TREATMENT_REFLECT);

    <a class="code" href="group__CommonConvolutionFilters.html#g4c1308148e93b0ad69932c352f17b67e" title="Apply two separable filters successively, the first in x-direction, the second in...">vigra::convolveImage</a>(srcImageRange(src), destImage(dest), kernel2d(sobel));
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    ImageIterator src_ul, src_lr;
    ImageIterator dest_ul;
    ImageIterator ik;

    SrcAccessor src_accessor;
    DestAccessor dest_accessor;
    KernelAccessor kernel_accessor;

    NumericTraits&lt;SrcAccessor::value_type&gt;::RealPromote s = src_accessor(src_ul);

    s = s + s;
    s = kernel_accessor(ik) * s;
    s -= s;

    dest_accessor.set(
    NumericTraits&lt;DestAccessor::value_type&gt;::fromRealPromote(s), dest_ul);

    NumericTraits&lt;KernelAccessor::value_type&gt;::RealPromote k = kernel_accessor(ik);

    k += k;
    k -= k;
    k = k / k;
</pre></div><p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">    kul.x &lt;= 0
    kul.y &lt;= 0
    klr.x &gt;= 0
    klr.y &gt;= 0
    src_lr.x - src_ul.x &gt;= klr.x + kul.x + 1
    src_lr.y - src_ul.y &gt;= klr.y + kul.y + 1
</pre></div><p>
If border == BORDER_TREATMENT_CLIP: Sum of kernel elements must be != 0. 
</div>
</div><p>
<a class="anchor" name="gda968281f4992ffb636914bb4545ff87"></a><!-- doxytag: member="vigra::normalizedConvolveImage" ref="gda968281f4992ffb636914bb4545ff87" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::normalizedConvolveImage           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a 2-dimensional normalized convolution, i.e. convolution with a mask image. 
<p>
This functions computes <a href="http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/PIRODDI1/NormConv/NormConv.html">normalized convolution</a> as defined in Knutsson, H. and Westin, C-F.: <em>Normalized and differential convolution: Methods for Interpolation and Filtering of incomplete and uncertain data</em>. Proc. of the IEEE Conf. on Computer Vision and Pattern Recognition, 1993, 515-523.<p>
The mask image must be binary and encodes which pixels of the original image are valid. It is used as follows: Only pixel under the mask are used in the calculations. Whenever a part of the kernel lies outside the mask, it is ignored, and the kernel is renormalized to its original norm (analogous to the CLIP <a class="el" href="BorderTreatmentMode.html">BorderTreatmentMode</a>). Thus, a useful convolution result is computed whenever <em>at least one valid pixel is within the current window</em> Thus, destination pixels not under the mask still receive a value if they are <em>near</em> the mask. Therefore, this algorithm is useful as an interpolator of sparse input data. If you are only interested in the destination values under the mask, you can perform a subsequent <a class="el" href="group__CopyAlgo.html#g0d396cbf319b69f8adaba0cb5945ff18">copyImageIf()</a>.<p>
The KernelIterator must point to the center of the kernel, and the kernel's size is given by its upper left (x and y of distance &lt;= 0) and lower right (distance &gt;= 0) corners. The image must always be larger than the kernel. At those positions where the kernel does not completely fit into the image, the specified <a class="el" href="BorderTreatmentMode.html">BorderTreatmentMode</a> is applied. Only BORDER_TREATMENT_CLIP and BORDER_TREATMENT_AVOID are currently supported.<p>
The images's pixel type (SrcAccessor::value_type) must be a linear space over the kernel's value_type (KernelAccessor::value_type), i.e. addition of source values, multiplication with kernel values, and NumericTraits must be defined. The kernel's value_type must be an algebraic field, i.e. the arithmetic operations (+, -, *, /) and NumericTraits must be defined.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>MaskIterator, <span class="keyword">class </span>MaskAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>KernelAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__StandardConvolution.html#gda968281f4992ffb636914bb4545ff87" title="Performs a 2-dimensional normalized convolution, i.e. convolution with a mask image...">normalizedConvolveImage</a>(SrcIterator src_ul, SrcIterator src_lr, SrcAccessor src_acc,
                                MaskIterator <a class="code" href="group__FixedPointOperations.html#g111aabe970f8fc7f228520dcd09378af" title="multiplication with enforced result type.">mul</a>, MaskAccessor am,
                                DestIterator dest_ul, DestAccessor dest_acc,
                                KernelIterator ki, KernelAccessor ak,
                                Diff2D kul, Diff2D klr, BorderTreatmentMode border);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>MaskIterator, <span class="keyword">class </span>MaskAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>KernelAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__StandardConvolution.html#gda968281f4992ffb636914bb4545ff87" title="Performs a 2-dimensional normalized convolution, i.e. convolution with a mask image...">normalizedConvolveImage</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
                                     pair&lt;MaskIterator, MaskAccessor&gt; mask,
                                     pair&lt;DestIterator, DestAccessor&gt; dest,
                                     tuple5&lt;KernelIterator, KernelAccessor, Diff2D, Diff2D,
                                     BorderTreatmentMode&gt; kernel);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="stdconvolution_8hxx-source.html">vigra/stdconvolution.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FImage</a> src(w,h), dest(w,h);
    vigra::CImage mask(w,h);
    ...

    <span class="comment">// define 3x3 binomial filter</span>
    <a class="code" href="classvigra_1_1Kernel2D.html" title="Generic 2 dimensional convolution kernel.">vigra::Kernel2D&lt;float&gt;</a> binom;

    binom.<a class="code" href="classvigra_1_1Kernel2D.html#655f2e66826607be6901a295d1216c9f">initExplicitly</a>(Diff2D(-1,-1), Diff2D(1,1)) =   <span class="comment">// upper left and lower right</span>
                         0.0625, 0.125, 0.0625,
                         0.125,  0.25,  0.125,
                         0.0625, 0.125, 0.0625;

    <a class="code" href="group__StandardConvolution.html#gda968281f4992ffb636914bb4545ff87" title="Performs a 2-dimensional normalized convolution, i.e. convolution with a mask image...">vigra::normalizedConvolveImage</a>(srcImageRange(src), maskImage(mask), destImage(dest), kernel2d(binom));
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    ImageIterator src_ul, src_lr;
    ImageIterator <a class="code" href="group__FixedPointOperations.html#g111aabe970f8fc7f228520dcd09378af" title="multiplication with enforced result type.">mul</a>;
    ImageIterator dest_ul;
    ImageIterator ik;

    SrcAccessor src_accessor;
    MaskAccessor mask_accessor;
    DestAccessor dest_accessor;
    KernelAccessor kernel_accessor;

    NumericTraits&lt;SrcAccessor::value_type&gt;::RealPromote s = src_accessor(src_ul);

    s = s + s;
    s = kernel_accessor(ik) * s;
    s -= s;

    <span class="keywordflow">if</span>(mask_accessor(mul)) ...;

    dest_accessor.set(
    NumericTraits&lt;DestAccessor::value_type&gt;::fromRealPromote(s), dest_ul);

    NumericTraits&lt;KernelAccessor::value_type&gt;::RealPromote k = kernel_accessor(ik);

    k += k;
    k -= k;
    k = k / k;
</pre></div><p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">    kul.x &lt;= 0
    kul.y &lt;= 0
    klr.x &gt;= 0
    klr.y &gt;= 0
    src_lr.x - src_ul.x &gt;= klr.x + kul.x + 1
    src_lr.y - src_ul.y &gt;= klr.y + kul.y + 1
    border == BORDER_TREATMENT_CLIP || border == BORDER_TREATMENT_AVOID
</pre></div><p>
Sum of kernel elements must be != 0. 
</div>
</div><p>
<a class="anchor" name="g684765dd3aa358959da2051dbb9ee4d1"></a><!-- doxytag: member="vigra::convolveImageWithMask" ref="g684765dd3aa358959da2051dbb9ee4d1" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::convolveImageWithMask           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deprecated name of 2-dimensional normalized convolution, i.e. convolution with a mask image. 
<p>
See <a class="el" href="group__StandardConvolution.html#gda968281f4992ffb636914bb4545ff87">normalizedConvolveImage()</a> for documentation.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>MaskIterator, <span class="keyword">class </span>MaskAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>KernelAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__StandardConvolution.html#g684765dd3aa358959da2051dbb9ee4d1" title="Deprecated name of 2-dimensional normalized convolution, i.e. convolution with a...">convolveImageWithMask</a>(SrcIterator src_ul, SrcIterator src_lr, SrcAccessor src_acc,
                              MaskIterator mul, MaskAccessor am,
                              DestIterator dest_ul, DestAccessor dest_acc,
                              KernelIterator ki, KernelAccessor ak,
                              Diff2D kul, Diff2D klr, BorderTreatmentMode border);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>MaskIterator, <span class="keyword">class </span>MaskAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>KernelIterator, <span class="keyword">class </span>KernelAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__StandardConvolution.html#g684765dd3aa358959da2051dbb9ee4d1" title="Deprecated name of 2-dimensional normalized convolution, i.e. convolution with a...">convolveImageWithMask</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
                                   pair&lt;MaskIterator, MaskAccessor&gt; mask,
                                   pair&lt;DestIterator, DestAccessor&gt; dest,
                                   tuple5&lt;KernelIterator, KernelAccessor, Diff2D, Diff2D,
                                   BorderTreatmentMode&gt; kernel);
    }
</pre></div> 
</div>
</div><p>
</div>
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
VIGRA 1.6.0 (13 Aug 2008)
</i>
</tr>
</table>


</BODY>
</HTML>
