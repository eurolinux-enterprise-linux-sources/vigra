<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>VIGRA - VIGRA: IteratorAdaptor Class Template Reference</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">IteratorAdaptor
</td>
<td align=right><a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif"></a></td></tr>
</table><p>
<!-- doxytag: class="vigra::IteratorAdaptor" -->Quickly create 1-dimensional iterator adapters.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="iteratoradapter_8hxx-source.html">vigra/iteratoradapter.hxx</a>&gt;</code>
<p>

<p>
<a href="classvigra_1_1IteratorAdaptor-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1IteratorAdaptor.html#4508aff81c9d94e0a3c317068f7fd4fc">IteratorAdaptor</a> (BaseType const &amp;o)</td></tr>

</table>
<hr><a name="_details"></a><h2 class="details_section">Detailed Description</h2>
<h3 class="details_section">template&lt;class Policy&gt;<br>
 class vigra::IteratorAdaptor&lt; Policy &gt;</h3>

Quickly create 1-dimensional iterator adapters. 
<p>
This class supports the easy creation of 1D iterator adpaters out of existing iterators. To use it, you must first implement a policy class that defines the iterator's behavior. The policy is used to instantiate the IteratorAdapter template, which thus automatically obtains all required functions of an STL-compatible iterator. General information on how this works can be found on the <a href="http://www.boost.org/libs/utility/iterator_adaptors.htm">Boost Iterator Adaptor</a> page, although there are some differences in the details of the boost and VIGRA implementations. Here is an example policy class that just exports the behaviour of the underlying iterator:<p>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;
    <span class="keyword">class </span>TrivialIteratorAdaptorPolicy
    {
      <span class="keyword">public</span>:
        <span class="comment">// the underlying iterator</span>
        <span class="keyword">typedef</span> Iterator                               BaseType;

        <span class="comment">// the adaptor's value type</span>
        <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type          value_type;

        <span class="comment">// the adaptor's difference type (result of 'iter1 - iter2',</span>
        <span class="comment">//                                argument of 'iter[n]')</span>
        <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type     difference_type;

        <span class="comment">// the adaptor's reference type (result of '*iter')</span>
        <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference           reference;

        <span class="comment">// the adaptor's index_reference type (result of 'iter[n]')</span>
        <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::index_reference     index_reference;

        <span class="comment">// the adaptor's pointer type (result of 'iter.operator-&gt;()')</span>
        <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer             pointer;

        <span class="comment">// the adaptor's iterator category</span>
        <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category   iterator_category;

        <span class="comment">// do some additional initialization in the adaptor's constructor</span>
        <span class="keyword">static</span> <span class="keywordtype">void</span> initialize(BaseType &amp; d) {}

        <span class="comment">// called by '*iter', 'iter-&gt;'</span>
        <span class="keyword">static</span> reference dereference(BaseType <span class="keyword">const</span> &amp; d)
            { <span class="keywordflow">return</span> *d; }

        <span class="comment">// called by 'iter[n]'</span>
        <span class="keyword">static</span> index_reference dereference(BaseType d, difference_type n)
            { <span class="keywordflow">return</span> d[n]; }

        <span class="comment">// called by 'iter1 == iter2', 'iter1 != iter2'</span>
        <span class="keyword">static</span> <span class="keywordtype">bool</span> equal(BaseType <span class="keyword">const</span> &amp; d1, BaseType <span class="keyword">const</span> &amp; d2)
            { <span class="keywordflow">return</span> d1 == d2; }

        <span class="comment">// called by 'iter1 &lt; iter2', 'iter1 &lt;= iter2', 'iter1 &gt; iter2', 'iter1 &gt;= iter2'</span>
        <span class="keyword">static</span> <span class="keywordtype">bool</span> less(BaseType <span class="keyword">const</span> &amp; d1, BaseType <span class="keyword">const</span> &amp; d2)
            { <span class="keywordflow">return</span> d1 &lt; d2; }

        <span class="comment">// called by 'iter1 - iter2'</span>
        <span class="keyword">static</span> difference_type difference(BaseType <span class="keyword">const</span> &amp; d1, BaseType <span class="keyword">const</span> &amp; d2)
            { <span class="keywordflow">return</span> d1 - d2; }

        <span class="comment">// called by '++iter', 'iter++'</span>
        <span class="keyword">static</span> <span class="keywordtype">void</span> increment(BaseType &amp; d)
            { ++d; }

        <span class="comment">// called by '--iter', 'iter--'</span>
        <span class="keyword">static</span> <span class="keywordtype">void</span> decrement(BaseType &amp; d)
            { --d; }

        <span class="comment">// called by 'iter += n', 'iter -= n'</span>
        <span class="keyword">static</span> <span class="keywordtype">void</span> advance(BaseType &amp; d, difference_type n)
            { d += n; }
    };
</pre></div><p>
This policy class is used like this:<p>
<div class="fragment"><pre class="fragment">    SomeIterator iter = ...;

    <a class="code" href="classvigra_1_1IteratorAdaptor.html" title="Quickly create 1-dimensional iterator adapters.">vigra::IteratorAdaptor&lt;vigra::TrivialIteratorAdaptorPolicy&lt;SomeIterator&gt;</a> &gt; iter_adaptor(iter);
</pre></div><p>
By changing the definition of the policy members, a wide range of adaptor behaviors can be achieved. If the base iterator isn't a random access iterator, just drop the functions that cannot be implemented. This simply means that some adaptor functions may not be called, as one would expect from an iterator that doesn't support random access. Note also that the <code>BaseType</code> needs not be an iterator - it can be any type that contains the information necessary for the adaptor to do it's work.<p>
<b>#include</b> &lt;<a href="iteratoradapter_8hxx-source.html">vigra/iteratoradapter.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="4508aff81c9d94e0a3c317068f7fd4fc"></a><!-- doxytag: member="vigra::IteratorAdaptor::IteratorAdaptor" ref="4508aff81c9d94e0a3c317068f7fd4fc" args="(BaseType const &amp;o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1IteratorAdaptor.html">IteratorAdaptor</a>           </td>
          <td>(</td>
          <td class="paramtype">BaseType const &amp;&nbsp;</td>
          <td class="paramname"> <em>o</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct from an instance of the policy class' BaseType Note that the functions of the adaptor implement the interface of an random access iterator as defined in the C++ standard, so there is no need for explicit documentation. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>vigra/<a class="el" href="iteratoradapter_8hxx-source.html">iteratoradapter.hxx</a></ul>
</div>
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
VIGRA 1.6.0 (13 Aug 2008)
</i>
</tr>
</table>


</BODY>
</HTML>
