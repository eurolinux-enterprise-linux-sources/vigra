<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>VIGRA - VIGRA: Kernel1D Class Template Reference</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Kernel1D
</td>
<td align=right><a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif"></a></td></tr>
</table><p>
<!-- doxytag: class="vigra::Kernel1D" -->Generic 1 dimensional convolution kernel.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="separableconvolution_8hxx-source.html">vigra/separableconvolution.hxx</a>&gt;</code>
<p>

<p>
<a href="classvigra_1_1Kernel1D-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classvigra_1_1StandardAccessor.html">StandardAccessor</a><br>
&lt; ARITHTYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#6c53fe234330a9d1604e0948fa47174b">Accessor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
InternalVector::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#b5a64d70f2934a8cb54eb8d81f059773">const_iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
InternalVector::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#b6c87d7921339cc42075571aaf0c6534">const_reference</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classvigra_1_1StandardConstAccessor.html">StandardConstAccessor</a><br>
&lt; ARITHTYPE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#a78445962f8673a1e2c1393dab7c7ad8">ConstAccessor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef InternalVector::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#8c0b17e9965a56ba56cb5fedc7119a92">iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef InternalVector::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#def84b9c9d4f014effcfecbca87629d2">Iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef InternalVector::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#130b31490ce7ba9051094274b190940d">reference</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classvigra_1_1ArrayVector.html#dee9ba124f2423126f678c913667a229">InternalVector::value_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classvigra_1_1StandardAccessor.html">Accessor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#c1e543db9ce291e86b9023cdb9202b5b">accessor</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classvigra_1_1StandardConstAccessor.html">ConstAccessor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#40e8567a7e13dacc22cadde2f9d1dcd0">accessor</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BorderTreatmentMode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html#8c0b17e9965a56ba56cb5fedc7119a92">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#fa906590f3f139cdfeb292a15add8e1f">center</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#97c19fd629e175e9b97af74733b2bbd4">initAveraging</a> (int radius)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#b7fe279fbc6c3e2ce60ec778109b9923">initAveraging</a> (int radius, <a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a> norm)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#01c5f04a39f4a11736e787f7d27f6666">initBinomial</a> (int radius)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#c919a292dea182575c698495de0430b2">initBinomial</a> (int radius, <a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a> norm)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#1406a301a1cc659b3098bbcc0a827228">initBurtFilter</a> (double a=0.04785)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#15901db2903a004e09e86ae5fbd66ca2">initDiscreteGaussian</a> (double std_dev)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#80922d43665cec4f4378e8378997feb0">initDiscreteGaussian</a> (double std_dev, <a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a> norm)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#1164e5b808619971ebc0e9783f972dc9">initExplicitly</a> (int left, int right)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#bba907ac90270c3dd8aac14af93f7b58">initGaussian</a> (double std_dev)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#27d9971d7859098dc18549fd6b8b996f">initGaussian</a> (double std_dev, <a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a> norm)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#7eec7322d05865b857efb1449888d918">initGaussianDerivative</a> (double std_dev, int order)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#f85d8b10d8111a088bc30a78c5e791f3">initGaussianDerivative</a> (double std_dev, int order, <a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a> norm)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#1eeff31c2ffd35f352631fbe27d1dcdc">initOptimalFirstDerivative5</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#f5677b3c7ffdc1586c4e9e4a5394daac">initOptimalFirstDerivativeSmoothing3</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#068e7beed066f292a4ba8e777897526f">initOptimalFirstDerivativeSmoothing5</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#b50c7edfcedf325996e21eb74a69a4d0">initOptimalSecondDerivative5</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#0fe353a930022de958b75e9e6311189e">initOptimalSecondDerivativeSmoothing3</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#bbe3a4b86ffdaf0e8e85d5ab7e75ed71">initOptimalSecondDerivativeSmoothing5</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#f4902fcc6fe66ab6646cbe1fdc5e7121">initOptimalSmoothing3</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#75b3593dd18b43b1d5f81532617d8010">initOptimalSmoothing5</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#072b8efc06e0bd9c6f1fd395becebf17">initSecondDifference3</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#8feea4952f1c61fc8643bbcd23afe103">initSymmetricDifference</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#50d0fbcbdb93cbbdfa5d497d5afb5b13">initSymmetricGradient</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#b9c9a9ebb3b89ac2c8aff5e985923d18">initSymmetricGradient</a> (<a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a> norm)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#afb70f6879284a8f74ae53ab656094e6">Kernel1D</a> (<a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> const &amp;k)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#c4bc39b4e951c1da5c7d14e79774842b">Kernel1D</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#cd0de676568888d848beb97dcc53ae47">normalize</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#7f10c82d42dacf3b4c9b691fb0840e35">normalize</a> (<a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a> norm, unsigned int derivativeOrder=0, double offset=0.0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">InitProxy&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#4fd821bdc684b1cdad02afe53dd043dc">operator=</a> (<a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a> const &amp;v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#4d661136561636b764e9689d41db9349">operator=</a> (<a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a> const &amp;k)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classvigra_1_1Kernel1D.html#130b31490ce7ba9051094274b190940d">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#42bf8c098fec92f08714fdf0c72a66ff">operator[]</a> (int location)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#647df9e68cc4da54a5c9d2ba13768c9a">setBorderTreatment</a> (BorderTreatmentMode new_mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#b8e4e3e2a7bf18888b71bdf9dda0770b">size</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Kernel1D.html#8dce5d31376d099a6f6a940dd1b1fa28">~Kernel1D</a> ()</td></tr>

</table>
<hr><a name="_details"></a><h2 class="details_section">Detailed Description</h2>
<h3 class="details_section">template&lt;class ARITHTYPE&gt;<br>
 class vigra::Kernel1D&lt; ARITHTYPE &gt;</h3>

Generic 1 dimensional convolution kernel. 
<p>
This kernel may be used for convolution of 1 dimensional signals or for separable convolution of multidimensional signals.<p>
Convlution functions access the kernel via a 1 dimensional random access iterator which they get by calling <a class="el" href="classvigra_1_1Kernel1D.html#fa906590f3f139cdfeb292a15add8e1f">center()</a>. This iterator points to the center of the kernel. The kernel's size is given by its <a class="el" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left()</a> (&lt;=0) and <a class="el" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right()</a> (&gt;= 0) methods. The desired border treatment mode is returned by <a class="el" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment()</a>.<p>
The different init functions create a kernel with the specified properties. The kernel's value_type must be a linear space, i.e. it must define multiplication with doubles and NumericTraits.<p>
The kernel defines a factory function kernel1d() to create an argument object (see <a class="el" href="KernelArgumentObjectFactories.html">Kernel Argument Object Factories</a>).<p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="stdconvolution_8hxx-source.html">vigra/stdconvolution.hxx</a>&gt;<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FImage</a> src(w,h), dest(w,h);
    ...

    <span class="comment">// define Gaussian kernel with std. deviation 3.0</span>
    <a class="code" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D</a> kernel;
    kernel.<a class="code" href="classvigra_1_1Kernel1D.html#27d9971d7859098dc18549fd6b8b996f">initGaussian</a>(3.0);

    <a class="code" href="group__SeparableConvolution.html#g91c42eb92438d7d8f78a14eb8ca23d71" title="Performs a 1 dimensional convolution in x direction.">vigra::separableConvolveX</a>(srcImageRange(src), destImage(dest), kernel1d(kernel));
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a> v = vigra::NumericTraits&lt;value_type&gt;::one(); <span class="comment">// if norm is not</span>
                                                            <span class="comment">// given explicitly</span>
    <span class="keywordtype">double</span> d;

    v = d * v;
</pre></div> <dl compact><dt><b>Examples: </b></dt><dd>

<p>
<a class="el" href="pyramid_8cxx-example.html#_a0">pyramid.cxx</a>, and <a class="el" href="smooth_8cxx-example.html#_a7">smooth.cxx</a>.</dl><hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="6c53fe234330a9d1604e0948fa47174b"></a><!-- doxytag: member="vigra::Kernel1D::Accessor" ref="6c53fe234330a9d1604e0948fa47174b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classvigra_1_1StandardAccessor.html">StandardAccessor</a>&lt;ARITHTYPE&gt; <a class="el" href="classvigra_1_1StandardAccessor.html">Accessor</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the kernel's accessor 
</div>
</div><p>
<a class="anchor" name="b5a64d70f2934a8cb54eb8d81f059773"></a><!-- doxytag: member="vigra::Kernel1D::const_iterator" ref="b5a64d70f2934a8cb54eb8d81f059773" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalVector::const_iterator <a class="el" href="classvigra_1_1Kernel1D.html#b5a64d70f2934a8cb54eb8d81f059773">const_iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
const 1D random access iterator over the kernel's values 
</div>
</div><p>
<a class="anchor" name="b6c87d7921339cc42075571aaf0c6534"></a><!-- doxytag: member="vigra::Kernel1D::const_reference" ref="b6c87d7921339cc42075571aaf0c6534" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalVector::const_reference <a class="el" href="classvigra_1_1Kernel1D.html#b6c87d7921339cc42075571aaf0c6534">const_reference</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the kernel's const reference type 
</div>
</div><p>
<a class="anchor" name="a78445962f8673a1e2c1393dab7c7ad8"></a><!-- doxytag: member="vigra::Kernel1D::ConstAccessor" ref="a78445962f8673a1e2c1393dab7c7ad8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classvigra_1_1StandardConstAccessor.html">StandardConstAccessor</a>&lt;ARITHTYPE&gt; <a class="el" href="classvigra_1_1StandardConstAccessor.html">ConstAccessor</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the kernel's const accessor 
</div>
</div><p>
<a class="anchor" name="8c0b17e9965a56ba56cb5fedc7119a92"></a><!-- doxytag: member="vigra::Kernel1D::iterator" ref="8c0b17e9965a56ba56cb5fedc7119a92" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalVector::iterator <a class="el" href="classvigra_1_1Kernel1D.html#8c0b17e9965a56ba56cb5fedc7119a92">iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
1D random access iterator over the kernel's values 
</div>
</div><p>
<a class="anchor" name="def84b9c9d4f014effcfecbca87629d2"></a><!-- doxytag: member="vigra::Kernel1D::Iterator" ref="def84b9c9d4f014effcfecbca87629d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalVector::iterator <a class="el" href="classvigra_1_1Kernel1D.html#def84b9c9d4f014effcfecbca87629d2">Iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
deprecated -- use <a class="el" href="classvigra_1_1Kernel1D.html#8c0b17e9965a56ba56cb5fedc7119a92">Kernel1D::iterator</a> 
</div>
</div><p>
<a class="anchor" name="130b31490ce7ba9051094274b190940d"></a><!-- doxytag: member="vigra::Kernel1D::reference" ref="130b31490ce7ba9051094274b190940d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef InternalVector::reference <a class="el" href="classvigra_1_1Kernel1D.html#130b31490ce7ba9051094274b190940d">reference</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the kernel's reference type 
</div>
</div><p>
<a class="anchor" name="821b18fa86c2bc45ccf17716429d438b"></a><!-- doxytag: member="vigra::Kernel1D::value_type" ref="821b18fa86c2bc45ccf17716429d438b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classvigra_1_1ArrayVector.html#dee9ba124f2423126f678c913667a229">InternalVector::value_type</a> <a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the kernel's value type 
</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="c4bc39b4e951c1da5c7d14e79774842b"></a><!-- doxytag: member="vigra::Kernel1D::Kernel1D" ref="c4bc39b4e951c1da5c7d14e79774842b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. Creates a kernel of size 1 which would copy the signal unchanged. 
</div>
</div><p>
<a class="anchor" name="afb70f6879284a8f74ae53ab656094e6"></a><!-- doxytag: member="vigra::Kernel1D::Kernel1D" ref="afb70f6879284a8f74ae53ab656094e6" args="(Kernel1D const &amp;k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>&lt; ARITHTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>k</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
</div>
</div><p>
<a class="anchor" name="8dce5d31376d099a6f6a940dd1b1fa28"></a><!-- doxytag: member="vigra::Kernel1D::~Kernel1D" ref="8dce5d31376d099a6f6a940dd1b1fa28" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="c1e543db9ce291e86b9023cdb9202b5b"></a><!-- doxytag: member="vigra::Kernel1D::accessor" ref="c1e543db9ce291e86b9023cdb9202b5b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1StandardAccessor.html">Accessor</a> accessor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get an accessor 
</div>
</div><p>
<a class="anchor" name="40e8567a7e13dacc22cadde2f9d1dcd0"></a><!-- doxytag: member="vigra::Kernel1D::accessor" ref="40e8567a7e13dacc22cadde2f9d1dcd0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1StandardConstAccessor.html">ConstAccessor</a> accessor           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get a const accessor 
</div>
</div><p>
<a class="anchor" name="69dbff83a4127cc415a7eb796d95051e"></a><!-- doxytag: member="vigra::Kernel1D::borderTreatment" ref="69dbff83a4127cc415a7eb796d95051e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BorderTreatmentMode borderTreatment           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
current border treatment mode 
</div>
</div><p>
<a class="anchor" name="fa906590f3f139cdfeb292a15add8e1f"></a><!-- doxytag: member="vigra::Kernel1D::center" ref="fa906590f3f139cdfeb292a15add8e1f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html#8c0b17e9965a56ba56cb5fedc7119a92">iterator</a> center           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get iterator to center of kernel<p>
Postconditions: <div class="fragment"><pre class="fragment">            <a class="code" href="classvigra_1_1Kernel1D.html#fa906590f3f139cdfeb292a15add8e1f">center</a>()[<a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()] ... <a class="code" href="classvigra_1_1Kernel1D.html#fa906590f3f139cdfeb292a15add8e1f">center</a>()[<a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>()] are valid kernel positions
</pre></div> 
</div>
</div><p>
<a class="anchor" name="97c19fd629e175e9b97af74733b2bbd4"></a><!-- doxytag: member="vigra::Kernel1D::initAveraging" ref="97c19fd629e175e9b97af74733b2bbd4" args="(int radius)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initAveraging           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>radius</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init as an Averaging filter with norm 1. 
</div>
</div><p>
<a class="anchor" name="b7fe279fbc6c3e2ce60ec778109b9923"></a><!-- doxytag: member="vigra::Kernel1D::initAveraging" ref="b7fe279fbc6c3e2ce60ec778109b9923" args="(int radius, value_type norm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initAveraging           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>norm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init as an Averaging filter. 'norm' denotes the sum of all bins of the kernel. The window size is (2*radius+1) * (2*radius+1)<p>
Precondition: <div class="fragment"><pre class="fragment">            radius   &gt;= 0
</pre></div><p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -radius
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  radius
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_CLIP
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>
</pre></div> 
</div>
</div><p>
<a class="anchor" name="01c5f04a39f4a11736e787f7d27f6666"></a><!-- doxytag: member="vigra::Kernel1D::initBinomial" ref="01c5f04a39f4a11736e787f7d27f6666" args="(int radius)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initBinomial           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>radius</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init as a Binomial filter with norm 1. 
</div>
</div><p>
<a class="anchor" name="c919a292dea182575c698495de0430b2"></a><!-- doxytag: member="vigra::Kernel1D::initBinomial" ref="c919a292dea182575c698495de0430b2" args="(int radius, value_type norm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initBinomial           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>norm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init as a Binomial filter. 'norm' denotes the sum of all bins of the kernel.<p>
Precondition: <div class="fragment"><pre class="fragment">            radius   &gt;= 0
</pre></div><p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -radius
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  radius
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>
</pre></div> 
</div>
</div><p>
<a class="anchor" name="1406a301a1cc659b3098bbcc0a827228"></a><!-- doxytag: member="vigra::Kernel1D::initBurtFilter" ref="1406a301a1cc659b3098bbcc0a827228" args="(double a=0.04785)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initBurtFilter           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a</em> = <code>0.04785</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init a 5-tap filter as defined by Peter Burt in the context of pyramid creation. The filter values are<p>
<div class="fragment"><pre class="fragment">            [a, 0.25, 0.5-2*a, 0.25, a]
</pre></div><p>
The default <code>a = 0.04785</code> is optimal in the sense that it minimizes the difference to a true <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter (which would have sigma = 0.975). For other values of <code>a</code>, the scale of the most similar <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> can be approximated by<p>
<div class="fragment"><pre class="fragment">            sigma = 5.1 * a + 0.731
</pre></div><p>
Preconditions: <div class="fragment"><pre class="fragment">            0 &lt;= a &lt;= 0.125
</pre></div><p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  2
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div><p>
<a class="anchor" name="15901db2903a004e09e86ae5fbd66ca2"></a><!-- doxytag: member="vigra::Kernel1D::initDiscreteGaussian" ref="15901db2903a004e09e86ae5fbd66ca2" args="(double std_dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initDiscreteGaussian           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>std_dev</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init as a Lindeberg's discrete analog of the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> function with norm 1. 
</div>
</div><p>
<a class="anchor" name="80922d43665cec4f4378e8378997feb0"></a><!-- doxytag: member="vigra::Kernel1D::initDiscreteGaussian" ref="80922d43665cec4f4378e8378997feb0" args="(double std_dev, value_type norm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initDiscreteGaussian           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>std_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>norm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init as Lindeberg's discrete analog of the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> function. The radius of the kernel is always 3*std_dev. 'norm' denotes the sum of all bins of the kernel.<p>
Precondition: <div class="fragment"><pre class="fragment">            std_dev &gt;= 0.0
</pre></div><p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -(int)(3.0*std_dev + 0.5)
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  (int)(3.0*std_dev + 0.5)
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>
</pre></div> 
</div>
</div><p>
<a class="anchor" name="1164e5b808619971ebc0e9783f972dc9"></a><!-- doxytag: member="vigra::Kernel1D::initExplicitly" ref="1164e5b808619971ebc0e9783f972dc9" args="(int left, int right)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>&amp; initExplicitly           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init the kernel by an explicit initializer list. The left and right boundaries of the kernel must be passed. A comma-separated initializer list is given after the assignment operator. This function is used like this:<p>
<div class="fragment"><pre class="fragment">            <span class="comment">// define horizontal Roberts filter</span>
            <a class="code" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D&lt;float&gt;</a> roberts_gradient_x;

            roberts_gradient_x.<a class="code" href="classvigra_1_1Kernel1D.html#1164e5b808619971ebc0e9783f972dc9">initExplicitly</a>(0, 1) = 1.0, -1.0;
</pre></div><p>
The norm is set to the sum of the initialzer values. If the wrong number of values is given, a run-time error results. It is, however, possible to give just one initializer. This creates an averaging filter with the given constant:<p>
<div class="fragment"><pre class="fragment">            <a class="code" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D&lt;float&gt;</a> average5x1;

            average5x1.<a class="code" href="classvigra_1_1Kernel1D.html#1164e5b808619971ebc0e9783f972dc9">initExplicitly</a>(-2, 2) = 1.0/5.0;
</pre></div><p>
Here, the norm is set to value*size().<p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a> &lt;= 0
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a> &gt;= 0
            3. the number of values in the initializer list
               is 1 or equals the size of the kernel.
</pre></div> 
</div>
</div><p>
<a class="anchor" name="bba907ac90270c3dd8aac14af93f7b58"></a><!-- doxytag: member="vigra::Kernel1D::initGaussian" ref="bba907ac90270c3dd8aac14af93f7b58" args="(double std_dev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initGaussian           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>std_dev</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init as a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> function with norm 1. 
</div>
</div><p>
<a class="anchor" name="27d9971d7859098dc18549fd6b8b996f"></a><!-- doxytag: member="vigra::Kernel1D::initGaussian" ref="27d9971d7859098dc18549fd6b8b996f" args="(double std_dev, value_type norm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initGaussian           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>std_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>norm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init as a sampled <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> function. The radius of the kernel is always 3*std_dev. '<code>norm</code>' denotes the sum of all bins of the kernel (i.e. the kernel is corrected for the normalization error introduced by windowing the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> to a finite interval). However, if <code>norm</code> is 0.0, the kernel is normalized to 1 by the analytic expression for the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a>, and <b>no</b> correction for the windowing error is performed.<p>
Precondition: <div class="fragment"><pre class="fragment">            std_dev &gt;= 0.0
</pre></div><p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -(int)(3.0*std_dev + 0.5)
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  (int)(3.0*std_dev + 0.5)
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>
</pre></div> 
</div>
</div><p>
<a class="anchor" name="7eec7322d05865b857efb1449888d918"></a><!-- doxytag: member="vigra::Kernel1D::initGaussianDerivative" ref="7eec7322d05865b857efb1449888d918" args="(double std_dev, int order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initGaussianDerivative           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>std_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>order</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init as a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative with norm 1. 
</div>
</div><p>
<a class="anchor" name="f85d8b10d8111a088bc30a78c5e791f3"></a><!-- doxytag: member="vigra::Kernel1D::initGaussianDerivative" ref="f85d8b10d8111a088bc30a78c5e791f3" args="(double std_dev, int order, value_type norm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initGaussianDerivative           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>std_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>norm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init as a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative of order '<code>order</code>'. The radius of the kernel is always <code>3*std_dev + 0.5*order</code>. '<code>norm</code>' denotes the norm of the kernel so that the following condition is fulfilled:<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{i=left()}^{right()} \frac{(-i)^{order}kernel[i]}{order!} = norm \]" src="form_66.png">
<p>
<p>
Thus, the kernel will be corrected for the error introduced by windowing the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> to a finite interval. However, if <code>norm</code> is 0.0, the kernel is normalized to 1 by the analytic expression for the <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative, and <b>no</b> correction for the windowing error is performed.<p>
Preconditions: <div class="fragment"><pre class="fragment">            1. std_dev &gt;= 0.0
            2. order   &gt;= 1
</pre></div><p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -(int)(3.0*std_dev + 0.5*order + 0.5)
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  (int)(3.0*std_dev + 0.5*order + 0.5)
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>
</pre></div> 
</div>
</div><p>
<a class="anchor" name="1eeff31c2ffd35f352631fbe27d1dcdc"></a><!-- doxytag: member="vigra::Kernel1D::initOptimalFirstDerivative5" ref="1eeff31c2ffd35f352631fbe27d1dcdc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initOptimalFirstDerivative5           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init an optimal 5-tap first derivative filter. This filter must be used in conjunction with the corresponding 5-tap smoothing filter (see <a class="el" href="classvigra_1_1Kernel1D.html#068e7beed066f292a4ba8e777897526f">initOptimalFirstDerivativeSmoothing5()</a>), such that the derivative filter is applied along one dimension, and the smoothing filter along the other. The filter values are<p>
<div class="fragment"><pre class="fragment">            [0.1, 0.3, 0.0, -0.3, -0.1]
</pre></div><p>
These values are optimal in the sense that the 5x5 filter obtained by combining this filter with the corresponding 5-tap smoothing filter is the best possible 5x5 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> first derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.906.<p>
If the filter is instead separably combined with itself, an almost optimal approximation of the mixed second <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> derivative at scale sigma = 0.899 results.<p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  2
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div><p>
<a class="anchor" name="f5677b3c7ffdc1586c4e9e4a5394daac"></a><!-- doxytag: member="vigra::Kernel1D::initOptimalFirstDerivativeSmoothing3" ref="f5677b3c7ffdc1586c4e9e4a5394daac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initOptimalFirstDerivativeSmoothing3           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init an optimal 3-tap smoothing filter to be used in the context of first derivative computation. This filter must be used in conjunction with the symmetric difference filter (see <a class="el" href="classvigra_1_1Kernel1D.html#8feea4952f1c61fc8643bbcd23afe103">initSymmetricDifference()</a>), such that the difference filter is applied along one dimension, and the smoothing filter along the other. The filter values are<p>
<div class="fragment"><pre class="fragment">            [0.224365, 0.55127, 0.224365]
</pre></div><p>
These values are optimal in the sense that the 3x3 filter obtained by combining this filter with the symmetric difference is the best possible 3x3 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> first derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.675.<p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  1
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div><p>
<a class="anchor" name="068e7beed066f292a4ba8e777897526f"></a><!-- doxytag: member="vigra::Kernel1D::initOptimalFirstDerivativeSmoothing5" ref="068e7beed066f292a4ba8e777897526f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initOptimalFirstDerivativeSmoothing5           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init an optimal 5-tap smoothing filter to be used in the context of first derivative computation. This filter must be used in conjunction with the optimal 5-tap first derivative filter (see <a class="el" href="classvigra_1_1Kernel1D.html#1eeff31c2ffd35f352631fbe27d1dcdc">initOptimalFirstDerivative5()</a>), such that the derivative filter is applied along one dimension, and the smoothing filter along the other. The filter values are<p>
<div class="fragment"><pre class="fragment">            [0.04255, 0.241, 0.4329, 0.241, 0.04255]
</pre></div><p>
These values are optimal in the sense that the 5x5 filter obtained by combining this filter with the optimal 5-tap first derivative is the best possible 5x5 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> first derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.906.<p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  2
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div><p>
<a class="anchor" name="b50c7edfcedf325996e21eb74a69a4d0"></a><!-- doxytag: member="vigra::Kernel1D::initOptimalSecondDerivative5" ref="b50c7edfcedf325996e21eb74a69a4d0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initOptimalSecondDerivative5           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init an optimal 5-tap second derivative filter. This filter must be used in conjunction with the corresponding 5-tap smoothing filter (see <a class="el" href="classvigra_1_1Kernel1D.html#bbe3a4b86ffdaf0e8e85d5ab7e75ed71">initOptimalSecondDerivativeSmoothing5()</a>), such that the derivative filter is applied along one dimension, and the smoothing filter along the other. The filter values are<p>
<div class="fragment"><pre class="fragment">            [0.22075, 0.117, -0.6755, 0.117, 0.22075]
</pre></div><p>
These values are optimal in the sense that the 5x5 filter obtained by combining this filter with the corresponding 5-tap smoothing filter is the best possible 5x5 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> second derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.817.<p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  2
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div><p>
<a class="anchor" name="0fe353a930022de958b75e9e6311189e"></a><!-- doxytag: member="vigra::Kernel1D::initOptimalSecondDerivativeSmoothing3" ref="0fe353a930022de958b75e9e6311189e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initOptimalSecondDerivativeSmoothing3           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init an optimal 3-tap smoothing filter to be used in the context of second derivative computation. This filter must be used in conjunction with the 3-tap second difference filter (see <a class="el" href="classvigra_1_1Kernel1D.html#072b8efc06e0bd9c6f1fd395becebf17">initSecondDifference3()</a>), such that the difference filter is applied along one dimension, and the smoothing filter along the other. The filter values are<p>
<div class="fragment"><pre class="fragment">            [0.13, 0.74, 0.13]
</pre></div><p>
These values are optimal in the sense that the 3x3 filter obtained by combining this filter with the 3-tap second difference is the best possible 3x3 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> second derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.433.<p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  1
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div><p>
<a class="anchor" name="bbe3a4b86ffdaf0e8e85d5ab7e75ed71"></a><!-- doxytag: member="vigra::Kernel1D::initOptimalSecondDerivativeSmoothing5" ref="bbe3a4b86ffdaf0e8e85d5ab7e75ed71" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initOptimalSecondDerivativeSmoothing5           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init an optimal 5-tap smoothing filter to be used in the context of second derivative computation. This filter must be used in conjunction with the optimal 5-tap second derivative filter (see <a class="el" href="classvigra_1_1Kernel1D.html#b50c7edfcedf325996e21eb74a69a4d0">initOptimalSecondDerivative5()</a>), such that the derivative filter is applied along one dimension, and the smoothing filter along the other. The filter values are<p>
<div class="fragment"><pre class="fragment">            [0.0243, 0.23556, 0.48028, 0.23556, 0.0243]
</pre></div><p>
These values are optimal in the sense that the 5x5 filter obtained by combining this filter with the optimal 5-tap second derivative is the best possible 5x5 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> second derivative filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.817.<p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  2
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div><p>
<a class="anchor" name="f4902fcc6fe66ab6646cbe1fdc5e7121"></a><!-- doxytag: member="vigra::Kernel1D::initOptimalSmoothing3" ref="f4902fcc6fe66ab6646cbe1fdc5e7121" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initOptimalSmoothing3           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init an optimal 3-tap smoothing filter. The filter values are<p>
<div class="fragment"><pre class="fragment">            [0.216, 0.568, 0.216]
</pre></div><p>
These values are optimal in the sense that the 3x3 filter obtained by separable application of this filter is the best possible 3x3 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.680.<p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  1
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div><p>
<a class="anchor" name="75b3593dd18b43b1d5f81532617d8010"></a><!-- doxytag: member="vigra::Kernel1D::initOptimalSmoothing5" ref="75b3593dd18b43b1d5f81532617d8010" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initOptimalSmoothing5           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init an optimal 5-tap smoothing filter. The filter values are<p>
<div class="fragment"><pre class="fragment">            [0.03134, 0.24, 0.45732, 0.24, 0.03134]
</pre></div><p>
These values are optimal in the sense that the 5x5 filter obtained by separable application of this filter is the best possible 5x5 approximation to a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> filter. The equivalent <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> has sigma = 0.867.<p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -2
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  2
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div><p>
<a class="anchor" name="072b8efc06e0bd9c6f1fd395becebf17"></a><!-- doxytag: member="vigra::Kernel1D::initSecondDifference3" ref="072b8efc06e0bd9c6f1fd395becebf17" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initSecondDifference3           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init the 3-tap second difference filter. The filter values are<p>
<div class="fragment"><pre class="fragment">             [1, -2, 1]
</pre></div><p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  1
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1
</pre></div> 
</div>
</div><p>
<a class="anchor" name="8feea4952f1c61fc8643bbcd23afe103"></a><!-- doxytag: member="vigra::Kernel1D::initSymmetricDifference" ref="8feea4952f1c61fc8643bbcd23afe103" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initSymmetricDifference           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init as the 3-tap symmetric difference filter The filter values are<p>
<div class="fragment"><pre class="fragment">             [0.5, 0, -0.5]
</pre></div><p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  1
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REFLECT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == 1.0
</pre></div> 
</div>
</div><p>
<a class="anchor" name="50d0fbcbdb93cbbdfa5d497d5afb5b13"></a><!-- doxytag: member="vigra::Kernel1D::initSymmetricGradient" ref="50d0fbcbdb93cbbdfa5d497d5afb5b13" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initSymmetricGradient           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init as a symmetric gradient filter with norm 1.<p>
<b>Deprecated</b>. Use <a class="el" href="classvigra_1_1Kernel1D.html#8feea4952f1c61fc8643bbcd23afe103">initSymmetricDifference()</a> instead. 
</div>
</div><p>
<a class="anchor" name="b9c9a9ebb3b89ac2c8aff5e985923d18"></a><!-- doxytag: member="vigra::Kernel1D::initSymmetricGradient" ref="b9c9a9ebb3b89ac2c8aff5e985923d18" args="(value_type norm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initSymmetricGradient           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>norm</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Init as a symmetric gradient filter of the form <code>[ 0.5 * norm, 0.0 * norm, -0.5 * norm]</code><p>
<b>Deprecated</b>. Use <a class="el" href="classvigra_1_1Kernel1D.html#8feea4952f1c61fc8643bbcd23afe103">initSymmetricDifference()</a> instead.<p>
Postconditions: <div class="fragment"><pre class="fragment">            1. <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>()  == -1
            2. <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>() ==  1
            3. <a class="code" href="classvigra_1_1Kernel1D.html#69dbff83a4127cc415a7eb796d95051e">borderTreatment</a>() == BORDER_TREATMENT_REPEAT
            4. <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>() == <a class="code" href="classvigra_1_1Kernel1D.html#ac41cd63a48de00144dbd94e4c38ead6">norm</a>
</pre></div> 
</div>
</div><p>
<a class="anchor" name="265321ef4c7ad76f60e512fc09eef7c2"></a><!-- doxytag: member="vigra::Kernel1D::left" ref="265321ef4c7ad76f60e512fc09eef7c2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int left           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
left border of kernel (inclusive), always &lt;= 0 
</div>
</div><p>
<a class="anchor" name="ac41cd63a48de00144dbd94e4c38ead6"></a><!-- doxytag: member="vigra::Kernel1D::norm" ref="ac41cd63a48de00144dbd94e4c38ead6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a> norm           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
norm of kernel 
</div>
</div><p>
<a class="anchor" name="cd0de676568888d848beb97dcc53ae47"></a><!-- doxytag: member="vigra::Kernel1D::normalize" ref="cd0de676568888d848beb97dcc53ae47" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void normalize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
normalize kernel to norm 1. 
</div>
</div><p>
<a class="anchor" name="7f10c82d42dacf3b4c9b691fb0840e35"></a><!-- doxytag: member="vigra::Kernel1D::normalize" ref="7f10c82d42dacf3b4c9b691fb0840e35" args="(value_type norm, unsigned int derivativeOrder=0, double offset=0.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void normalize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a>&nbsp;</td>
          <td class="paramname"> <em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>derivativeOrder</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>offset</em> = <code>0.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
set a new norm and normalize kernel, use the normalization formula for the given <code>derivativeOrder</code>. 
</div>
</div><p>
<a class="anchor" name="4fd821bdc684b1cdad02afe53dd043dc"></a><!-- doxytag: member="vigra::Kernel1D::operator=" ref="4fd821bdc684b1cdad02afe53dd043dc" args="(value_type const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InitProxy operator=           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html#821b18fa86c2bc45ccf17716429d438b">value_type</a> const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialization. This initializes the kernel with the given constant. The norm becomes v*size().<p>
Instead of a single value an initializer list of length <a class="el" href="classvigra_1_1Kernel1D.html#b8e4e3e2a7bf18888b71bdf9dda0770b">size()</a> can be used like this:<p>
<div class="fragment"><pre class="fragment">            <a class="code" href="classvigra_1_1Kernel1D.html" title="Generic 1 dimensional convolution kernel.">vigra::Kernel1D&lt;float&gt;</a> roberts_gradient_x;

            roberts_gradient_x.<a class="code" href="classvigra_1_1Kernel1D.html#1164e5b808619971ebc0e9783f972dc9">initExplicitly</a>(0, 1) = 1.0, -1.0;
</pre></div><p>
In this case, the norm will be set to the sum of the init values. An initializer list of wrong length will result in a run-time error. 
</div>
</div><p>
<a class="anchor" name="4d661136561636b764e9689d41db9349"></a><!-- doxytag: member="vigra::Kernel1D::operator=" ref="4d661136561636b764e9689d41db9349" args="(Kernel1D const &amp;k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>&amp; operator=           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1Kernel1D.html">Kernel1D</a>&lt; ARITHTYPE &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>k</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy assignment. 
</div>
</div><p>
<a class="anchor" name="42bf8c098fec92f08714fdf0c72a66ff"></a><!-- doxytag: member="vigra::Kernel1D::operator[]" ref="42bf8c098fec92f08714fdf0c72a66ff" args="(int location)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvigra_1_1Kernel1D.html#130b31490ce7ba9051094274b190940d">reference</a> operator[]           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>location</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access kernel value at specified location.<p>
Preconditions: <div class="fragment"><pre class="fragment">            <a class="code" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left</a>() &lt;= location &lt;= <a class="code" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right</a>()
</pre></div> 
</div>
</div><p>
<a class="anchor" name="d04ec796f4e7db479575644d114974ef"></a><!-- doxytag: member="vigra::Kernel1D::right" ref="d04ec796f4e7db479575644d114974ef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int right           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
right border of kernel (inclusive), always &gt;= 0 
</div>
</div><p>
<a class="anchor" name="647df9e68cc4da54a5c9d2ba13768c9a"></a><!-- doxytag: member="vigra::Kernel1D::setBorderTreatment" ref="647df9e68cc4da54a5c9d2ba13768c9a" args="(BorderTreatmentMode new_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setBorderTreatment           </td>
          <td>(</td>
          <td class="paramtype">BorderTreatmentMode&nbsp;</td>
          <td class="paramname"> <em>new_mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set border treatment mode. 
</div>
</div><p>
<a class="anchor" name="b8e4e3e2a7bf18888b71bdf9dda0770b"></a><!-- doxytag: member="vigra::Kernel1D::size" ref="b8e4e3e2a7bf18888b71bdf9dda0770b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
size of kernel (<a class="el" href="classvigra_1_1Kernel1D.html#d04ec796f4e7db479575644d114974ef">right()</a> - <a class="el" href="classvigra_1_1Kernel1D.html#265321ef4c7ad76f60e512fc09eef7c2">left()</a> + 1) 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>vigra/<a class="el" href="separableconvolution_8hxx-source.html">separableconvolution.hxx</a></ul>
</div>
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
VIGRA 1.6.0 (13 Aug 2008)
</i>
</tr>
</table>


</BODY>
</HTML>
