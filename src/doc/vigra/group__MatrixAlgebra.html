<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>VIGRA - VIGRA: Advanced Matrix Algebra</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Advanced Matrix Algebra<br>
<small>
[<a class="el" href="group__LinearAlgebraModule.html">Linear Algebra</a>]</small>

</td>
<td align=right><a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif"></a></td></tr>
</table><p>
Solution of linear systems, eigen systems, linear least squares etc.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1, class C2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#g949208b5e9ea3840a01ed8e04af6f3ef">choleskyDecomposition</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; &amp;L)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#ge82e9158ebf7376a5f3522a3593083b0">determinant</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;a, std::string method=&quot;LU&quot;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">TemporaryMatrix&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#g5960eefdeea2e41a8784c15c4538dae9">inverse</a> (const MultiArrayView&lt; 2, T, C &gt; &amp;v)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1, class C2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#g5242a832201b32d3a1db1386a0c97d97">inverse</a> (const MultiArrayView&lt; 2, T, C1 &gt; &amp;v, MultiArrayView&lt; 2, T, C2 &gt; &amp;res)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1, class C2, class C3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#g18d34c1c9083fe0d8cf9aaeb2355ef50">leastSquares</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; &amp;x, std::string method=&quot;QR&quot;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1, class C2, class C3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#gef8edc8b2eab94efae5c775551c55cb6">linearSolve</a> (const MultiArrayView&lt; 2, T, C1 &gt; &amp;A, const MultiArrayView&lt; 2, T, C2 &gt; &amp;b, MultiArrayView&lt; 2, T, C3 &gt; &amp;res, std::string method=&quot;QR&quot;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1, class C2, class C3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#gdfeb2ba0c8e6b4ec938d606702b415ce">linearSolveLowerTriangular</a> (const MultiArrayView&lt; 2, T, C1 &gt; &amp;l, const MultiArrayView&lt; 2, T, C2 &gt; &amp;b, MultiArrayView&lt; 2, T, C3 &gt; x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1, class C2, class C3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#g8950e99153326c453cd6a33e6f4822b3">linearSolveUpperTriangular</a> (const MultiArrayView&lt; 2, T, C1 &gt; &amp;r, const MultiArrayView&lt; 2, T, C2 &gt; &amp;b, MultiArrayView&lt; 2, T, C3 &gt; x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#g725a8b3fc6a4f4eee1f21dae424b3ad7">logDeterminant</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1, class C2, class C3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#g98c97e8bbde66b1ef109533926699040">nonsymmetricEigensystem</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;a, MultiArrayView&lt; 2, std::complex&lt; T &gt;, C2 &gt; &amp;ew, MultiArrayView&lt; 2, T, C3 &gt; &amp;ev)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class POLYNOMIAL, class VECTOR&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#ga83f285285079d99d03bb94aab8a9a37">polynomialRealRootsEigenvalueMethod</a> (POLYNOMIAL const &amp;p, VECTOR &amp;roots, bool polishRoots)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class POLYNOMIAL, class VECTOR&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#g3eff5c01267e8931811f72884e120ad9">polynomialRootsEigenvalueMethod</a> (POLYNOMIAL const &amp;poly, VECTOR &amp;roots, bool polishRoots)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1, class C2, class C3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#g5a2c6f5cc5ed7e471dcee8c78558359f">qrDecomposition</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;a, MultiArrayView&lt; 2, T, C2 &gt; &amp;q, MultiArrayView&lt; 2, T, C3 &gt; &amp;r, double epsilon=0.0)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1, class C2, class C3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#gfe3e0ee9e067dde9d647357a72968d17">reverseElimination</a> (const MultiArrayView&lt; 2, T, C1 &gt; &amp;r, const MultiArrayView&lt; 2, T, C2 &gt; &amp;b, MultiArrayView&lt; 2, T, C3 &gt; x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1, class C2, class C3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#g7b22decce13240b6d58d5cdeef3db759">ridgeRegression</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; &amp;x, double lambda)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1, class C2, class C3, class Array&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#g87100f96920d114852ab6ab6c113238d">ridgeRegressionSeries</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; &amp;x, Array const &amp;lambda)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1, class C2, class C3, class C4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#g04c25c7386cca251e2f95c671e0cfc19">singularValueDecomposition</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; &amp;U, MultiArrayView&lt; 2, T, C3 &gt; &amp;S, MultiArrayView&lt; 2, T, C4 &gt; &amp;V)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1, class C2, class C3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#gf102668fcfa5853002d1527df071fac7">symmetricEigensystem</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;a, MultiArrayView&lt; 2, T, C2 &gt; &amp;ew, MultiArrayView&lt; 2, T, C3 &gt; &amp;ev)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1, class C2, class C3, class C4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#g8718006a36f67e3ed75131e705ae517f">weightedLeastSquares</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; const &amp;weights, MultiArrayView&lt; 2, T, C4 &gt; &amp;x, std::string method=&quot;QR&quot;)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, class C1, class C2, class C3, class C4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixAlgebra.html#g934703bfd58fb06aaaf897ce7c4814ed">weightedRidgeRegression</a> (MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; const &amp;weights, MultiArrayView&lt; 2, T, C4 &gt; &amp;x, double lambda)</td></tr>

</table>
<hr><a name="_details"></a><h2 class="details_section">Detailed Description</h2>
Solution of linear systems, eigen systems, linear least squares etc. 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gf102668fcfa5853002d1527df071fac7"></a><!-- doxytag: member="vigra::linalg::symmetricEigensystem" ref="gf102668fcfa5853002d1527df071fac7" args="(MultiArrayView&lt; 2, T, C1 &gt; const &amp;a, MultiArrayView&lt; 2, T, C2 &gt; &amp;ew, MultiArrayView&lt; 2, T, C3 &gt; &amp;ev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1, class C2, class C3&gt; </td></tr><tr>
          <td class="memname">bool vigra::linalg::symmetricEigensystem           </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ev</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the eigensystem of a symmetric matrix.<p>
<em>a</em> is a real symmetric matrix, <em>ew</em> is a single-column matrix holding the eigenvalues, and <em>ev</em> is a matrix of the same size as <em>a</em> whose columns are the corresponding eigenvectors. Eigenvalues will be sorted from largest to smallest magnitude. The algorithm returns <code>false</code> when it doesn't converge. It can be applied in-place, i.e. <code>&amp;a == &amp;ev</code> is allowed. The code of this function was adapted from JAMA.<p>
<b>#include</b> &lt;<a href="eigensystem_8hxx-source.html">vigra/eigensystem.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
<a class="anchor" name="g98c97e8bbde66b1ef109533926699040"></a><!-- doxytag: member="vigra::linalg::nonsymmetricEigensystem" ref="g98c97e8bbde66b1ef109533926699040" args="(MultiArrayView&lt; 2, T, C1 &gt; const &amp;a, MultiArrayView&lt; 2, std::complex&lt; T &gt;, C2 &gt; &amp;ew, MultiArrayView&lt; 2, T, C3 &gt; &amp;ev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1, class C2, class C3&gt; </td></tr><tr>
          <td class="memname">bool vigra::linalg::nonsymmetricEigensystem           </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, std::complex&lt; T &gt;, C2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>ev</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the eigensystem of a square, but not necessarily symmetric matrix.<p>
<em>a</em> is a real square matrix, <em>ew</em> is a single-column matrix holding the possibly complex eigenvalues, and <em>ev</em> is a matrix of the same size as <em>a</em> whose columns are the corresponding eigenvectors. Eigenvalues will be sorted from largest to smallest magnitude. The algorithm returns <code>false</code> when it doesn't converge. It can be applied in-place, i.e. <code>&amp;a == &amp;ev</code> is allowed. The code of this function was adapted from JAMA.<p>
<b>#include</b> &lt;<a href="eigensystem_8hxx-source.html">vigra/eigensystem.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
<a class="anchor" name="g3eff5c01267e8931811f72884e120ad9"></a><!-- doxytag: member="vigra::linalg::polynomialRootsEigenvalueMethod" ref="g3eff5c01267e8931811f72884e120ad9" args="(POLYNOMIAL const &amp;poly, VECTOR &amp;roots, bool polishRoots)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class POLYNOMIAL, class VECTOR&gt; </td></tr><tr>
          <td class="memname">bool vigra::linalg::polynomialRootsEigenvalueMethod           </td>
          <td>(</td>
          <td class="paramtype">POLYNOMIAL const &amp;&nbsp;</td>
          <td class="paramname"> <em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&nbsp;</td>
          <td class="paramname"> <em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>polishRoots</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the roots of a polynomial using the eigenvalue method.<p>
<em>poly</em> is a real polynomial (compatible to <a class="el" href="classvigra_1_1PolynomialView.html">vigra::PolynomialView</a>), and <em>roots</em> a complex valued vector (compatible to <code>std::vector</code> with a <code>value_type</code> compatible to the type <code>POLYNOMIAL::Complex</code>) to which the roots are appended. The function calls <a class="el" href="group__MatrixAlgebra.html#g98c97e8bbde66b1ef109533926699040">nonsymmetricEigensystem()</a> with the standard companion matrix yielding the roots as eigenvalues. It returns <code>false</code> if it fails to converge.<p>
<b>#include</b> &lt;<a href="eigensystem_8hxx-source.html">vigra/eigensystem.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__Polynomials.html#gd0bdd5914b44a2cbd9888a0ea3351fd5">polynomialRoots()</a>, <a class="el" href="classvigra_1_1Polynomial.html">vigra::Polynomial</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga83f285285079d99d03bb94aab8a9a37"></a><!-- doxytag: member="vigra::linalg::polynomialRealRootsEigenvalueMethod" ref="ga83f285285079d99d03bb94aab8a9a37" args="(POLYNOMIAL const &amp;p, VECTOR &amp;roots, bool polishRoots)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class POLYNOMIAL, class VECTOR&gt; </td></tr><tr>
          <td class="memname">bool vigra::linalg::polynomialRealRootsEigenvalueMethod           </td>
          <td>(</td>
          <td class="paramtype">POLYNOMIAL const &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VECTOR &amp;&nbsp;</td>
          <td class="paramname"> <em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>polishRoots</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the real roots of a real polynomial using the eigenvalue method.<p>
<em>poly</em> is a real polynomial (compatible to <a class="el" href="classvigra_1_1PolynomialView.html">vigra::PolynomialView</a>), and <em>roots</em> a real valued vector (compatible to <code>std::vector</code> with a <code>value_type</code> compatible to the type <code>POLYNOMIAL::Real</code>) to which the roots are appended. The function calls <a class="el" href="group__MatrixAlgebra.html#g3eff5c01267e8931811f72884e120ad9">polynomialRootsEigenvalueMethod()</a> and throws away all complex roots. It returns <code>false</code> if it fails to converge.<p>
<b>#include</b> &lt;<a href="eigensystem_8hxx-source.html">vigra/eigensystem.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__Polynomials.html#g89baf34391707821b257e7e0dc14244f">polynomialRealRoots()</a>, <a class="el" href="classvigra_1_1Polynomial.html">vigra::Polynomial</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5242a832201b32d3a1db1386a0c97d97"></a><!-- doxytag: member="vigra::linalg::inverse" ref="g5242a832201b32d3a1db1386a0c97d97" args="(const MultiArrayView&lt; 2, T, C1 &gt; &amp;v, MultiArrayView&lt; 2, T, C2 &gt; &amp;res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1, class C2&gt; </td></tr><tr>
          <td class="memname">bool vigra::linalg::inverse           </td>
          <td>(</td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>res</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create the inverse or pseudo-inverse of matrix <em>v</em>.<p>
If the matrix <em>v</em> is square, <em>res</em> must have the same shape and will contain the inverse of <em>v</em>. If <em>v</em> is rectangular, it must have more rows than columns, and <em>res</em> must have the transposed shape of <em>v</em>. The inverse is then computed in the least-squares sense, i.e. <em>res</em> will be the pseudo-inverse (Moore-Penrose inverse). The function returns <code>true</code> upon success, and <code>false</code> if <em>v</em> is not invertible (has not full rank). The inverse is computed by means of QR decomposition. This function can be applied in-place.<p>
<b>#include</b> &lt;<a href="linear__solve_8hxx-source.html">vigra/linear_solve.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
<a class="anchor" name="g5960eefdeea2e41a8784c15c4538dae9"></a><!-- doxytag: member="vigra::linalg::inverse" ref="g5960eefdeea2e41a8784c15c4538dae9" args="(const MultiArrayView&lt; 2, T, C &gt; &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C&gt; </td></tr><tr>
          <td class="memname">TemporaryMatrix&lt;T&gt; vigra::linalg::inverse           </td>
          <td>(</td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create the inverse or pseudo-inverse of matrix <em>v</em>.<p>
The result is returned as a temporary matrix. If the matrix <em>v</em> is square, the result will have the same shape and contains the inverse of <em>v</em>. If <em>v</em> is rectangular, it must have more rows than columns, and the result will have the transposed shape of <em>v</em>. The inverse is then computed in the least-squares sense, i.e. <em>res</em> will be the pseudo-inverse (Moore-Penrose inverse). The inverse is computed by means of QR decomposition. If <em>v</em> is not invertible, <code>vigra::PreconditionViolation</code> exception is thrown. Usage:<p>
<div class="fragment"><pre class="fragment">        vigra::Matrix&lt;double&gt; v(n, n);
        v = ...;

        vigra::Matrix&lt;double&gt; m = <a class="code" href="group__MatrixAlgebra.html#g5242a832201b32d3a1db1386a0c97d97">inverse</a>(v);
</pre></div><p>
<b>#include</b> &lt;<a href="linear__solve_8hxx-source.html">vigra/linear_solve.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
<a class="anchor" name="ge82e9158ebf7376a5f3522a3593083b0"></a><!-- doxytag: member="vigra::linalg::determinant" ref="ge82e9158ebf7376a5f3522a3593083b0" args="(MultiArrayView&lt; 2, T, C1 &gt; const &amp;a, std::string method=&quot;LU&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1&gt; </td></tr><tr>
          <td class="memname">T vigra::linalg::determinant           </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>&quot;LU&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the determinant of a square matrix.<p>
<em>method</em> must be one of the following: <dl>
<dt>"Cholesky"</dt>
<dd>Compute the solution by means of Cholesky decomposition. This method is faster than "LU", but requires the matrix <em>a</em> to be symmetric positive definite. If this is not the case, a <code>ContractViolation</code> exception is thrown.<p>
</dd>
<dt>"LU"</dt>
<dd>(default) Compute the solution by means of LU decomposition. </dd>
</dl>
<p>
<b>#include</b> &lt;<a href="linear__solve_8hxx-source.html">vigra/linear_solve.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
<a class="anchor" name="g725a8b3fc6a4f4eee1f21dae424b3ad7"></a><!-- doxytag: member="vigra::linalg::logDeterminant" ref="g725a8b3fc6a4f4eee1f21dae424b3ad7" args="(MultiArrayView&lt; 2, T, C1 &gt; const &amp;a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1&gt; </td></tr><tr>
          <td class="memname">T vigra::linalg::logDeterminant           </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the logarithm of the determinant of a symmetric positive definite matrix.<p>
This is useful to avoid multiplication of very large numbers in big matrices. It is implemented by means of Cholesky decomposition.<p>
<b>#include</b> &lt;<a href="linear__solve_8hxx-source.html">vigra/linear_solve.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
<a class="anchor" name="g949208b5e9ea3840a01ed8e04af6f3ef"></a><!-- doxytag: member="vigra::linalg::choleskyDecomposition" ref="g949208b5e9ea3840a01ed8e04af6f3ef" args="(MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; &amp;L)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1, class C2&gt; </td></tr><tr>
          <td class="memname">bool vigra::linalg::choleskyDecomposition           </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cholesky decomposition.<p>
<em>A</em> must be a symmetric positive definite matrix, and <em>L</em> will be a lower triangular matrix, such that (up to round-off errors):<p>
<div class="fragment"><pre class="fragment">        A == L * <a class="code" href="group__LinearAlgebraFunctions.html#g53bbcdef21e5c5e9ca096adee23f0bcf">transpose</a>(L);
</pre></div><p>
This implementation cannot be applied in-place, i.e. <code>&amp;L == &amp;A</code> is an error. If <em>A</em> is not symmetric, a <code>ContractViolation</code> exception is thrown. If it is not positive definite, the function returns <code>false</code>.<p>
<b>#include</b> &lt;<a href="linear__solve_8hxx-source.html">vigra/linear_solve.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
<a class="anchor" name="g5a2c6f5cc5ed7e471dcee8c78558359f"></a><!-- doxytag: member="vigra::linalg::qrDecomposition" ref="g5a2c6f5cc5ed7e471dcee8c78558359f" args="(MultiArrayView&lt; 2, T, C1 &gt; const &amp;a, MultiArrayView&lt; 2, T, C2 &gt; &amp;q, MultiArrayView&lt; 2, T, C3 &gt; &amp;r, double epsilon=0.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1, class C2, class C3&gt; </td></tr><tr>
          <td class="memname">bool vigra::linalg::qrDecomposition           </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>epsilon</em> = <code>0.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
QR decomposition.<p>
<em>a</em> contains the original matrix, results are returned in <em>q</em> and <em>r</em>, where <em>q</em> is a orthogonal matrix, and <em>r</em> is an upper triangular matrix, such that (up to round-off errors):<p>
<div class="fragment"><pre class="fragment">        a == q * r;
</pre></div><p>
If <em>a</em> dosn't have full rank, the function returns <code>false</code>. The decomposition is computed by householder transformations. It can be applied in-place, i.e. <code>&amp;a == &amp;q</code> or <code>&amp;a == &amp;r</code> are allowed.<p>
<b>#include</b> &lt;<a href="linear__solve_8hxx-source.html">vigra/linear_solve.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
<a class="anchor" name="gfe3e0ee9e067dde9d647357a72968d17"></a><!-- doxytag: member="vigra::linalg::reverseElimination" ref="gfe3e0ee9e067dde9d647357a72968d17" args="(const MultiArrayView&lt; 2, T, C1 &gt; &amp;r, const MultiArrayView&lt; 2, T, C2 &gt; &amp;b, MultiArrayView&lt; 2, T, C3 &gt; x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1, class C2, class C3&gt; </td></tr><tr>
          <td class="memname">bool vigra::linalg::reverseElimination           </td>
          <td>(</td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deprecated, use <a class="el" href="group__MatrixAlgebra.html#g8950e99153326c453cd6a33e6f4822b3">linearSolveUpperTriangular()</a>. 
</div>
</div><p>
<a class="anchor" name="g8950e99153326c453cd6a33e6f4822b3"></a><!-- doxytag: member="vigra::linalg::linearSolveUpperTriangular" ref="g8950e99153326c453cd6a33e6f4822b3" args="(const MultiArrayView&lt; 2, T, C1 &gt; &amp;r, const MultiArrayView&lt; 2, T, C2 &gt; &amp;b, MultiArrayView&lt; 2, T, C3 &gt; x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1, class C2, class C3&gt; </td></tr><tr>
          <td class="memname">bool vigra::linalg::linearSolveUpperTriangular           </td>
          <td>(</td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solve a linear system with upper-triangular coefficient matrix.<p>
The square matrix <em>r</em> must be an upper-triangular coefficient matrix as can, for example, be obtained by means of QR decomposition. If <em>r</em> doesn't have full rank the function fails and returns <code>false</code>, otherwise it returns <code>true</code>. The lower triangular part of matrix <em>r</em> will not be touched, so it doesn't need to contain zeros.<p>
The column vectors of matrix <em>b</em> are the right-hand sides of the equation (several equations with the same coefficients can thus be solved in one go). The result is returned int <em>x</em>, whose columns contain the solutions for the corresponding columns of <em>b</em>. This implementation can be applied in-place, i.e. <code>&amp;b == &amp;x</code> is allowed. The following size requirements apply:<p>
<div class="fragment"><pre class="fragment">        <a class="code" href="group__LinearAlgebraFunctions.html#g8f0a6674670f576820b7c4c8ba56b2e9">rowCount</a>(r) == <a class="code" href="group__LinearAlgebraFunctions.html#g8126bdeb4bd52789eb1aad45500f05b7">columnCount</a>(r);
        <a class="code" href="group__LinearAlgebraFunctions.html#g8f0a6674670f576820b7c4c8ba56b2e9">rowCount</a>(r) == <a class="code" href="group__LinearAlgebraFunctions.html#g8f0a6674670f576820b7c4c8ba56b2e9">rowCount</a>(b);
        <a class="code" href="group__LinearAlgebraFunctions.html#g8126bdeb4bd52789eb1aad45500f05b7">columnCount</a>(r) == <a class="code" href="group__LinearAlgebraFunctions.html#g8f0a6674670f576820b7c4c8ba56b2e9">rowCount</a>(x);
        <a class="code" href="group__LinearAlgebraFunctions.html#g8126bdeb4bd52789eb1aad45500f05b7">columnCount</a>(b) == <a class="code" href="group__LinearAlgebraFunctions.html#g8126bdeb4bd52789eb1aad45500f05b7">columnCount</a>(x);
</pre></div><p>
<b>#include</b> &lt;<a href="linear__solve_8hxx-source.html">vigra/linear_solve.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
<a class="anchor" name="gdfeb2ba0c8e6b4ec938d606702b415ce"></a><!-- doxytag: member="vigra::linalg::linearSolveLowerTriangular" ref="gdfeb2ba0c8e6b4ec938d606702b415ce" args="(const MultiArrayView&lt; 2, T, C1 &gt; &amp;l, const MultiArrayView&lt; 2, T, C2 &gt; &amp;b, MultiArrayView&lt; 2, T, C3 &gt; x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1, class C2, class C3&gt; </td></tr><tr>
          <td class="memname">bool vigra::linalg::linearSolveLowerTriangular           </td>
          <td>(</td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt;&nbsp;</td>
          <td class="paramname"> <em>x</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solve a linear system with lower-triangular coefficient matrix.<p>
The square matrix <em>l</em> must be a lower-triangular coefficient matrix. If <em>l</em> doesn't have full rank the function fails and returns <code>false</code>, otherwise it returns <code>true</code>. The upper triangular part of matrix <em>l</em> will not be touched, so it doesn't need to contain zeros.<p>
The column vectors of matrix <em>b</em> are the right-hand sides of the equation (several equations with the same coefficients can thus be solved in one go). The result is returned in <em>x</em>, whose columns contain the solutions for the correspoinding columns of <em>b</em>. This implementation can be applied in-place, i.e. <code>&amp;b == &amp;x</code> is allowed. The following size requirements apply:<p>
<div class="fragment"><pre class="fragment">        <a class="code" href="group__LinearAlgebraFunctions.html#g8f0a6674670f576820b7c4c8ba56b2e9">rowCount</a>(l) == <a class="code" href="group__LinearAlgebraFunctions.html#g8126bdeb4bd52789eb1aad45500f05b7">columnCount</a>(l);
        <a class="code" href="group__LinearAlgebraFunctions.html#g8f0a6674670f576820b7c4c8ba56b2e9">rowCount</a>(l) == <a class="code" href="group__LinearAlgebraFunctions.html#g8f0a6674670f576820b7c4c8ba56b2e9">rowCount</a>(b);
        <a class="code" href="group__LinearAlgebraFunctions.html#g8126bdeb4bd52789eb1aad45500f05b7">columnCount</a>(l) == <a class="code" href="group__LinearAlgebraFunctions.html#g8f0a6674670f576820b7c4c8ba56b2e9">rowCount</a>(x);
        <a class="code" href="group__LinearAlgebraFunctions.html#g8126bdeb4bd52789eb1aad45500f05b7">columnCount</a>(b) == <a class="code" href="group__LinearAlgebraFunctions.html#g8126bdeb4bd52789eb1aad45500f05b7">columnCount</a>(x);
</pre></div><p>
<b>#include</b> &lt;<a href="linear__solve_8hxx-source.html">vigra/linear_solve.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
<a class="anchor" name="gef8edc8b2eab94efae5c775551c55cb6"></a><!-- doxytag: member="vigra::linalg::linearSolve" ref="gef8edc8b2eab94efae5c775551c55cb6" args="(const MultiArrayView&lt; 2, T, C1 &gt; &amp;A, const MultiArrayView&lt; 2, T, C2 &gt; &amp;b, MultiArrayView&lt; 2, T, C3 &gt; &amp;res, std::string method=&quot;QR&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1, class C2, class C3&gt; </td></tr><tr>
          <td class="memname">bool vigra::linalg::linearSolve           </td>
          <td>(</td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MultiArrayView&lt; 2, T, C2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>&quot;QR&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Solve a linear system.<p>
<em>A</em> is the coefficient matrix, and the column vectors in <em>b</em> are the right-hand sides of the equation (so, several equations with the same coefficients can be solved in one go). The result is returned in <em>res</em>, whose columns contain the solutions for the corresponding columns of <em>b</em>. The number of columns of <em>A</em> must equal the number of rows of both <em>b</em> and <em>res</em>, and the number of columns of <em>b</em> and <em>res</em> must match.<p>
<em>method</em> must be one of the following: <dl>
<dt>"Cholesky"</dt>
<dd>Compute the solution by means of Cholesky decomposition. The coefficient matrix <em>A</em> must by symmetric positive definite. If this is not the case, the function returns <code>false</code>.<p>
</dd>
<dt>"QR"</dt>
<dd>(default) Compute the solution by means of QR decomposition. The coefficient matrix <em>A</em> can be square or rectangular. In the latter case, it must have more rows than columns, and the solution will be computed in the least squares sense. If <em>A</em> doesn't have full rank, the function returns <code>false</code>.<p>
</dd>
<dt>"SVD"</dt>
<dd>Compute the solution by means of singular value decomposition. The coefficient matrix <em>A</em> can be square or rectangular. In the latter case, it must have more rows than columns, and the solution will be computed in the least squares sense. If <em>A</em> doesn't have full rank, the function returns <code>false</code>.<p>
</dd>
<dt>"NE"</dt>
<dd>Compute the solution by means of the normal equations, i.e. by applying Cholesky decomposition to the equivalent problem <code>A'*A*x = A'*b</code>. This only makes sense when the equation is to be solved in the least squares sense, i.e. when <em>A</em> is a rectangular matrix with more rows than columns. If <em>A</em> doesn't have full column rank, the function returns <code>false</code>. </dd>
</dl>
<p>
This function can be applied in-place, i.e. <code>&amp;b == &amp;res</code> or <code>&amp;A == &amp;res</code> are allowed (provided they have the required shapes).<p>
The following size requirements apply:<p>
<div class="fragment"><pre class="fragment">        <a class="code" href="group__LinearAlgebraFunctions.html#g8f0a6674670f576820b7c4c8ba56b2e9">rowCount</a>(r) == <a class="code" href="group__LinearAlgebraFunctions.html#g8f0a6674670f576820b7c4c8ba56b2e9">rowCount</a>(b);
        <a class="code" href="group__LinearAlgebraFunctions.html#g8126bdeb4bd52789eb1aad45500f05b7">columnCount</a>(r) == <a class="code" href="group__LinearAlgebraFunctions.html#g8f0a6674670f576820b7c4c8ba56b2e9">rowCount</a>(x);
        <a class="code" href="group__LinearAlgebraFunctions.html#g8126bdeb4bd52789eb1aad45500f05b7">columnCount</a>(b) == <a class="code" href="group__LinearAlgebraFunctions.html#g8126bdeb4bd52789eb1aad45500f05b7">columnCount</a>(x);
</pre></div><p>
<b>#include</b> &lt;<a href="linear__solve_8hxx-source.html">vigra/linear_solve.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
<a class="anchor" name="g18d34c1c9083fe0d8cf9aaeb2355ef50"></a><!-- doxytag: member="vigra::linalg::leastSquares" ref="g18d34c1c9083fe0d8cf9aaeb2355ef50" args="(MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; &amp;x, std::string method=&quot;QR&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1, class C2, class C3&gt; </td></tr><tr>
          <td class="memname">bool vigra::linalg::leastSquares           </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>&quot;QR&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ordinary Least Squares Regression.<p>
Given a matrix <em>A</em> with <code>m</code> rows and <code>n</code> columns (with <code>m &gt;= n</code>), and a column vector <em>b</em> of length <code>m</code> rows, this function computes a column vector <em>x</em> of length <code>n</code> rows such that the residual<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left|\textrm{\bf A} \textrm{\bf x} - \textrm{\bf b}\right|^2 \]" src="form_59.png">
<p>
<p>
is minimized. When <em>b</em> is a matrix with <code>k</code> columns, <em>x</em> must also have <code>k</code> columns, which will contain the solutions for the corresponding columns of <em>b</em>. Note that all matrices must already have the correct shape.<p>
This function is just another name for <a class="el" href="group__MatrixAlgebra.html#gef8edc8b2eab94efae5c775551c55cb6">linearSolve()</a>, perhaps leading to more readable code when <em>A</em> is a rectangular matrix. It returns <code>false</code> when the rank of <em>A</em> is less than <code>n</code>. See <a class="el" href="group__MatrixAlgebra.html#gef8edc8b2eab94efae5c775551c55cb6">linearSolve()</a> for more documentation.<p>
<b>#include</b> &lt;<a href="regression_8hxx-source.html">vigra/regression_8hxx.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
<a class="anchor" name="g8718006a36f67e3ed75131e705ae517f"></a><!-- doxytag: member="vigra::linalg::weightedLeastSquares" ref="g8718006a36f67e3ed75131e705ae517f" args="(MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; const &amp;weights, MultiArrayView&lt; 2, T, C4 &gt; &amp;x, std::string method=&quot;QR&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1, class C2, class C3, class C4&gt; </td></tr><tr>
          <td class="memname">bool vigra::linalg::weightedLeastSquares           </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>method</em> = <code>&quot;QR&quot;</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Weighted Least Squares Regression.<p>
Given a matrix <em>A</em> with <code>m</code> rows and <code>n</code> columns (with <code>m &gt;= n</code>), a vector <em>b</em> of length <code>m</code>, and a weight vector <em>weights</em> of length <code>m</code> with non-negative entries, this function computes a vector <em>x</em> of length <code>n</code> such that the weighted residual<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left(\textrm{\bf A} \textrm{\bf x} - \textrm{\bf b}\right)^T \textrm{diag}(\textrm{\bf weights}) \left(\textrm{\bf A} \textrm{\bf x} - \textrm{\bf b}\right) \]" src="form_60.png">
<p>
<p>
is minimized, where <code>diag(weights)</code> creates a diagonal matrix from <em>weights</em>. The algorithm calls <a class="el" href="group__MatrixAlgebra.html#g18d34c1c9083fe0d8cf9aaeb2355ef50">leastSquares()</a> on the equivalent problem<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left|\textrm{diag}(\textrm{\bf weights})^{1/2}\textrm{\bf A} \textrm{\bf x} - \textrm{diag}(\textrm{\bf weights})^{1/2} \textrm{\bf b}\right|^2 \]" src="form_61.png">
<p>
<p>
where the square root of <em>weights</em> is just taken element-wise.<p>
When <em>b</em> is a matrix with <code>k</code> columns, <em>x</em> must also have <code>k</code> columns, which will contain the solutions for the corresponding columns of <em>b</em>. Note that all matrices must already have the correct shape.<p>
The function returns <code>false</code> when the rank of the weighted matrix <em>A</em> is less than <code>n</code>.<p>
<b>#include</b> &lt;<a href="regression_8hxx-source.html">vigra/regression.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
<a class="anchor" name="g7b22decce13240b6d58d5cdeef3db759"></a><!-- doxytag: member="vigra::linalg::ridgeRegression" ref="g7b22decce13240b6d58d5cdeef3db759" args="(MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; &amp;x, double lambda)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1, class C2, class C3&gt; </td></tr><tr>
          <td class="memname">bool vigra::linalg::ridgeRegression           </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>lambda</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ridge Regression.<p>
Given a matrix <em>A</em> with <code>m</code> rows and <code>n</code> columns (with <code>m &gt;= n</code>), a vector <em>b</em> of length <code>m</code>, and a regularization parameter <code>lambda &gt;= 0.0</code>, this function computes a vector <em>x</em> of length <code>n</code> such that the residual<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left|\textrm{\bf A} \textrm{\bf x} - \textrm{\bf b}\right|^2 + \lambda \textrm{\bf x}^T\textrm{\bf x} \]" src="form_62.png">
<p>
<p>
is minimized. This is implemented by means of <a class="el" href="group__MatrixAlgebra.html#g04c25c7386cca251e2f95c671e0cfc19">singularValueDecomposition()</a>.<p>
When <em>b</em> is a matrix with <code>k</code> columns, <em>x</em> must also have <code>k</code> columns, which will contain the solutions for the corresponding columns of <em>b</em>. Note that all matrices must already have the correct shape.<p>
The function returns <code>false</code> if the rank of <em>A</em> is less than <code>n</code> and <code>lambda == 0.0</code>.<p>
<b>#include</b> &lt;<a href="regression_8hxx-source.html">vigra/regression.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
<a class="anchor" name="g934703bfd58fb06aaaf897ce7c4814ed"></a><!-- doxytag: member="vigra::linalg::weightedRidgeRegression" ref="g934703bfd58fb06aaaf897ce7c4814ed" args="(MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; const &amp;weights, MultiArrayView&lt; 2, T, C4 &gt; &amp;x, double lambda)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1, class C2, class C3, class C4&gt; </td></tr><tr>
          <td class="memname">bool vigra::linalg::weightedRidgeRegression           </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>lambda</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Weighted ridge Regression.<p>
Given a matrix <em>A</em> with <code>m</code> rows and <code>n</code> columns (with <code>m &gt;= n</code>), a vector <em>b</em> of length <code>m</code>, a weight vector <em>weights</em> of length <code>m</code> with non-negative entries, and a regularization parameter <code>lambda &gt;= 0.0</code> this function computes a vector <em>x</em> of length <code>n</code> such that the weighted residual<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left(\textrm{\bf A} \textrm{\bf x} - \textrm{\bf b}\right)^T \textrm{diag}(\textrm{\bf weights}) \left(\textrm{\bf A} \textrm{\bf x} - \textrm{\bf b}\right) + \lambda \textrm{\bf x}^T\textrm{\bf x} \]" src="form_63.png">
<p>
<p>
is minimized, where <code>diag(weights)</code> creates a diagonal matrix from <em>weights</em>. The algorithm calls <a class="el" href="group__MatrixAlgebra.html#g7b22decce13240b6d58d5cdeef3db759">ridgeRegression()</a> on the equivalent problem<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left|\textrm{diag}(\textrm{\bf weights})^{1/2}\textrm{\bf A} \textrm{\bf x} - \textrm{diag}(\textrm{\bf weights})^{1/2} \textrm{\bf b}\right|^2 + \lambda \textrm{\bf x}^T\textrm{\bf x} \]" src="form_64.png">
<p>
<p>
where the square root of <em>weights</em> is just taken element-wise. This solution is computed by means of <a class="el" href="group__MatrixAlgebra.html#g04c25c7386cca251e2f95c671e0cfc19">singularValueDecomposition()</a>.<p>
When <em>b</em> is a matrix with <code>k</code> columns, <em>x</em> must also have <code>k</code> columns, which will contain the solutions for the corresponding columns of <em>b</em>. Note that all matrices must already have the correct shape.<p>
The function returns <code>false</code> if the rank of <em>A</em> is less than <code>n</code> and <code>lambda == 0.0</code>.<p>
<b>#include</b> &lt;<a href="regression_8hxx-source.html">vigra/regression.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
<a class="anchor" name="g87100f96920d114852ab6ab6c113238d"></a><!-- doxytag: member="vigra::linalg::ridgeRegressionSeries" ref="g87100f96920d114852ab6ab6c113238d" args="(MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; const &amp;b, MultiArrayView&lt; 2, T, C3 &gt; &amp;x, Array const &amp;lambda)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1, class C2, class C3, class Array&gt; </td></tr><tr>
          <td class="memname">bool vigra::linalg::ridgeRegressionSeries           </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array const &amp;&nbsp;</td>
          <td class="paramname"> <em>lambda</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ridge Regression with many lambdas.<p>
This executes <a class="el" href="group__MatrixAlgebra.html#g7b22decce13240b6d58d5cdeef3db759">ridgeRegression()</a> for a sequence of regularization parameters. This is implemented so that the <a class="el" href="group__MatrixAlgebra.html#g04c25c7386cca251e2f95c671e0cfc19">singularValueDecomposition()</a> has to be executed only once. <em>lambda</em> must be an array conforming to the <code>std::vector</code> interface, i.e. must support <code>lambda.size()</code> and <code>lambda[k]</code>. The columns of the matrix <em>x</em> will contain the solutions for the corresponding lambda, so the number of columns of the matrix <em>x</em> must be equal to <code>lambda.size()</code>, and <em>b</em> must be a columns vector, i.e. cannot contain several right hand sides at once.<p>
The function returns <code>false</code> when the matrix <em>A</em> is rank deficient. If this happens, and one of the lambdas is zero, the corresponding column of <em>x</em> will be skipped.<p>
<b>#include</b> &lt;<a href="regression_8hxx-source.html">vigra/regression.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
<a class="anchor" name="g04c25c7386cca251e2f95c671e0cfc19"></a><!-- doxytag: member="vigra::linalg::singularValueDecomposition" ref="g04c25c7386cca251e2f95c671e0cfc19" args="(MultiArrayView&lt; 2, T, C1 &gt; const &amp;A, MultiArrayView&lt; 2, T, C2 &gt; &amp;U, MultiArrayView&lt; 2, T, C3 &gt; &amp;S, MultiArrayView&lt; 2, T, C4 &gt; &amp;V)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T, class C1, class C2, class C3, class C4&gt; </td></tr><tr>
          <td class="memname">unsigned int vigra::linalg::singularValueDecomposition           </td>
          <td>(</td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C1 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C3 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MultiArrayView&lt; 2, T, C4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>V</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Singular Value Decomposition.<p>
For an m-by-n matrix <em>A</em> with m &gt;= n, the singular value decomposition is an m-by-n orthogonal matrix <em>U</em>, an n-by-n diagonal matrix S, and an n-by-n orthogonal matrix <em>V</em> so that A = U*S*V'.<p>
To save memory, this functions stores the matrix <em>S</em> in a column vector of appropriate length (a diagonal matrix can be obtained by <code>diagonalMatrix(S)</code>). The singular values, sigma[k] = S(k, 0), are ordered so that sigma[0] &gt;= sigma[1] &gt;= ... &gt;= sigma[n-1].<p>
The singular value decomposition always exists, so this function will never fail (except if the shapes of the argument matrices don't match). The effective numerical rank of A is returned.<p>
(Adapted from JAMA, a Java <a class="el" href="classvigra_1_1linalg_1_1Matrix.html">Matrix</a> Library, developed jointly by the Mathworks and NIST; see <a href="http://math.nist.gov/javanumerics/jama">http://math.nist.gov/javanumerics/jama</a>).<p>
<b>#include</b> &lt;<a href="singular__value__decomposition_8hxx-source.html">vigra/singular_value_decomposition.hxx</a>&gt; or<br>
 <b>#include</b> &lt;<a href="linear__algebra_8hxx-source.html">vigra/linear_algebra.hxx</a>&gt;<br>
 Namespaces: <a class="el" href="namespacevigra.html">vigra</a> and <a class="el" href="namespacevigra_1_1linalg.html">vigra::linalg</a> 
</div>
</div><p>
</div>
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
VIGRA 1.6.0 (13 Aug 2008)
</i>
</tr>
</table>


</BODY>
</HTML>
