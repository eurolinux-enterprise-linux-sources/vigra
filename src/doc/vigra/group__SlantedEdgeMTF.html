<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>VIGRA - VIGRA: Camera MTF Estimation</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Camera MTF Estimation
</td>
<td align=right><a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif"></a></td></tr>
</table><p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1SlantedEdgeMTFOptions.html">SlantedEdgeMTFOptions</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pass options to one of the <a class="el" href="group__SlantedEdgeMTF.html#gbdcc512f9fc5653ef63ca6b882bd0869">slantedEdgeMTF()</a> functions.  <a href="classvigra_1_1SlantedEdgeMTFOptions.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Vector&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SlantedEdgeMTF.html#g1f3784ee90a84a60131520895344cd40">mtfFitGaussian</a> (Vector const &amp;mtf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fit a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> function to a given MTF.  <a href="#g1f3784ee90a84a60131520895344cd40"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SlantedEdgeMTF.html#gbdcc512f9fc5653ef63ca6b882bd0869">slantedEdgeMTF</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the magnitude transfer function of the camera.  <a href="#gbdcc512f9fc5653ef63ca6b882bd0869"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2 class="details_section">Detailed Description</h2>
Determine the magnitude transfer function (MTF) of a camera using the slanted edge method. <hr><h2>Function Documentation</h2>
<a class="anchor" name="gbdcc512f9fc5653ef63ca6b882bd0869"></a><!-- doxytag: member="vigra::slantedEdgeMTF" ref="gbdcc512f9fc5653ef63ca6b882bd0869" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::slantedEdgeMTF           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the magnitude transfer function of the camera. 
<p>
This operator estimates the magnitude transfer function (MTF) of a camera by means of the slanted edge method described in:<p>
ISO Standard No. 12233: <em>"Photography - Electronic still picture cameras - Resolution measurements"</em>, 2000<p>
The input must be an image that contains a single step edge with bright pixels on one side and dark pixels on the other. However, the intensity values must be neither saturated nor zero. The algorithms computes the MTF from the Fourier transform of the edge's derivative. Thus, if the actual MTF is unisotropic, the estimated MTF does actually only apply in the direction perpendicular to the edge - several edges at different orientations are required to estimate an unisotropic MTF.<p>
The algorithm returns a sequence of frequency / attenuation pairs. The frequency axis is normalized so that the Nyquist frequency of the original image is 0.5. Since the edge's derivative is computed with subpixel accuracy, the attenuation can usually be computed for frequencies significantly above the Nyquist frequency as well. The MTF estimate ends at either the first zero crossing of the MTF or at frequency 1, whichever comes earlier.<p>
The present implementation improves the original slanted edge algorithm according to ISO 12233 in a number of ways:<p>
<ul>
<li>
The edge is not required to run nearly vertically or horizontally (i.e. with a slant of approximately 5 degrees). The algorithm will automatically compute the edge's actual angle and adjust estimates accordingly. However, it is still necessary for the edge to be somewhat slanted, because subpixel-accurate estimation of the derivative is impossible otherwise (i.e. the edge position perpendicular to the edge direction must differ by at least 1 pixel between the two ends of the edge).<p>
</li>
<li>
Our implementation uses a more accurate subpixel derivative algrithm. In addition, we first perform a shading correction in order to reduce possible derivative bias due to nonuniform illumination.<p>
</li>
<li>
If the input image is large enough (i.e. there are at least 20 pixels on either side of the edge over the edge's entire length), our algorithm attempts to subtract the estimated noise power spectrum from the estimated MTF. </li>
</ul>
<p>
The source value type (<code>SrcAccessor::value_type</code>) must be a scalar type which is convertible to <code>double</code>. The result is written into the <em>result</em> sequence, whose <code>value_type</code> must be constructible from two <code>double</code> values. Algorithm options can be set via the <em>options</em> object (see <a class="el" href="classvigra_1_1NoiseNormalizationOptions.html">vigra::NoiseNormalizationOptions</a> for details).<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> SrcIterator, <span class="keyword">class</span> SrcAccessor, <span class="keyword">class</span> BackInsertable&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__SlantedEdgeMTF.html#gbdcc512f9fc5653ef63ca6b882bd0869" title="Determine the magnitude transfer function of the camera.">slantedEdgeMTF</a>(SrcIterator sul, SrcIterator slr, SrcAccessor src, BackInsertable &amp; mtf,
                    SlantedEdgeMTFOptions <span class="keyword">const</span> &amp; options = SlantedEdgeMTFOptions());
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> SrcIterator, <span class="keyword">class</span> SrcAccessor, <span class="keyword">class</span> BackInsertable&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__SlantedEdgeMTF.html#gbdcc512f9fc5653ef63ca6b882bd0869" title="Determine the magnitude transfer function of the camera.">slantedEdgeMTF</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src, BackInsertable &amp; mtf,
                       SlantedEdgeMTFOptions <span class="keyword">const</span> &amp; options = SlantedEdgeMTFOptions())
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="slanted__edge__mtf_8hxx-source.html">vigra/slanted_edge_mtf.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::BImage</a> src(w,h);
    std::vector&lt;vigra::TinyVector&lt;double, 2&gt; &gt; mtf;
    
    ...
    <a class="code" href="group__SlantedEdgeMTF.html#gbdcc512f9fc5653ef63ca6b882bd0869" title="Determine the magnitude transfer function of the camera.">vigra::slantedEdgeMTF</a>(srcImageRange(src), mtf);
    
    <span class="comment">// print the frequency / attenuation pairs found</span>
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;result.size(); ++k)
        std::cout &lt;&lt; <span class="stringliteral">"frequency: "</span> &lt;&lt; mtf[k][0] &lt;&lt; <span class="stringliteral">", estimated attenuation: "</span> &lt;&lt; mtf[k][1] &lt;&lt; std::endl;
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcIterator upperleft, lowerright;
    SrcAccessor src;
    
    <span class="keyword">typedef</span> SrcAccessor::value_type SrcType;
    <span class="keyword">typedef</span> NumericTraits&lt;SrcType&gt;::isScalar isScalar;
    assert(isScalar::asBool == <span class="keyword">true</span>);
    
    <span class="keywordtype">double</span> value = src(uperleft);
    
    BackInsertable result;
    <span class="keyword">typedef</span> BackInsertable::value_type ResultType;    
    <span class="keywordtype">double</span> intensity, variance;
    result.push_back(ResultType(intensity, variance));
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g1f3784ee90a84a60131520895344cd40"></a><!-- doxytag: member="vigra::mtfFitGaussian" ref="g1f3784ee90a84a60131520895344cd40" args="(Vector const &amp;mtf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class Vector&gt; </td></tr><tr>
          <td class="memname">double vigra::mtfFitGaussian           </td>
          <td>(</td>
          <td class="paramtype">Vector const &amp;&nbsp;</td>
          <td class="paramname"> <em>mtf</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fit a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> function to a given MTF. 
<p>
This function expects a squence of frequency / attenuation pairs as produced by <a class="el" href="group__SlantedEdgeMTF.html#gbdcc512f9fc5653ef63ca6b882bd0869">slantedEdgeMTF()</a> and finds the best fitting <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> point spread function (<a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> functions are good approximations of the PSF of many real cameras). It returns the standard deviation (scale) of this function. The algorithm computes the standard deviation by means of a linear least square on the logarithm of the MTF, i.e. an algebraic fit rather than a Euclidean fit - thus, the resulting <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> may not be the one that intuitively fits the data optimally.<p>
<b> Declaration:</b><p>
<div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Vector&gt;
        <span class="keywordtype">double</span> <a class="code" href="group__SlantedEdgeMTF.html#g1f3784ee90a84a60131520895344cd40" title="Fit a Gaussian function to a given MTF.">mtfFitGaussian</a>(Vector <span class="keyword">const</span> &amp; mtf);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="slanted__edge__mtf_8hxx-source.html">vigra/slanted_edge_mtf.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::BImage</a> src(w,h);
    std::vector&lt;vigra::TinyVector&lt;double, 2&gt; &gt; mtf;
    
    ...
    <a class="code" href="group__SlantedEdgeMTF.html#gbdcc512f9fc5653ef63ca6b882bd0869" title="Determine the magnitude transfer function of the camera.">vigra::slantedEdgeMTF</a>(srcImageRange(src), mtf);
    <span class="keywordtype">double</span> scale = <a class="code" href="group__SlantedEdgeMTF.html#g1f3784ee90a84a60131520895344cd40" title="Fit a Gaussian function to a given MTF.">vigra::mtfFitGaussian</a>(mtf)
    
    std::cout &lt;&lt; "The camera PSF is approximately a Gaussian at scale " &lt;&lt; scale &lt;&lt; std::endl;
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    Vector mtf;
    <span class="keywordtype">int</span> numberOfMeasurements = mtf.size()
    
    <span class="keywordtype">double</span> frequency = mtf[0][0];
    <span class="keywordtype">double</span> attenuation = mtf[0][1];
</pre></div> 
</div>
</div><p>
</div>
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
VIGRA 1.6.0 (13 Aug 2008)
</i>
</tr>
</table>


</BODY>
</HTML>
