<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>VIGRA - VIGRA: Mathematical Functions</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Mathematical Functions
</td>
<td align=right><a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif"></a></td></tr>
</table><p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BSpline.html">BSpline</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1BSplineBase.html">BSplineBase</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1CatmullRomSpline.html">CatmullRomSpline</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1CoscotFunction.html">CoscotFunction</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Iterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g79279a6771df5f585b508628ff5ebc61">argMax</a> (Iterator first, Iterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Iterator, class UnaryFunctor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gac3f2fd33a316fe1e80bdb0d672e07b7">argMaxIf</a> (Iterator first, Iterator last, UnaryFunctor condition)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Iterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g3240912902a65d9082304f3d7a533173">argMin</a> (Iterator first, Iterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Iterator, class UnaryFunctor&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g3652eb9350eb38452b8107b26a1ccf0a">argMinIf</a> (Iterator first, Iterator last, UnaryFunctor condition)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g54aeb0113ef25c8a4f2e72a1acc794c5">ceilPower2</a> (UInt32 x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g0f6a2804ceaf785495472fb9bf2dd5bc">chi2</a> (unsigned int degreesOfFreedom, double arg, double accuracy=1e-7)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga94c7af27b4aecda8a764beb89dbc2a6">chi2CDF</a> (unsigned int degreesOfFreedom, double arg, double accuracy=1e-7)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g8ef85e4a27cbd7e0cd532ad3f6b3db4b">closeAtTolerance</a> (T1 l, T2 r, typename PromoteTraits&lt; T1, T2 &gt;::Promote epsilon)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g29d6193bd95ec54c5f25dd0470f58215">ellipticIntegralE</a> (double x, double k)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g7e909bd1d07e846d5d3ba78eaed7c520">ellipticIntegralF</a> (double x, double k)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g8b8b9e366958396bdfdd46ba1364f112">erf</a> (double x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g73c914923c1c096cef574906d6169329">floorPower2</a> (UInt32 x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename IntType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">IntType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga7954a1dde9a8a13e9090f148dffb9a5">gcd</a> (IntType n, IntType m)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gadeb8f8d057b08852b6e36b862ab9d72">hypot</a> (double a, double b)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename IntType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">IntType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g7bc03cb6d19a309b9fea7e5b135fa547">lcm</a> (IntType n, IntType m)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g0271fdd97b849704cded72b31cce3c83">log2i</a> (UInt32 x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g074ace0a87d00243c85a52e5071a1ad4">noncentralChi2</a> (unsigned int degreesOfFreedom, double noncentrality, double arg, double accuracy=1e-7)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g4e01fc59c3d8455e8ccbbd8824230226">noncentralChi2CDF</a> (unsigned int degreesOfFreedom, double noncentrality, double arg, double accuracy=1e-7)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gddeff01bf2aa44ad74399a1888a6bbfb">noncentralChi2CDFApprox</a> (unsigned int degreesOfFreedom, double noncentrality, double arg)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">NormTraits&lt; T &gt;::NormType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g5df3142a37f4dc390ff949bff486c4d8">norm</a> (T const &amp;t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">result_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gebd375194b3220beebe0a22e67d7a4e8">operator()</a> (argument_type x) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g23027b5a14396e8f6a0559e8db50cc41">round</a> (float t)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T1&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#gccc7abd1b76da8bd3f72f96873e962f3">sign</a> (T1 t1, T2 t2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#ga676c74bca158f2556180ad221ef2d31">sign</a> (T t)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">NumericTraits&lt; T &gt;::Promote&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g76b63321670e191a1fe94b1e5ddeb3d4">sq</a> (T t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">UInt32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g03456314a725357cee877a020e11c560">sqrti</a> (UInt32 v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g238d174bd3f9e6d78299618a35924624">sqrti</a> (Int32 v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">NormTraits&lt; T &gt;::SquaredNormType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MathFunctions.html#g38870065d4c6e12602b9154c7e69df1f">squaredNorm</a> (T const &amp;t)</td></tr>

</table>
<hr><a name="_details"></a><h2 class="details_section">Detailed Description</h2>
Useful mathematical functions and functors. <hr><h2>Function Documentation</h2>
<a class="anchor" name="g23027b5a14396e8f6a0559e8db50cc41"></a><!-- doxytag: member="vigra::round" ref="g23027b5a14396e8f6a0559e8db50cc41" args="(float t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float vigra::round           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The rounding function.<p>
Defined for all floating point types. Rounds towards the nearest integer such that <code>abs(round(t)) == round(abs(t))</code> for all <code>t</code>.<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g54aeb0113ef25c8a4f2e72a1acc794c5"></a><!-- doxytag: member="vigra::ceilPower2" ref="g54aeb0113ef25c8a4f2e72a1acc794c5" args="(UInt32 x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 vigra::ceilPower2           </td>
          <td>(</td>
          <td class="paramtype">UInt32&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Round up to the nearest power of 2.<p>
Efficient algorithm for finding the smallest power of 2 which is not smaller than <em>x</em> (function clp2() from Henry Warren: "Hacker's Delight", Addison-Wesley, 2003, see <a href="http://www.hackersdelight.org/">http://www.hackersdelight.org/</a>). If <em>x</em> &gt; 2^31, the function will return 0 because integer arithmetic is defined modulo 2^32.<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g73c914923c1c096cef574906d6169329"></a><!-- doxytag: member="vigra::floorPower2" ref="g73c914923c1c096cef574906d6169329" args="(UInt32 x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 vigra::floorPower2           </td>
          <td>(</td>
          <td class="paramtype">UInt32&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Round down to the nearest power of 2.<p>
Efficient algorithm for finding the largest power of 2 which is not greater than <em>x</em> (function flp2() from Henry Warren: "Hacker's Delight", Addison-Wesley, 2003, see <a href="http://www.hackersdelight.org/">http://www.hackersdelight.org/</a>).<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g0271fdd97b849704cded72b31cce3c83"></a><!-- doxytag: member="vigra::log2i" ref="g0271fdd97b849704cded72b31cce3c83" args="(UInt32 x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 vigra::log2i           </td>
          <td>(</td>
          <td class="paramtype">UInt32&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the base-2 logarithm of an integer.<p>
Returns the position of the left-most 1-bit in the given number <em>x</em>, or -1 if <em>x</em> == 0. That is,<p>
<div class="fragment"><pre class="fragment">        assert(k &gt;= 0 &amp;&amp; k &lt; 32 &amp;&amp; <a class="code" href="group__MathFunctions.html#g0271fdd97b849704cded72b31cce3c83">log2i</a>(1 &lt;&lt; k) == k);
</pre></div><p>
The function uses Robert Harley's algorithm to determine the number of leading zeros in <em>x</em> (algorithm nlz10() at <a href="http://www.hackersdelight.org/">http://www.hackersdelight.org/</a>). But note that the functions <a class="el" href="group__MathFunctions.html#g73c914923c1c096cef574906d6169329">floorPower2()</a> or <a class="el" href="group__MathFunctions.html#g54aeb0113ef25c8a4f2e72a1acc794c5">ceilPower2()</a> are more efficient and should be preferred when possible.<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g76b63321670e191a1fe94b1e5ddeb3d4"></a><!-- doxytag: member="vigra::sq" ref="g76b63321670e191a1fe94b1e5ddeb3d4" args="(T t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T&gt; </td></tr><tr>
          <td class="memname">NumericTraits&lt;T&gt;::Promote vigra::sq           </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The square function.<p>
<code>sq(x) = x*x</code> is needed so often that it makes sense to define it as a function.<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g238d174bd3f9e6d78299618a35924624"></a><!-- doxytag: member="vigra::sqrti" ref="g238d174bd3f9e6d78299618a35924624" args="(Int32 v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int32 vigra::sqrti           </td>
          <td>(</td>
          <td class="paramtype">Int32&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signed integer square root.<p>
Useful for fast fixed-point computations.<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g03456314a725357cee877a020e11c560"></a><!-- doxytag: member="vigra::sqrti" ref="g03456314a725357cee877a020e11c560" args="(UInt32 v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UInt32 vigra::sqrti           </td>
          <td>(</td>
          <td class="paramtype">UInt32&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unsigned integer square root.<p>
Useful for fast fixed-point computations.<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="gadeb8f8d057b08852b6e36b862ab9d72"></a><!-- doxytag: member="vigra::hypot" ref="gadeb8f8d057b08852b6e36b862ab9d72" args="(double a, double b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::hypot           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the Euclidean distance (length of the hypothenuse of a right-angled triangle).<p>
The <a class="el" href="group__MathFunctions.html#gadeb8f8d057b08852b6e36b862ab9d72">hypot()</a> function returns the sqrt(a*a + b*b). It is implemented in a way that minimizes round-off error.<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="ga676c74bca158f2556180ad221ef2d31"></a><!-- doxytag: member="vigra::sign" ref="ga676c74bca158f2556180ad221ef2d31" args="(T t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T&gt; </td></tr><tr>
          <td class="memname">T vigra::sign           </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The sign function.<p>
Returns 1, 0, or -1 depending on the sign of <em>t</em>.<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="gccc7abd1b76da8bd3f72f96873e962f3"></a><!-- doxytag: member="vigra::sign" ref="gccc7abd1b76da8bd3f72f96873e962f3" args="(T1 t1, T2 t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T1, class T2&gt; </td></tr><tr>
          <td class="memname">T1 vigra::sign           </td>
          <td>(</td>
          <td class="paramtype">T1&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The binary sign function.<p>
Transfers the sign of <em>t2</em> to <em>t1</em>.<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g38870065d4c6e12602b9154c7e69df1f"></a><!-- doxytag: member="vigra::squaredNorm" ref="g38870065d4c6e12602b9154c7e69df1f" args="(T const &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NormTraits&lt;T&gt;::SquaredNormType vigra::squaredNorm           </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The squared norm of a numerical object.<p>
For scalar types: equals <code>vigra::sq(t)</code><br>
. For vectorial types: equals <code>vigra::dot(t, t)</code><br>
. For complex types: equals <code><a class="el" href="group__MathFunctions.html#g76b63321670e191a1fe94b1e5ddeb3d4">vigra::sq</a>(t.real()) + <a class="el" href="group__MathFunctions.html#g76b63321670e191a1fe94b1e5ddeb3d4">vigra::sq</a>(t.imag())</code><br>
. For matrix types: results in the squared Frobenius norm (sum of squares of the matrix elements). 
</div>
</div><p>
<a class="anchor" name="g5df3142a37f4dc390ff949bff486c4d8"></a><!-- doxytag: member="vigra::norm" ref="g5df3142a37f4dc390ff949bff486c4d8" args="(T const &amp;t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T&gt; </td></tr><tr>
          <td class="memname">NormTraits&lt;T&gt;::NormType vigra::norm           </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The norm of a numerical object.<p>
For scalar types: implemented as <code>abs(t)</code><br>
 otherwise: implemented as <code>sqrt(squaredNorm(t))</code>.<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g3240912902a65d9082304f3d7a533173"></a><!-- doxytag: member="vigra::argMin" ref="g3240912902a65d9082304f3d7a533173" args="(Iterator first, Iterator last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class Iterator&gt; </td></tr><tr>
          <td class="memname">Iterator vigra::argMin           </td>
          <td>(</td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the minimum element in a sequence.<p>
The function returns the iterator refering to the minimum element.<p>
<b>Required Interface:</b><p>
<div class="fragment"><pre class="fragment">        Iterator is a standard forward iterator.
        
        <span class="keywordtype">bool</span> f = *first &lt; NumericTraits&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::max();
</pre></div><p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g79279a6771df5f585b508628ff5ebc61"></a><!-- doxytag: member="vigra::argMax" ref="g79279a6771df5f585b508628ff5ebc61" args="(Iterator first, Iterator last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class Iterator&gt; </td></tr><tr>
          <td class="memname">Iterator vigra::argMax           </td>
          <td>(</td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the maximum element in a sequence.<p>
The function returns the iterator refering to the maximum element.<p>
<b>Required Interface:</b><p>
<div class="fragment"><pre class="fragment">        Iterator is a standard forward iterator.
        
        <span class="keywordtype">bool</span> f = NumericTraits&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::min() &lt; *first;
</pre></div><p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g3652eb9350eb38452b8107b26a1ccf0a"></a><!-- doxytag: member="vigra::argMinIf" ref="g3652eb9350eb38452b8107b26a1ccf0a" args="(Iterator first, Iterator last, UnaryFunctor condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class Iterator, class UnaryFunctor&gt; </td></tr><tr>
          <td class="memname">Iterator vigra::argMinIf           </td>
          <td>(</td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunctor&nbsp;</td>
          <td class="paramname"> <em>condition</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the minimum element in a sequence conforming to a condition.<p>
The function returns the iterator refering to the minimum element, where only elements conforming to the condition (i.e. where <code>condition(*iterator)</code> evaluates to <code>true</code>) are considered. If no element conforms to the condition, or the sequence is empty, the end iterator <em>last</em> is returned.<p>
<b>Required Interface:</b><p>
<div class="fragment"><pre class="fragment">        Iterator is a standard forward iterator.
        
        <span class="keywordtype">bool</span> c = condition(*first);
        
        <span class="keywordtype">bool</span> f = *first &lt; NumericTraits&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::max();
</pre></div><p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="gac3f2fd33a316fe1e80bdb0d672e07b7"></a><!-- doxytag: member="vigra::argMaxIf" ref="gac3f2fd33a316fe1e80bdb0d672e07b7" args="(Iterator first, Iterator last, UnaryFunctor condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class Iterator, class UnaryFunctor&gt; </td></tr><tr>
          <td class="memname">Iterator vigra::argMaxIf           </td>
          <td>(</td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunctor&nbsp;</td>
          <td class="paramname"> <em>condition</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the maximum element in a sequence conforming to a condition.<p>
The function returns the iterator refering to the maximum element, where only elements conforming to the condition (i.e. where <code>condition(*iterator)</code> evaluates to <code>true</code>) are considered. If no element conforms to the condition, or the sequence is empty, the end iterator <em>last</em> is returned.<p>
<b>Required Interface:</b><p>
<div class="fragment"><pre class="fragment">        Iterator is a standard forward iterator.
        
        <span class="keywordtype">bool</span> c = condition(*first);
        
        <span class="keywordtype">bool</span> f = NumericTraits&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;::min() &lt; *first;
</pre></div><p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g7e909bd1d07e846d5d3ba78eaed7c520"></a><!-- doxytag: member="vigra::ellipticIntegralF" ref="g7e909bd1d07e846d5d3ba78eaed7c520" args="(double x, double k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::ellipticIntegralF           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The incomplete elliptic integral of the first kind.<p>
Computes<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{F}(x, k) = \int_0^x \frac{1}{\sqrt{1 - k^2 \sin(t)^2}} dt \]" src="form_52.png">
<p>
<p>
according to the algorithm given in Press et al. "Numerical Recipes".<p>
Note: In some libraries (e.g. Mathematica), the second parameter of the elliptic integral functions must be k^2 rather than k. Check the documentation when results disagree!<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g29d6193bd95ec54c5f25dd0470f58215"></a><!-- doxytag: member="vigra::ellipticIntegralE" ref="g29d6193bd95ec54c5f25dd0470f58215" args="(double x, double k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::ellipticIntegralE           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>k</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The incomplete elliptic integral of the second kind.<p>
Computes<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{E}(x, k) = \int_0^x \sqrt{1 - k^2 \sin(t)^2} dt \]" src="form_53.png">
<p>
<p>
according to the algorithm given in Press et al. "Numerical Recipes". The complete elliptic integral of the second kind is simply <code>ellipticIntegralE(M_PI/2, k)</code>.<p>
Note: In some libraries (e.g. Mathematica), the second parameter of the elliptic integral functions must be k^2 rather than k. Check the documentation when results disagree!<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g8b8b9e366958396bdfdd46ba1364f112"></a><!-- doxytag: member="vigra::erf" ref="g8b8b9e366958396bdfdd46ba1364f112" args="(double x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::erf           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The error function.<p>
If <code><a class="el" href="group__MathFunctions.html#g8b8b9e366958396bdfdd46ba1364f112">erf()</a></code> is not provided in the C standard math library (as it should according to the new C99 standard ?), VIGRA implements <code><a class="el" href="group__MathFunctions.html#g8b8b9e366958396bdfdd46ba1364f112">erf()</a></code> as an approximation of the error function<p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{erf}(x) = \int_0^x e^{-t^2} dt \]" src="form_54.png">
<p>
<p>
according to the formula given in Press et al. "Numerical Recipes".<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g0f6a2804ceaf785495472fb9bf2dd5bc"></a><!-- doxytag: member="vigra::chi2" ref="g0f6a2804ceaf785495472fb9bf2dd5bc" args="(unsigned int degreesOfFreedom, double arg, double accuracy=1e-7)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::chi2           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>degreesOfFreedom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em> = <code>1e-7</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Chi square distribution.<p>
Computes the density of a chi square distribution with <em>degreesOfFreedom</em> and tolerance <em>accuracy</em> at the given argument <em>arg</em> by calling <code>noncentralChi2(degreesOfFreedom, 0.0, arg, accuracy)</code>.<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="ga94c7af27b4aecda8a764beb89dbc2a6"></a><!-- doxytag: member="vigra::chi2CDF" ref="ga94c7af27b4aecda8a764beb89dbc2a6" args="(unsigned int degreesOfFreedom, double arg, double accuracy=1e-7)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::chi2CDF           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>degreesOfFreedom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em> = <code>1e-7</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cumulative chi square distribution.<p>
Computes the cumulative density of a chi square distribution with <em>degreesOfFreedom</em> and tolerance <em>accuracy</em> at the given argument <em>arg</em>, i.e. the probability that a random number drawn from the distribution is below <em>arg</em> by calling <code>noncentralChi2CDF(degreesOfFreedom, 0.0, arg, accuracy)</code>.<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g074ace0a87d00243c85a52e5071a1ad4"></a><!-- doxytag: member="vigra::noncentralChi2" ref="g074ace0a87d00243c85a52e5071a1ad4" args="(unsigned int degreesOfFreedom, double noncentrality, double arg, double accuracy=1e-7)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::noncentralChi2           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>degreesOfFreedom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>noncentrality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em> = <code>1e-7</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Non-central chi square distribution.<p>
Computes the density of a non-central chi square distribution with <em>degreesOfFreedom</em>, noncentrality parameter <em>noncentrality</em> and tolerance <em>accuracy</em> at the given argument <em>arg</em>. It uses Algorithm AS 231 from Appl. Statist. (1987) Vol.36, No.3 (code ported from <a href="http://lib.stat.cmu.edu/apstat/231">http://lib.stat.cmu.edu/apstat/231</a>). The algorithm has linear complexity in the number of degrees of freedom.<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g4e01fc59c3d8455e8ccbbd8824230226"></a><!-- doxytag: member="vigra::noncentralChi2CDF" ref="g4e01fc59c3d8455e8ccbbd8824230226" args="(unsigned int degreesOfFreedom, double noncentrality, double arg, double accuracy=1e-7)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::noncentralChi2CDF           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>degreesOfFreedom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>noncentrality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>accuracy</em> = <code>1e-7</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cumulative non-central chi square distribution.<p>
Computes the cumulative density of a chi square distribution with <em>degreesOfFreedom</em>, noncentrality parameter <em>noncentrality</em> and tolerance <em>accuracy</em> at the given argument <em>arg</em>, i.e. the probability that a random number drawn from the distribution is below <em>arg</em> It uses Algorithm AS 231 from Appl. Statist. (1987) Vol.36, No.3 (code ported from <a href="http://lib.stat.cmu.edu/apstat/231">http://lib.stat.cmu.edu/apstat/231</a>). The algorithm has linear complexity in the number of degrees of freedom (see <a class="el" href="group__MathFunctions.html#gddeff01bf2aa44ad74399a1888a6bbfb">noncentralChi2CDFApprox()</a> for a constant-time algorithm).<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="gddeff01bf2aa44ad74399a1888a6bbfb"></a><!-- doxytag: member="vigra::noncentralChi2CDFApprox" ref="gddeff01bf2aa44ad74399a1888a6bbfb" args="(unsigned int degreesOfFreedom, double noncentrality, double arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vigra::noncentralChi2CDFApprox           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>degreesOfFreedom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>noncentrality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cumulative non-central chi square distribution (approximate).<p>
Computes approximate values of the cumulative density of a chi square distribution with <em>degreesOfFreedom</em>, and noncentrality parameter <em>noncentrality</em> at the given argument <em>arg</em>, i.e. the probability that a random number drawn from the distribution is below <em>arg</em> It uses the approximate transform into a normal distribution due to Wilson and Hilferty (see Abramovitz, Stegun: "Handbook of Mathematical Functions", formula 26.3.32). The algorithm's running time is independent of the inputs, i.e. is should be used when <a class="el" href="group__MathFunctions.html#g4e01fc59c3d8455e8ccbbd8824230226">noncentralChi2CDF()</a> is too slow, and approximate values are sufficient. The accuracy is only about 0.1 for few degrees of freedom, but reaches about 0.001 above dof = 5.<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g8ef85e4a27cbd7e0cd532ad3f6b3db4b"></a><!-- doxytag: member="vigra::closeAtTolerance" ref="g8ef85e4a27cbd7e0cd532ad3f6b3db4b" args="(T1 l, T2 r, typename PromoteTraits&lt; T1, T2 &gt;::Promote epsilon)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class T1, class T2&gt; </td></tr><tr>
          <td class="memname">bool vigra::closeAtTolerance           </td>
          <td>(</td>
          <td class="paramtype">T1&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename PromoteTraits&lt; T1, T2 &gt;::Promote&nbsp;</td>
          <td class="paramname"> <em>epsilon</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tolerance based floating-point comparison.<p>
Check whether two floating point numbers are equal within the given tolerance. This is useful because floating point numbers that should be equal in theory are rarely exactly equal in practice. If the tolerance <em>epsilon</em> is not given, twice the machine epsilon is used.<p>
<b>#include</b> &lt;<a href="mathutil_8hxx-source.html">vigra/mathutil.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="ga7954a1dde9a8a13e9090f148dffb9a5"></a><!-- doxytag: member="vigra::gcd" ref="ga7954a1dde9a8a13e9090f148dffb9a5" args="(IntType n, IntType m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;typename IntType&gt; </td></tr><tr>
          <td class="memname">IntType vigra::gcd           </td>
          <td>(</td>
          <td class="paramtype">IntType&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the greatest common divisor.<p>
This function works for arbitrary integer types, including user-defined (e.g. infinite precision) ones.<p>
<b>#include</b> &lt;<a href="rational_8hxx-source.html">vigra/rational.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="g7bc03cb6d19a309b9fea7e5b135fa547"></a><!-- doxytag: member="vigra::lcm" ref="g7bc03cb6d19a309b9fea7e5b135fa547" args="(IntType n, IntType m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;typename IntType&gt; </td></tr><tr>
          <td class="memname">IntType vigra::lcm           </td>
          <td>(</td>
          <td class="paramtype">IntType&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType&nbsp;</td>
          <td class="paramname"> <em>m</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the lowest common multiple.<p>
This function works for arbitrary integer types, including user-defined (e.g. infinite precision) ones.<p>
<b>#include</b> &lt;<a href="rational_8hxx-source.html">vigra/rational.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="gebd375194b3220beebe0a22e67d7a4e8"></a><!-- doxytag: member="vigra::CatmullRomSpline::operator()" ref="gebd375194b3220beebe0a22e67d7a4e8" args="(argument_type x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CatmullRomSpline&lt; T &gt;::result_type operator()           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvigra_1_1CatmullRomSpline.html#e45326fbc1e2bb968bbb688bd8da81f1">argument_type</a>&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
function (functor) call 
</div>
</div><p>
</div>
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
VIGRA 1.6.0 (13 Aug 2008)
</i>
</tr>
</table>


</BODY>
</HTML>
