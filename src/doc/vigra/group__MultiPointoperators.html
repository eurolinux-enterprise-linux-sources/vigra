<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>VIGRA - VIGRA: Point operators for multi-dimensional arrays.</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Point operators for multi-dimensional arrays.
</td>
<td align=right><a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif"></a></td></tr>
</table><p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#g47334a2ed2e40de1f60606f06a1b7d9a">combineThreeMultiArrays</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine three multi-dimensional arrays into one using a ternary function or functor.  <a href="#g47334a2ed2e40de1f60606f06a1b7d9a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#g745d0821dafde88ef23ef315cc7fcb73">combineTwoMultiArrays</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combine two multi-dimensional arrays into one using a binary function or functor.  <a href="#g745d0821dafde88ef23ef315cc7fcb73"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#ga667c0e83304fe4c7e2318a82f5043ec">copyMultiArray</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a multi-dimensional array.  <a href="#ga667c0e83304fe4c7e2318a82f5043ec"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#gf81386d616fc0aec93b39b04f408dea8">initMultiArray</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a value to every pixel in a multi-dimensional array.  <a href="#gf81386d616fc0aec93b39b04f408dea8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Iterator, class Diff_type, class Accessor, class VALUETYPE&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#gc43ec8460b61298c6fafe181f2a85830">initMultiArrayBorder</a> (Iterator upperleft, Diff_type shape, Accessor a, int border_width, VALUETYPE v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write value to the specified border values in the array.  <a href="#gc43ec8460b61298c6fafe181f2a85830"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#gc17818407ac325c4c2510848a85dc6b5">inspectMultiArray</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call an analyzing functor at every element of a multi-dimensional array.  <a href="#gc17818407ac325c4c2510848a85dc6b5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#g673cdf358ac025137c460beb257ee3fa">inspectTwoMultiArrays</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call an analyzing functor at all corresponding elements of two multi-dimensional arrays.  <a href="#g673cdf358ac025137c460beb257ee3fa"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MultiPointoperators.html#g0c8e61d112544e0ff86e6aef1746d01b">transformMultiArray</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transform a multi-dimensional array with a unary function or functor.  <a href="#g0c8e61d112544e0ff86e6aef1746d01b"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2 class="details_section">Detailed Description</h2>
Copy, transform, and inspect arbitrary dimensional arrays which are represented by iterators compatible to <a class="el" href="MultiIteratorPage.html">Multi-dimensional Array Iterators</a>. Note that are range is here specified by a pair: an iterator referring to the first point of the array and a shape object specifying the size of the (rectangular) ROI.<p>
<b>#include</b> &lt;<a href="multi__pointoperators_8hxx-source.html">vigra/multi_pointoperators.hxx</a>&gt; <hr><h2>Function Documentation</h2>
<a class="anchor" name="gf81386d616fc0aec93b39b04f408dea8"></a><!-- doxytag: member="vigra::initMultiArray" ref="gf81386d616fc0aec93b39b04f408dea8" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::initMultiArray           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a value to every pixel in a multi-dimensional array. 
<p>
This function can be used to init the array which must be represented by a pair of iterators compatible to <a class="el" href="classvigra_1_1MultiIterator.html">vigra::MultiIterator</a>. It uses an accessor to access the data alements. Note that the iterator range must be specified by a shape object, because otherwise we could not control the range simultaneously in all dimensions (this is a necessary consequence of the <a class="el" href="classvigra_1_1MultiIterator.html">vigra::MultiIterator</a> design).<p>
The initial value can either be a constant of appropriate type (compatible with the destination's value_type), or a functor with compatible result_type. These two cases are automatically distinguished when <code>FunctorTraits&lt;FUNCTOR&gt;::isInitializer</code> yields <code>VigraTrueType</code>. Since the functor is passed by <code>const</code> reference, its <code>operator()</code> must be const, and ist internal state may need to be <code>mutable</code>.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> Shape, <span class="keyword">class</span> Accessor, <span class="keyword">class</span> VALUETYPE&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#gf81386d616fc0aec93b39b04f408dea8" title="Write a value to every pixel in a multi-dimensional array.">initMultiArray</a>(Iterator s, Shape <span class="keyword">const</span> &amp; shape, Accessor a,  VALUETYPE <span class="keyword">const</span> &amp; v);


        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> Shape, <span class="keyword">class</span> Accessor, <span class="keyword">class</span> FUNCTOR&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#gf81386d616fc0aec93b39b04f408dea8" title="Write a value to every pixel in a multi-dimensional array.">initMultiArray</a>(Iterator s, Shape <span class="keyword">const</span> &amp; shape, Accessor a,  FUNCTOR <span class="keyword">const</span> &amp; f);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> Shape, <span class="keyword">class</span> Accessor, <span class="keyword">class</span> VALUETYPE&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#gf81386d616fc0aec93b39b04f408dea8" title="Write a value to every pixel in a multi-dimensional array.">initMultiArray</a>(triple&lt;Iterator, Shape, Accessor&gt; <span class="keyword">const</span> &amp; s, VALUETYPE <span class="keyword">const</span> &amp; v);


        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> Shape, <span class="keyword">class</span> Accessor, <span class="keyword">class</span> FUNCTOR&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#gf81386d616fc0aec93b39b04f408dea8" title="Write a value to every pixel in a multi-dimensional array.">initMultiArray</a>(triple&lt;Iterator, Shape, Accessor&gt; <span class="keyword">const</span> &amp; s, FUNCTOR <span class="keyword">const</span> &amp; f);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="multi__pointoperators_8hxx-source.html">vigra/multi_pointoperators.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, int&gt;</a> Array;
    Array array(Array::size_type(100, 200, 50));
    
    <span class="comment">// zero the array</span>
    <a class="code" href="group__MultiPointoperators.html#gf81386d616fc0aec93b39b04f408dea8" title="Write a value to every pixel in a multi-dimensional array.">vigra::initMultiArray</a>(destMultiArrayRange(array), 0);
</pre></div><p>
<b> Required Interface:</b><p>
The function accepts either a value that is copied into every destination element:<p>
<div class="fragment"><pre class="fragment">    MultiIterator begin;
    
    Accessor accessor;
    VALUETYPE v;
    
    accessor.set(v, begin); 
</pre></div><p>
or a functor that is called (without argument) at every location, and the result is written into the current element. Internally, functors are recognized by the meta function <code>FunctorTraits&lt;FUNCTOR&gt;::isInitializer</code> yielding <code>VigraTrueType</code>. Make sure that your functor correctly defines <code><a class="el" href="classvigra_1_1FunctorTraits.html" title="Export associated information for a functor.">FunctorTraits</a></code> because otherwise the code will not compile.<p>
<div class="fragment"><pre class="fragment">    MultiIterator begin;    
    Accessor accessor;
    
    FUNCTOR f;
    assert(<span class="keyword">typeid</span>(FunctorTraits&lt;FUNCTOR&gt;::isInitializer) == <span class="keyword">typeid</span>(VigraTrueType));
    
    accessor.set(f(), begin); 
</pre></div> 
</div>
</div><p>
<a class="anchor" name="gc43ec8460b61298c6fafe181f2a85830"></a><!-- doxytag: member="vigra::initMultiArrayBorder" ref="gc43ec8460b61298c6fafe181f2a85830" args="(Iterator upperleft, Diff_type shape, Accessor a, int border_width, VALUETYPE v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;class Iterator, class Diff_type, class Accessor, class VALUETYPE&gt; </td></tr><tr>
          <td class="memname">void vigra::initMultiArrayBorder           </td>
          <td>(</td>
          <td class="paramtype">Iterator&nbsp;</td>
          <td class="paramname"> <em>upperleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Diff_type&nbsp;</td>
          <td class="paramname"> <em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>border_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VALUETYPE&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write value to the specified border values in the array. 
<p>

</div>
</div><p>
<a class="anchor" name="ga667c0e83304fe4c7e2318a82f5043ec"></a><!-- doxytag: member="vigra::copyMultiArray" ref="ga667c0e83304fe4c7e2318a82f5043ec" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::copyMultiArray           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy a multi-dimensional array. 
<p>
This function can be applied in two modes:<p>
<dl>
<dt><b>Standard Mode:</b> </dt>
<dd>If the source and destination arrays have the same size, the corresponding array elements are simply copied. If necessary, type conversion takes place. </dd>
<dt><b>Expanding Mode:</b> </dt>
<dd>If the source array has length 1 along some (or even all) dimensions, the source value at index 0 is used for all destination elements in those dimensions. For example, if we have single row of data (column length is 1), we can copy it into a 2D image of the same width: The given row is automatically repeated for every row of the destination image. Again, type conversion os performed if necessary. </dd>
</dl>
<p>
The arrays must be represented by iterators compatible with <a class="el" href="classvigra_1_1MultiIterator.html">vigra::MultiIterator</a>, and the iteration range is specified by means of shape objects. If only the source shape is given the destination array is assumed to have the same shape, and standard mode is applied. If two shapes are given, the size of corresponding dimensions must be either equal (standard copy), or the source length must be 1 (expanding copy). The function uses accessors to access the data elements.<p>
<b> Declarations:</b><p>
<b>#include</b> &lt;<a href="multi__pointoperators_8hxx-source.html">vigra/multi_pointoperators.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#ga667c0e83304fe4c7e2318a82f5043ec" title="Copy a multi-dimensional array.">copyMultiArray</a>(SrcIterator s, 
                       SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                       DestIterator d, DestAccessor dest);


        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestShape, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#ga667c0e83304fe4c7e2318a82f5043ec" title="Copy a multi-dimensional array.">copyMultiArray</a>(SrcIterator s, SrcShape <span class="keyword">const</span> &amp; sshape, SrcAccessor src,
                       DestIterator d, DestShape <span class="keyword">const</span> &amp; dshape, DestAccessor dest);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#ga667c0e83304fe4c7e2318a82f5043ec" title="Copy a multi-dimensional array.">copyMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; src,
                       pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest);
                       
                       
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestShape, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#ga667c0e83304fe4c7e2318a82f5043ec" title="Copy a multi-dimensional array.">copyMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; src,
                       triple&lt;DestIterator, DestShape, DestAccessor&gt; <span class="keyword">const</span> &amp; dest);
    }
</pre></div><p>
<b> Usage - Standard Mode:</b><p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, int&gt;</a> Array;
    Array src(Array::size_type(100, 200, 50)),
          dest(Array::size_type(100, 200, 50));
    ...
    
    <a class="code" href="group__MultiPointoperators.html#ga667c0e83304fe4c7e2318a82f5043ec" title="Copy a multi-dimensional array.">vigra::copyMultiArray</a>(srcMultiArrayRange(src), destMultiArray(dest));
</pre></div><p>
<b> Usage - Expanding Mode:</b><p>
The source array is only 2D (it has depth 1). Thus, the destination will contain 50 identical copies of this image. Note that the destination shape must be passed to the algorithm for the expansion to work, so we use <code>destMultiArrayRange()</code> rather than <code>destMultiArray()</code>.<p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, int&gt;</a> Array;
    Array src(Array::size_type(100, 200, 1)),
          dest(Array::size_type(100, 200, 50));
    ...
    
    <a class="code" href="group__MultiPointoperators.html#ga667c0e83304fe4c7e2318a82f5043ec" title="Copy a multi-dimensional array.">vigra::copyMultiArray</a>(srcMultiArrayRange(src), destMultiArrayRange(dest));
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    MultiIterator src_begin, dest_begin;
    
    SrcAccessor src_accessor;
    DestAccessor dest_accessor;

    dest_accessor.set(src_accessor(src_begin), dest_begin);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g0c8e61d112544e0ff86e6aef1746d01b"></a><!-- doxytag: member="vigra::transformMultiArray" ref="g0c8e61d112544e0ff86e6aef1746d01b" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::transformMultiArray           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transform a multi-dimensional array with a unary function or functor. 
<p>
This function can be applied in three modes:<p>
<dl>
<dt><b>Standard Mode:</b> </dt>
<dd>If the source and destination arrays have the same size, the transformation given by the functor is applied to every source element and the result written into the corresponding destination element. Unary functions, unary functors from the STL and the functors specifically defined in <a class="el" href="group__TransformFunctor.html">Functors to Transform Images</a> can be used in standard mode. Creation of new functors is easiest by using <a class="el" href="FunctorExpressions.html">Functor Expressions</a>. </dd>
<dt><b>Expanding Mode:</b> </dt>
<dd>If the source array has length 1 along some (or even all) dimensions, the source value at index 0 is used for all destination elements in those dimensions. In other words, the source index is not incremented along these dimensions, but the transformation functor is applied as usual. So, we can expand a small array (e.g. a single row of data, column length is 1), into a larger one (e.g. a 2D image with the same width): the given values are simply reused as necessary (e.g. for every row of the destination image). The same functors as in standard mode can be applied. </dd>
<dt><b>Reducing Mode:</b> </dt>
<dd>If the destination array has length 1 along some (or even all) dimensions, the source values in these dimensions are reduced to single values by means of a suitable functor (e.g. <a class="el" href="classvigra_1_1ReduceFunctor.html">vigra::ReduceFunctor</a>), which supports two function call operators: one with a single argument to collect the values, and without argument to obtain the final (reduced) result. This behavior is a multi-dimensional generalization of the C++ standard function <code>std::accumulate()</code>. </dd>
</dl>
<p>
The arrays must be represented by iterators compatible with <a class="el" href="classvigra_1_1MultiIterator.html">vigra::MultiIterator</a>, and the iteration range is specified by means of shape objects. If only the source shape is given the destination array is assumed to have the same shape, and standard mode is applied. If two shapes are given, the size of corresponding dimensions must be either equal (standard copy), or the source length must be 1 (expand mode), or the destination length must be 1 (reduce mode). However, reduction and expansion cannot be executed at the same time, so the latter conditions are mutual exclusive, even if they apply to different dimensions.<p>
The function uses accessors to access the data elements.<p>
<b> Declarations:</b><p>
<b>#include</b> &lt;<a href="multi__pointoperators_8hxx-source.html">vigra/multi_pointoperators.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, 
                  <span class="keyword">class </span>Functor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#g0c8e61d112544e0ff86e6aef1746d01b" title="Transform a multi-dimensional array with a unary function or functor.">transformMultiArray</a>(SrcIterator s, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor src,
                            DestIterator d, DestAccessor dest, Functor <span class="keyword">const</span> &amp; f);


        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestShape, <span class="keyword">class </span>DestAccessor, 
                  <span class="keyword">class </span>Functor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#g0c8e61d112544e0ff86e6aef1746d01b" title="Transform a multi-dimensional array with a unary function or functor.">transformMultiArray</a>(SrcIterator s, SrcShape <span class="keyword">const</span> &amp; sshape, SrcAccessor src,
                            DestIterator d, DestShape <span class="keyword">const</span> &amp; dshape, DestAccessor dest, 
                            Functor <span class="keyword">const</span> &amp; f);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, 
                  <span class="keyword">class </span>Functor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#g0c8e61d112544e0ff86e6aef1746d01b" title="Transform a multi-dimensional array with a unary function or functor.">transformMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; src,
                            pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest, Functor <span class="keyword">const</span> &amp; f);


        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestShape, <span class="keyword">class </span>DestAccessor, 
                  <span class="keyword">class </span>Functor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#g0c8e61d112544e0ff86e6aef1746d01b" title="Transform a multi-dimensional array with a unary function or functor.">transformMultiArray</a>(triple&lt;SrcIterator, SrcShape, SrcAccessor&gt; <span class="keyword">const</span> &amp; src,
                            triple&lt;DestIterator, DestShape, DestAccessor&gt; <span class="keyword">const</span> &amp; dest, 
                            Functor <span class="keyword">const</span> &amp; f)
    }
</pre></div><p>
<b> Usage - Standard Mode:</b><p>
Source and destination array have the same size.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;cmath&gt;</span>         <span class="comment">// for sqrt()</span>

    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, float&gt;</a> Array;
    Array src(Array::size_type(100, 200, 50)),
          dest(Array::size_type(100, 200, 50));
    ...
    
    <a class="code" href="group__MultiPointoperators.html#g0c8e61d112544e0ff86e6aef1746d01b" title="Transform a multi-dimensional array with a unary function or functor.">vigra::transformMultiArray</a>(srcMultiArrayRange(src),
                               destMultiArray(dest),
                               (<span class="keywordtype">float</span>(*)(<span class="keywordtype">float</span>))&amp;<a class="code" href="group__FixedPointOperations.html#ga498373861afd821131d42fa955ea506" title="square root.">std::sqrt</a> );
</pre></div><p>
<b> Usage - Expand Mode:</b><p>
The source array is only 2D (it has depth 1). Thus, the destination will contain 50 identical copies of the transformed source array. Note that the destination shape must be passed to the algorithm for the expansion to work, so we use <code>destMultiArrayRange()</code> rather than <code>destMultiArray()</code>.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;cmath&gt;</span>         <span class="comment">// for sqrt()</span>

    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, float&gt;</a> Array;
    Array src(Array::size_type(100, 200, 1)),
          dest(Array::size_type(100, 200, 50));
    ...
    
    <a class="code" href="group__MultiPointoperators.html#g0c8e61d112544e0ff86e6aef1746d01b" title="Transform a multi-dimensional array with a unary function or functor.">vigra::transformMultiArray</a>(srcMultiArrayRange(src),
                               destMultiArrayRange(dest),
                               (<span class="keywordtype">float</span>(*)(<span class="keywordtype">float</span>))&amp;<a class="code" href="group__FixedPointOperations.html#ga498373861afd821131d42fa955ea506" title="square root.">std::sqrt</a> );
</pre></div><p>
<b> Usage - Reduce Mode:</b><p>
The destination array is only 1D (it's width and height are 1). Thus, it will contain accumulated data for every slice of the source volume (or for every frame, if the source is intepreted as an image sequence). In the example, we use the functor <a class="el" href="classvigra_1_1FindAverage.html">vigra::FindAverage</a> to calculate the average gray value of every slice. Note that the destination shape must also be passed for the reduction to work, so we use <code>destMultiArrayRange()</code> rather than <code>destMultiArray()</code>.<p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, float&gt;</a> Array;
    Array src(Array::size_type(100, 200, 50)),
          dest(Array::size_type(1, 1, 50));
    ...
    
    <a class="code" href="group__MultiPointoperators.html#g0c8e61d112544e0ff86e6aef1746d01b" title="Transform a multi-dimensional array with a unary function or functor.">vigra::transformMultiArray</a>(srcMultiArrayRange(src),
                               destMultiArrayRange(dest),
                               <a class="code" href="classvigra_1_1FindAverage.html" title="Find the average pixel value in an image or ROI.">vigra::FindAverage&lt;float&gt;</a>() );
</pre></div><p>
<b> Required Interface:</b><p>
In standard and expand mode, the functor must be a model of UnaryFunction (i.e. support function call with one argument and a return value <code>res = functor(arg)</code>):<p>
<div class="fragment"><pre class="fragment">    MultiIterator src_begin, src_end, dest_begin;
    
    SrcAccessor src_accessor;
    DestAccessor dest_accessor;
    Functor functor;

    dest_accessor.set(functor(src_accessor(src_begin)), dest_begin);
</pre></div><p>
In reduce mode, it must be a model of UnaryAnalyser (i.e. support function call with one argument and no return vakue <code>functor(arg)</code>) and Initializer (i.e. support function call with no argument, but return value <code>res = functor()</code>). Internally, such functors are recognized by the meta functions <code>FunctorTraits&lt;FUNCTOR&gt;::isUnaryAnalyser</code> and <code>FunctorTraits&lt;FUNCTOR&gt;::isInitializer</code> which must both yield <code>VigraTrueType</code>. Make sure that your functor correctly defines <code><a class="el" href="classvigra_1_1FunctorTraits.html" title="Export associated information for a functor.">FunctorTraits</a></code> because otherwise reduce mode will not work. In addition, the functor must be copy constructible in order to start each reduction with a fresh functor.<p>
<div class="fragment"><pre class="fragment">    MultiIterator src_begin, src_end, dest_begin;
    
    SrcAccessor src_accessor;
    DestAccessor dest_accessor;
    
    FUNCTOR initial_functor, functor(initial_functor);
    assert(<span class="keyword">typeid</span>(FunctorTraits&lt;FUNCTOR&gt;::isInitializer) == <span class="keyword">typeid</span>(VigraTrueType));
    assert(<span class="keyword">typeid</span>(FunctorTraits&lt;FUNCTOR&gt;::isUnaryAnalyser) == <span class="keyword">typeid</span>(VigraTrueType));
    
    functor(src_accessor(src_begin));
    dest_accessor.set(functor(), dest_begin);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g745d0821dafde88ef23ef315cc7fcb73"></a><!-- doxytag: member="vigra::combineTwoMultiArrays" ref="g745d0821dafde88ef23ef315cc7fcb73" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::combineTwoMultiArrays           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Combine two multi-dimensional arrays into one using a binary function or functor. 
<p>
This function can be applied in three modes:<p>
<dl>
<dt><b>Standard Mode:</b> </dt>
<dd>If the source and destination arrays have the same size, the transformation given by the functor is applied to every pair of corresponding source elements and the result written into the corresponding destination element. Binary functions, binary functors from the STL and the functors specifically defined in <a class="el" href="group__CombineFunctor.html">Functors to Combine Images</a> can be used in standard mode. Creation of new functors is easiest by using <a class="el" href="FunctorExpressions.html">Functor Expressions</a>. </dd>
<dt><b>Expanding Mode:</b> </dt>
<dd>If the source arrays have length 1 along some (or even all) dimensions, the source values at index 0 are used for all destination elements in those dimensions. In other words, the source index is not incremented along those dimensions, but the transformation functor is applied as usual. So, we can expand small arrays (e.g. a single row of data, column length is 1), into larger ones (e.g. a 2D image with the same width): the given values are simply reused as necessary (e.g. for every row of the destination image). It is not even necessary that the source array shapes are equal. For example, we can combine a small array with one that hase the same size as the destination array. The same functors as in standard mode can be applied. </dd>
<dt><b>Reducing Mode:</b> </dt>
<dd>If the destination array has length 1 along some (or even all) dimensions, the source values in these dimensions are reduced to single values by means of a suitable functor which supports two function call operators: one with two arguments to collect the values, and one without argument to obtain the final (reduced) result. This behavior is a multi-dimensional generalization of the C++ standard function <code>std::accumulate()</code>. </dd>
</dl>
<p>
The arrays must be represented by iterators compatible with <a class="el" href="classvigra_1_1MultiIterator.html">vigra::MultiIterator</a>, and the iteration range is specified by means of shape objects. If only a single source shape is given the destination array is assumed to have the same shape, and standard mode is applied. If three shapes are given, the size of corresponding dimensions must be either equal (standard copy), or the length of this dimension must be 1 in one or both source arrays (expand mode), or the destination length must be 1 (reduce mode). However, reduction and expansion cannot be executed at the same time, so the latter conditions are mutual exclusive, even if they apply to different dimensions.<p>
The function uses accessors to access the data elements.<p>
<b> Declarations:</b><p>
<b>#include</b> &lt;<a href="multi__pointoperators_8hxx-source.html">vigra/multi_pointoperators.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator1, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor1,
                  <span class="keyword">class </span>SrcIterator2, <span class="keyword">class </span>SrcAccessor2,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, 
                  <span class="keyword">class </span>Functor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__MultiPointoperators.html#g745d0821dafde88ef23ef315cc7fcb73" title="Combine two multi-dimensional arrays into one using a binary function or functor...">combineTwoMultiArrays</a>(
                       SrcIterator1 s1, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor1 src1,
                       SrcIterator2 s2, SrcAccessor2 src2,
                       DestIterator d, DestAccessor dest, Functor <span class="keyword">const</span> &amp; f);


        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator1, <span class="keyword">class </span>SrcShape1, <span class="keyword">class </span>SrcAccessor1,
                  <span class="keyword">class </span>SrcIterator2, <span class="keyword">class </span>SrcShape2, <span class="keyword">class </span>SrcAccessor2,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestShape, <span class="keyword">class </span>DestAccessor, 
                  <span class="keyword">class </span>Functor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__MultiPointoperators.html#g745d0821dafde88ef23ef315cc7fcb73" title="Combine two multi-dimensional arrays into one using a binary function or functor...">combineTwoMultiArrays</a>(
                       SrcIterator1 s1, SrcShape1 <span class="keyword">const</span> &amp; sshape1, SrcAccessor1 src1,
                       SrcIterator2 s2, SrcShape2 <span class="keyword">const</span> &amp; sshape2, SrcAccessor2 src2,
                       DestIterator d, DestShape <span class="keyword">const</span> &amp; dshape, DestAccessor dest, 
                       Functor <span class="keyword">const</span> &amp; f);
            }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator1, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor1,
                  <span class="keyword">class </span>SrcIterator2, <span class="keyword">class </span>SrcAccessor2,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, <span class="keyword">class </span>Functor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__MultiPointoperators.html#g745d0821dafde88ef23ef315cc7fcb73" title="Combine two multi-dimensional arrays into one using a binary function or functor...">combineTwoMultiArrays</a>(
                       triple&lt;SrcIterator1, SrcShape, SrcAccessor1&gt; <span class="keyword">const</span> &amp; src1,
                       pair&lt;SrcIterator2, SrcAccessor2&gt; <span class="keyword">const</span> &amp; src2,
                       pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest, Functor <span class="keyword">const</span> &amp; f);


        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator1, <span class="keyword">class </span>SrcShape1, <span class="keyword">class </span>SrcAccessor1,
                  <span class="keyword">class </span>SrcIterator2, <span class="keyword">class </span>SrcShape2, <span class="keyword">class </span>SrcAccessor2,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestShape, <span class="keyword">class </span>DestAccessor, 
                  <span class="keyword">class </span>Functor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__MultiPointoperators.html#g745d0821dafde88ef23ef315cc7fcb73" title="Combine two multi-dimensional arrays into one using a binary function or functor...">combineTwoMultiArrays</a>(
                       triple&lt;SrcIterator1, SrcShape1, SrcAccessor1&gt; <span class="keyword">const</span> &amp; src1,
                       triple&lt;SrcIterator2, SrcShape2, SrcAccessor2&gt; <span class="keyword">const</span> &amp; src2,
                       triple&lt;DestIterator, DestShape, DestAccessor&gt; <span class="keyword">const</span> &amp; dest, 
                       Functor <span class="keyword">const</span> &amp; f);
    }
</pre></div><p>
<b> Usage - Standard Mode:</b><p>
Source and destination arrays have the same size.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;functional&gt;</span>     <span class="comment">// for std::plus</span>

    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, int&gt;</a> Array;
    Array src1(Array::size_type(100, 200, 50)),
          src2(Array::size_type(100, 200, 50)),
          dest(Array::size_type(100, 200, 50));
    ...
    
    <a class="code" href="group__MultiPointoperators.html#g745d0821dafde88ef23ef315cc7fcb73" title="Combine two multi-dimensional arrays into one using a binary function or functor...">vigra::combineTwoMultiArrays</a>(
                srcMultiArrayRange(src1), 
                srcMultiArray(src2), 
                destMultiArray(dest),  
                std::plus&lt;int&gt;());
</pre></div><p>
<b> Usage - Expand Mode:</b><p>
One source array is only 2D (it has depth 1). This image will be added to every slice of the other source array, and the result if written into the corresponding destination slice. Note that the shapes of all arrays must be passed to the algorithm, so we use <code>srcMultiArrayRange()</code> and <code>destMultiArrayRange()</code> rather than <code>srcMultiArray()</code> and <code>destMultiArray()</code>.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;functional&gt;</span>     <span class="comment">// for std::plus</span>

    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, int&gt;</a> Array;
    Array src1(Array::size_type(100, 200, 1)),
          src2(Array::size_type(100, 200, 50)),
          dest(Array::size_type(100, 200, 50));
    ...
    
    <a class="code" href="group__MultiPointoperators.html#g745d0821dafde88ef23ef315cc7fcb73" title="Combine two multi-dimensional arrays into one using a binary function or functor...">vigra::combineTwoMultiArrays</a>(
                srcMultiArrayRange(src1), 
                srcMultiArray(src2), 
                destMultiArray(dest),  
                std::plus&lt;int&gt;());
</pre></div><p>
<b> Usage - Reduce Mode:</b><p>
The destination array is only 1D (it's width and height are 1). Thus, it will contain accumulated data for every slice of the source volumes (or for every frame, if the sources are intepreted as image sequences). In the example, we use <a class="el" href="classvigra_1_1ReduceFunctor.html">vigra::ReduceFunctor</a> together with a functor expression (see <a class="el" href="FunctorExpressions.html">Functor Expressions</a>) to calculate the total absolute difference of the gray values in every pair of source slices. Note that the shapes of all arrays must be passed to the algorithm in order for the reduction to work, so we use <code>srcMultiArrayRange()</code> and <code>destMultiArrayRange()</code> rather than <code>srcMultiArray()</code> and <code>destMultiArray()</code>.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;vigra/functorexpression.hxx&gt;</span>
    <span class="keyword">using namespace </span>vigra::functor;
        
    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, int&gt;</a> Array;
    Array src1(Array::size_type(100, 200, 50)),
          src2(Array::size_type(100, 200, 50)),
          dest(Array::size_type(1, 1, 50));
    ...
    
    <a class="code" href="group__MultiPointoperators.html#g745d0821dafde88ef23ef315cc7fcb73" title="Combine two multi-dimensional arrays into one using a binary function or functor...">vigra::combineTwoMultiArrays</a>(
                srcMultiArrayRange(src1), 
                srcMultiArray(src2), 
                destMultiArray(dest),  
                reduceFunctor(Arg1() + <a class="code" href="group__FFTWComplexOperators.html#gc34074503e9381d098bb108e7c1ed0e6" title="absolute value (= magnitude)">abs</a>(Arg2() - Arg3()), 0) );
                <span class="comment">// Arg1() is the sum accumulated so far, initialzed with 0</span>
</pre></div><p>
<b> Required Interface:</b><p>
In standard and expand mode, the functor must be a model of BinaryFunction (i.e. support function call with two arguments and a return value <code>res = functor(arg1, arg2)</code>):<p>
<div class="fragment"><pre class="fragment">    MultiIterator src1_begin, src2_begin, dest_begin;
    
    SrcAccessor1 src1_accessor;
    SrcAccessor2 src2_accessor;
    DestAccessor dest_accessor;
    
    Functor functor;

    dest_accessor.set(
          functor(src1_accessor(src1_begin), src2_accessor(src2_begin)), 
          dest_begin);
</pre></div><p>
In reduce mode, it must be a model of BinaryAnalyser (i.e. support function call with two arguments and no return vakue <code>functor(arg1, arg2)</code>) and Initializer (i.e. support function call with no argument, but return value <code>res = functor()</code>). Internally, such functors are recognized by the meta functions <code>FunctorTraits&lt;FUNCTOR&gt;::isBinaryAnalyser</code> and <code>FunctorTraits&lt;FUNCTOR&gt;::isInitializer</code> which must both yield <code>VigraTrueType</code>. Make sure that your functor correctly defines <code><a class="el" href="classvigra_1_1FunctorTraits.html" title="Export associated information for a functor.">FunctorTraits</a></code> because otherwise reduce mode will not work. In addition, the functor must be copy constructible in order to start each reduction with a fresh functor.<p>
<div class="fragment"><pre class="fragment">    MultiIterator src1_begin, src2_begin, dest_begin;
    
    SrcAccessor1 src1_accessor;
    SrcAccessor2 src2_accessor;
    DestAccessor dest_accessor;
    
    FUNCTOR initial_functor, functor(initial_functor);
    assert(<span class="keyword">typeid</span>(FunctorTraits&lt;FUNCTOR&gt;::isInitializer) == <span class="keyword">typeid</span>(VigraTrueType));
    assert(<span class="keyword">typeid</span>(FunctorTraits&lt;FUNCTOR&gt;::isBinaryAnalyser) == <span class="keyword">typeid</span>(VigraTrueType));
    
    functor(src1_accessor(src1_begin), src2_accessor(src2_begin));
    dest_accessor.set(functor(), dest_begin);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g47334a2ed2e40de1f60606f06a1b7d9a"></a><!-- doxytag: member="vigra::combineThreeMultiArrays" ref="g47334a2ed2e40de1f60606f06a1b7d9a" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::combineThreeMultiArrays           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Combine three multi-dimensional arrays into one using a ternary function or functor. 
<p>
Except for the fact that it operates on three input arrays, this function is identical to <a class="el" href="group__MultiPointoperators.html#g745d0821dafde88ef23ef315cc7fcb73">combineTwoMultiArrays()</a>.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator1, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor1,
                  <span class="keyword">class </span>SrcIterator2, <span class="keyword">class </span>SrcAccessor2,
                  <span class="keyword">class </span>SrcIterator3, <span class="keyword">class </span>SrcAccessor3,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, 
                  <span class="keyword">class </span>Functor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#g47334a2ed2e40de1f60606f06a1b7d9a" title="Combine three multi-dimensional arrays into one using a ternary function or functor...">combineThreeMultiArrays</a>(SrcIterator1 s1, SrcShape <span class="keyword">const</span> &amp; shape, SrcAccessor1 src1,
                       SrcIterator2 s2, SrcAccessor2 src2,
                       SrcIterator3 s3, SrcAccessor3 src3,
                       DestIterator d, DestAccessor dest, Functor <span class="keyword">const</span> &amp; f);
                    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator1, <span class="keyword">class </span>SrcShape, <span class="keyword">class </span>SrcAccessor1,
                  <span class="keyword">class </span>SrcIterator2, <span class="keyword">class </span>SrcAccessor2,
                  <span class="keyword">class </span>SrcIterator3, <span class="keyword">class </span>SrcAccessor3,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor, 
                  <span class="keyword">class </span>Functor&gt;
        <span class="keyword">inline</span> <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#g47334a2ed2e40de1f60606f06a1b7d9a" title="Combine three multi-dimensional arrays into one using a ternary function or functor...">combineThreeMultiArrays</a>(triple&lt;SrcIterator1, SrcShape, SrcAccessor1&gt; <span class="keyword">const</span> &amp; src1,
                       pair&lt;SrcIterator2, SrcAccessor2&gt; <span class="keyword">const</span> &amp; src2,
                       pair&lt;SrcIterator3, SrcAccessor3&gt; <span class="keyword">const</span> &amp; src3,
                       pair&lt;DestIterator, DestAccessor&gt; <span class="keyword">const</span> &amp; dest, Functor <span class="keyword">const</span> &amp; f);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="multi__pointoperators_8hxx-source.html">vigra/multi_pointoperators.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;functional&gt;</span>     <span class="comment">// for plus</span>

    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, int&gt;</a> Array;
    Array src1(Array::size_type(100, 200, 50)),
          src2(Array::size_type(100, 200, 50)),
          src3(Array::size_type(100, 200, 50)),
          dest(Array::size_type(100, 200, 50));
    ...
    
    <a class="code" href="group__MultiPointoperators.html#g47334a2ed2e40de1f60606f06a1b7d9a" title="Combine three multi-dimensional arrays into one using a ternary function or functor...">vigra::combineThreeMultiArrays</a>(
                srcMultiArrayRange(src1), 
                srcMultiArray(src2), 
                srcMultiArray(src3), 
                destMultiArray(dest),  
                SomeThreeArgumentFunctor());
</pre></div> 
</div>
</div><p>
<a class="anchor" name="gc17818407ac325c4c2510848a85dc6b5"></a><!-- doxytag: member="vigra::inspectMultiArray" ref="gc17818407ac325c4c2510848a85dc6b5" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::inspectMultiArray           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call an analyzing functor at every element of a multi-dimensional array. 
<p>
This function can be used to collect statistics of the array etc. The results must be stored in the functor, which serves as a return value. The arrays must be represented by iterators compatible with <a class="el" href="classvigra_1_1MultiIterator.html">vigra::MultiIterator</a>. The function uses an accessor to access the pixel data. Note that the iterator range must be specified by a shape object, because otherwise we could not control the range simultaneously in all dimensions (this is a necessary consequence of the <a class="el" href="classvigra_1_1MultiIterator.html">vigra::MultiIterator</a> design).<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> Shape, <span class="keyword">class</span> Accessor, <span class="keyword">class</span> Functor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#gc17818407ac325c4c2510848a85dc6b5" title="Call an analyzing functor at every element of a multi-dimensional array.">inspectMultiArray</a>(Iterator s, Shape <span class="keyword">const</span> &amp; shape, Accessor a,  Functor &amp; f);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> Shape, <span class="keyword">class</span> Accessor, <span class="keyword">class</span> Functor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#gc17818407ac325c4c2510848a85dc6b5" title="Call an analyzing functor at every element of a multi-dimensional array.">inspectMultiArray</a>(triple&lt;Iterator, Shape, Accessor&gt; <span class="keyword">const</span> &amp; s, Functor &amp; f);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="multi__pointoperators_8hxx-source.html">vigra/multi_pointoperators.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, int&gt;</a> Array;
    Array array(Array::size_type(100, 200, 50));

    <span class="comment">// init functor</span>
    <a class="code" href="classvigra_1_1FindMinMax.html" title="Find the minimum and maximum pixel value in an image or ROI.">vigra::FindMinMax&lt;int&gt;</a> minmax;

    <a class="code" href="group__MultiPointoperators.html#gc17818407ac325c4c2510848a85dc6b5" title="Call an analyzing functor at every element of a multi-dimensional array.">vigra::inspectMultiArray</a>(srcMultiArrayRange(array), minmax);

    cout &lt;&lt; <span class="stringliteral">"Min: "</span> &lt;&lt; minmax.<a class="code" href="classvigra_1_1FindMinMax.html#0ae3408e83fa258f08ece61e194251a9">min</a> &lt;&lt; <span class="stringliteral">" Max: "</span> &lt;&lt; minmax.<a class="code" href="classvigra_1_1FindMinMax.html#7a6d5ee26475974260562366c1a71b01">max</a>;
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    MultiIterator src_begin;

    Accessor accessor;
    Functor functor;

    functor(accessor(src_begin)); 
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g673cdf358ac025137c460beb257ee3fa"></a><!-- doxytag: member="vigra::inspectTwoMultiArrays" ref="g673cdf358ac025137c460beb257ee3fa" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::inspectTwoMultiArrays           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call an analyzing functor at all corresponding elements of two multi-dimensional arrays. 
<p>
This function can be used to collect statistics of the array etc. The results must be stored in the functor, which serves as a return value. The arrays must be represented by iterators compatible with <a class="el" href="classvigra_1_1MultiIterator.html">vigra::MultiIterator</a>. The function uses an accessor to access the pixel data. Note that the iterator range must be specified by a shape object, because otherwise we could not control the range simultaneously in all dimensions (this is a necessary consequence of the <a class="el" href="classvigra_1_1MultiIterator.html">vigra::MultiIterator</a> design).<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>Iterator1, <span class="keyword">class </span>Shape, <span class="keyword">class </span>Accessor1, 
                  <span class="keyword">class </span>Iterator2, <span class="keyword">class </span>Accessor2, 
                  <span class="keyword">class </span>Functor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#g673cdf358ac025137c460beb257ee3fa" title="Call an analyzing functor at all corresponding elements of two multi-dimensional...">inspectTwoMultiArrays</a>(Iterator1 s1, Shape <span class="keyword">const</span> &amp; shape, Accessor1 a1,
                              Iterator2 s2, Accessor2 a2, Functor &amp; f);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>Iterator1, <span class="keyword">class </span>Shape1, <span class="keyword">class </span>Accessor1, 
                  <span class="keyword">class </span>Iterator2, <span class="keyword">class </span>Accessor2, 
                  <span class="keyword">class </span>Functor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__MultiPointoperators.html#g673cdf358ac025137c460beb257ee3fa" title="Call an analyzing functor at all corresponding elements of two multi-dimensional...">inspectTwoMultiArrays</a>(triple&lt;Iterator1, Shape1, Accessor1&gt; <span class="keyword">const</span> &amp; s1, 
                              pair&lt;Iterator2, Accessor2&gt; <span class="keyword">const</span> &amp; s2, Functor &amp; f);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="multi__pointoperators_8hxx-source.html">vigra/multi_pointoperators.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, int&gt;</a> Array;
    Array array1(Array::size_type(100, 200, 50)),
          array2(Array::size_type(100, 200, 50));

    <span class="comment">// init functor</span>
    SomeStatisticsFunctor stats(..);

    <a class="code" href="group__MultiPointoperators.html#g673cdf358ac025137c460beb257ee3fa" title="Call an analyzing functor at all corresponding elements of two multi-dimensional...">vigra::inspectTwoMultiArrays</a>(srcMultiArrayRange(array1), srcMultiArray(array2), stats);
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    MultiIterator src1_begin, src2_begin;

    Accessor a1, a2;
    Functor functor;

    functor(a1(src1_begin), a2(src2_begin)); 
</pre></div> 
</div>
</div><p>
</div>
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
VIGRA 1.6.0 (13 Aug 2008)
</i>
</tr>
</table>


</BODY>
</HTML>
