<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>VIGRA - VIGRA: Geometric Transformations</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Geometric Transformations
</td>
<td align=right><a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif"></a></td></tr>
</table><p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#g769f3e9b8a983232f7adc5031f393629">affineWarpImage</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Warp an image according to an affine transformation.  <a href="#g769f3e9b8a983232f7adc5031f393629"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#g39250b79a46084cfd41309921efa0ccb">reflectImage</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reflect image horizontally or vertically.  <a href="#g39250b79a46084cfd41309921efa0ccb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#g68e08f25b220b037fd59313fde70ffc9">resampleImage</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resample image by a given factor.  <a href="#g68e08f25b220b037fd59313fde70ffc9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#g4fe762871977ae7f4b29fc78ea411edc">resizeImageCatmullRomInterpolation</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize image using the Catmull/Rom interpolation function.  <a href="#g4fe762871977ae7f4b29fc78ea411edc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#gb4955d622ab2f110a7e5c72d0d27b59a">resizeImageCoscotInterpolation</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize image using the Coscot interpolation function.  <a href="#gb4955d622ab2f110a7e5c72d0d27b59a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#gdc90ce771db3f4b57fe6d3135592f74c">resizeImageLinearInterpolation</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize image using linear interpolation.  <a href="#gdc90ce771db3f4b57fe6d3135592f74c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#g8db7c21dc1a3b3f5a7b4e8619345626b">resizeImageNoInterpolation</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize image by repeating the nearest pixel values.  <a href="#g8db7c21dc1a3b3f5a7b4e8619345626b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#g02f1c9007ec9b0395accc6b02ea37284">resizeImageSplineInterpolation</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize image using B-spline interpolation.  <a href="#g02f1c9007ec9b0395accc6b02ea37284"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#gd77190b060bafe5791f7926502f147ec">resizeMultiArraySplineInterpolation</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize <a class="el" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">MultiArray</a> using B-spline interpolation.  <a href="#gd77190b060bafe5791f7926502f147ec"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#g06ddb213ebcfcd09923b36aff144e954">rotateImage</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate image by an arbitrary angle.  <a href="#g06ddb213ebcfcd09923b36aff144e954"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#gc5db2aa94b116d3cc1b67b96e4ac96b5">rotationMatrix2DDegrees</a> (double angle, TinyVector&lt; double, 2 &gt; const &amp;center)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create homogeneous matrix representing a 2D rotation about the given point.  <a href="#gc5db2aa94b116d3cc1b67b96e4ac96b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#gcc7041b192dfb4a79de8d168abd495c9">rotationMatrix2DDegrees</a> (double angle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create homogeneous matrix representing a 2D rotation about the coordinate origin.  <a href="#gcc7041b192dfb4a79de8d168abd495c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#gfdb14c737ca2c1587eeb2ac7d040542e">rotationMatrix2DRadians</a> (double angle, TinyVector&lt; double, 2 &gt; const &amp;center)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create homogeneous matrix representing a 2D rotation about the given point.  <a href="#gfdb14c737ca2c1587eeb2ac7d040542e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#g814c2b60d8b8579e159e939a76cd6db3">rotationMatrix2DRadians</a> (double angle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create homogeneous matrix representing a 2D rotation about the coordinate origin.  <a href="#g814c2b60d8b8579e159e939a76cd6db3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#g0ed2998d9b3c103c07d005ca15a84316">scalingMatrix2D</a> (double sx, double sy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create homogeneous matrix representing a 2D non-uniform scaling about the coordinate origin.  <a href="#g0ed2998d9b3c103c07d005ca15a84316"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#g41cb093e4faa9a00db19571790530b86">scalingMatrix2D</a> (double scalingFactor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create homogeneous matrix representing a 2D uniform scaling about the coordinate origin.  <a href="#g41cb093e4faa9a00db19571790530b86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#g42a408803035022f33ce0dae2cff5e81">shearMatrix2D</a> (double s01, double s10)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create homogeneous matrix representing a 2D shearing.  <a href="#g42a408803035022f33ce0dae2cff5e81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">linalg::TemporaryMatrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#g18dd969f7e355a60a1ade6517944457d">translationMatrix2D</a> (TinyVector&lt; double, 2 &gt; const &amp;shift)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create homogeneous matrix representing a 2D translation.  <a href="#g18dd969f7e355a60a1ade6517944457d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GeometricTransformations.html#g831ea7f68193828d8fadd7f97539e97c">transposeImage</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transpose an image over the major or minor diagonal.  <a href="#g831ea7f68193828d8fadd7f97539e97c"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2 class="details_section">Detailed Description</h2>
Zoom up and down by repeating pixels, or using various interpolation schemes.<p>
See also: <a class="el" href="group__ResamplingConvolutionFilters.html#g4a52df2a11c33ca42fa74664678177c8">resamplingConvolveImage()</a>, <a class="el" href="group__GeometricTransformations.html#g68e08f25b220b037fd59313fde70ffc9">resampleImage()</a>, <a class="el" href="group__GeometricTransformations.html#gd77190b060bafe5791f7926502f147ec">resizeMultiArraySplineInterpolation()</a><p>
<b>#include</b> &lt;<a href="stdimagefunctions_8hxx-source.html">vigra/stdimagefunctions.hxx</a>&gt;<br>
 <b>or</b><br>
 <b>#include</b> &lt;<a href="resizeimage_8hxx-source.html">vigra/resizeimage.hxx</a>&gt;<br>
 <hr><h2>Function Documentation</h2>
<a class="anchor" name="g18dd969f7e355a60a1ade6517944457d"></a><!-- doxytag: member="vigra::translationMatrix2D" ref="g18dd969f7e355a60a1ade6517944457d" args="(TinyVector&lt; double, 2 &gt; const &amp;shift)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">linalg::TemporaryMatrix&lt;double&gt; vigra::translationMatrix2D           </td>
          <td>(</td>
          <td class="paramtype">TinyVector&lt; double, 2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>shift</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create homogeneous matrix representing a 2D translation. 
<p>
For use with <a class="el" href="group__GeometricTransformations.html#g769f3e9b8a983232f7adc5031f393629">affineWarpImage()</a>. 
</div>
</div><p>
<a class="anchor" name="g41cb093e4faa9a00db19571790530b86"></a><!-- doxytag: member="vigra::scalingMatrix2D" ref="g41cb093e4faa9a00db19571790530b86" args="(double scalingFactor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">linalg::TemporaryMatrix&lt;double&gt; vigra::scalingMatrix2D           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>scalingFactor</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create homogeneous matrix representing a 2D uniform scaling about the coordinate origin. 
<p>
For use with <a class="el" href="group__GeometricTransformations.html#g769f3e9b8a983232f7adc5031f393629">affineWarpImage()</a>. 
</div>
</div><p>
<a class="anchor" name="g0ed2998d9b3c103c07d005ca15a84316"></a><!-- doxytag: member="vigra::scalingMatrix2D" ref="g0ed2998d9b3c103c07d005ca15a84316" args="(double sx, double sy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">linalg::TemporaryMatrix&lt;double&gt; vigra::scalingMatrix2D           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>sy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create homogeneous matrix representing a 2D non-uniform scaling about the coordinate origin. 
<p>
For use with <a class="el" href="group__GeometricTransformations.html#g769f3e9b8a983232f7adc5031f393629">affineWarpImage()</a>. 
</div>
</div><p>
<a class="anchor" name="g42a408803035022f33ce0dae2cff5e81"></a><!-- doxytag: member="vigra::shearMatrix2D" ref="g42a408803035022f33ce0dae2cff5e81" args="(double s01, double s10)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">linalg::TemporaryMatrix&lt;double&gt; vigra::shearMatrix2D           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>s10</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create homogeneous matrix representing a 2D shearing. 
<p>
For use with <a class="el" href="group__GeometricTransformations.html#g769f3e9b8a983232f7adc5031f393629">affineWarpImage()</a>. 
</div>
</div><p>
<a class="anchor" name="g814c2b60d8b8579e159e939a76cd6db3"></a><!-- doxytag: member="vigra::rotationMatrix2DRadians" ref="g814c2b60d8b8579e159e939a76cd6db3" args="(double angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">linalg::TemporaryMatrix&lt;double&gt; vigra::rotationMatrix2DRadians           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>angle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create homogeneous matrix representing a 2D rotation about the coordinate origin. 
<p>
For use with <a class="el" href="group__GeometricTransformations.html#g769f3e9b8a983232f7adc5031f393629">affineWarpImage()</a>. Angle must be in radians. 
</div>
</div><p>
<a class="anchor" name="gcc7041b192dfb4a79de8d168abd495c9"></a><!-- doxytag: member="vigra::rotationMatrix2DDegrees" ref="gcc7041b192dfb4a79de8d168abd495c9" args="(double angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">linalg::TemporaryMatrix&lt;double&gt; vigra::rotationMatrix2DDegrees           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>angle</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create homogeneous matrix representing a 2D rotation about the coordinate origin. 
<p>
For use with <a class="el" href="group__GeometricTransformations.html#g769f3e9b8a983232f7adc5031f393629">affineWarpImage()</a>. Angle must be in degrees. 
</div>
</div><p>
<a class="anchor" name="gfdb14c737ca2c1587eeb2ac7d040542e"></a><!-- doxytag: member="vigra::rotationMatrix2DRadians" ref="gfdb14c737ca2c1587eeb2ac7d040542e" args="(double angle, TinyVector&lt; double, 2 &gt; const &amp;center)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">linalg::TemporaryMatrix&lt;double&gt; vigra::rotationMatrix2DRadians           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TinyVector&lt; double, 2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create homogeneous matrix representing a 2D rotation about the given point. 
<p>
For use with <a class="el" href="group__GeometricTransformations.html#g769f3e9b8a983232f7adc5031f393629">affineWarpImage()</a>. Angle must be in radians. 
</div>
</div><p>
<a class="anchor" name="gc5db2aa94b116d3cc1b67b96e4ac96b5"></a><!-- doxytag: member="vigra::rotationMatrix2DDegrees" ref="gc5db2aa94b116d3cc1b67b96e4ac96b5" args="(double angle, TinyVector&lt; double, 2 &gt; const &amp;center)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">linalg::TemporaryMatrix&lt;double&gt; vigra::rotationMatrix2DDegrees           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TinyVector&lt; double, 2 &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>center</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create homogeneous matrix representing a 2D rotation about the given point. 
<p>
For use with <a class="el" href="group__GeometricTransformations.html#g769f3e9b8a983232f7adc5031f393629">affineWarpImage()</a>. Angle must be in degrees. 
</div>
</div><p>
<a class="anchor" name="g06ddb213ebcfcd09923b36aff144e954"></a><!-- doxytag: member="vigra::rotateImage" ref="g06ddb213ebcfcd09923b36aff144e954" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void rotateImage           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotate image by an arbitrary angle. 
<p>
Rotate image by a multiple of 90 degrees.<p>
The algorithm performs a rotation about the given center point (the image center by default) using the given <a class="el" href="classvigra_1_1SplineImageView.html" title="Create a continuous view onto a discrete image using splines.">SplineImageView</a> for interpolation. The destination image must have the same size as the source <a class="el" href="classvigra_1_1SplineImageView.html" title="Create a continuous view onto a discrete image using splines.">SplineImageView</a>. The rotation is counter-clockwise, and the angle must be given in degrees.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="comment">// rotate about given center point</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> ORDER, <span class="keyword">class </span>T, 
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__GeometricTransformations.html#g06ddb213ebcfcd09923b36aff144e954" title="Rotate image by an arbitrary angle.">rotateImage</a>(SplineImageView&lt;ORDER, T&gt; <span class="keyword">const</span> &amp; src,
                         DestIterator <span class="keywordtype">id</span>, DestAccessor dest, 
                         <span class="keywordtype">double</span> angleInDegree, TinyVector&lt;double, 2&gt; <span class="keyword">const</span> &amp; center);
                         
        <span class="comment">// rotate about image center</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> ORDER, <span class="keyword">class </span>T, 
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> 
        <a class="code" href="group__GeometricTransformations.html#g06ddb213ebcfcd09923b36aff144e954" title="Rotate image by an arbitrary angle.">rotateImage</a>(SplineImageView&lt;ORDER, T&gt; <span class="keyword">const</span> &amp; src,
                    DestIterator <span class="keywordtype">id</span>, DestAccessor dest, 
                    <span class="keywordtype">double</span> angleInDegree)
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="comment">// rotate about given center point</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> ORDER, <span class="keyword">class </span>T, 
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> 
        <a class="code" href="group__GeometricTransformations.html#g06ddb213ebcfcd09923b36aff144e954" title="Rotate image by an arbitrary angle.">rotateImage</a>(SplineImageView&lt;ORDER, T&gt; <span class="keyword">const</span> &amp; src,
                    pair&lt;DestImageIterator, DestAccessor&gt; dest, 
                    <span class="keywordtype">double</span> angleInDegree, TinyVector&lt;double, 2&gt; <span class="keyword">const</span> &amp; center);

        <span class="comment">// rotate about image center</span>
        <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> ORDER, <span class="keyword">class </span>T, 
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> 
        <a class="code" href="group__GeometricTransformations.html#g06ddb213ebcfcd09923b36aff144e954" title="Rotate image by an arbitrary angle.">rotateImage</a>(SplineImageView&lt;ORDER, T&gt; <span class="keyword">const</span> &amp; src,
                    pair&lt;DestImageIterator, DestAccessor&gt; dest, 
                    <span class="keywordtype">double</span> angleInDegree);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="affinegeometry_8hxx-source.html">vigra/affinegeometry.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    Image src(width, height);
    <a class="code" href="classvigra_1_1SplineImageView.html" title="Create a continuous view onto a discrete image using splines.">vigra::SplineImageView&lt;3, Image::value_type&gt;</a> spline(srcImageRange(src));
    
    Image dest(width, height);
    
    <a class="code" href="group__GeometricTransformations.html#g06ddb213ebcfcd09923b36aff144e954" title="Rotate image by an arbitrary angle.">vigra::rotateImage</a>(spline, destImage(dest), 38.5);
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    DestImageIterator dest_upperleft;
    
    <span class="keywordtype">double</span> x = ..., y = ...;
    
    <span class="keywordflow">if</span> (spline.isInside(x,y))
        dest_accessor.set(spline(x, y), dest_upperleft);
</pre></div><p>
This algorithm just copies the pixels in the appropriate new order. It expects the destination image to have the correct shape for the desired rotation.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> 
        <a class="code" href="group__GeometricTransformations.html#g06ddb213ebcfcd09923b36aff144e954" title="Rotate image by an arbitrary angle.">rotateImage</a>(SrcIterator is, SrcIterator end, SrcAccessor as,
                    DestIterator <span class="keywordtype">id</span>, DestAccessor ad, <span class="keywordtype">int</span> rotation);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
              <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keyword">inline</span> <span class="keywordtype">void</span> 
        <a class="code" href="group__GeometricTransformations.html#g06ddb213ebcfcd09923b36aff144e954" title="Rotate image by an arbitrary angle.">rotateImage</a>(triple&lt;SrcImageIterator, SrcImageIterator, SrcAccessor&gt; src,
                    pair&lt;DestImageIterator, DestAccessor&gt; dest, <span class="keywordtype">int</span> rotation);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="basicgeometry_8hxx-source.html">vigra/basicgeometry.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    Image dest(src.height(), src.width()); <span class="comment">// note that width and height are exchanged</span>
    
    <a class="code" href="group__GeometricTransformations.html#g06ddb213ebcfcd09923b36aff144e954" title="Rotate image by an arbitrary angle.">vigra::rotateImage</a>(srcImageRange(src), destImage(dest), 90);
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcImageIterator src_upperleft, src_lowerright;
    DestImageIterator dest_upperleft;
    
    SrcAccessor src_accessor;
    
    dest_accessor.set(src_accessor(src_upperleft), dest_upperleft);
</pre></div><p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">    src_lowerright.x - src_upperleft.x &gt; 1
    src_lowerright.y - src_upperleft.y &gt; 1
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g769f3e9b8a983232f7adc5031f393629"></a><!-- doxytag: member="vigra::affineWarpImage" ref="g769f3e9b8a983232f7adc5031f393629" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::affineWarpImage           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Warp an image according to an affine transformation. 
<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> ORDER, <span class="keyword">class </span>T, 
                <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                <span class="keyword">class </span>C&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__GeometricTransformations.html#g769f3e9b8a983232f7adc5031f393629" title="Warp an image according to an affine transformation.">affineWarpImage</a>(SplineImageView&lt;ORDER, T&gt; <span class="keyword">const</span> &amp; src,
                            DestIterator dul, DestIterator dlr, DestAccessor dest, 
                            MultiArrayView&lt;2, double, C&gt; <span class="keyword">const</span> &amp; affineMatrix);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> ORDER, <span class="keyword">class </span>T, 
                <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                <span class="keyword">class </span>C&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__GeometricTransformations.html#g769f3e9b8a983232f7adc5031f393629" title="Warp an image according to an affine transformation.">affineWarpImage</a>(SplineImageView&lt;ORDER, T&gt; <span class="keyword">const</span> &amp; src,
                            triple&lt;DestIterator, DestIterator, DestAccessor&gt; dest, 
                            MultiArrayView&lt;2, double, C&gt; <span class="keyword">const</span> &amp; affineMatrix);
    }
</pre></div><p>
The algorithm applies the given <em>affineMatrix</em> to the <em>destination coordinates</em> and copies the image value from the resulting source coordinates, using the given <a class="el" href="classvigra_1_1SplineImageView.html" title="Create a continuous view onto a discrete image using splines.">SplineImageView</a> <em>src</em> for interpolation. If the resulting coordinate is outside the source image, nothing will be writen at that destination point.<p>
<div class="fragment"><pre class="fragment">        <span class="keywordflow">for</span> all dest pixels:
            currentSrcCoordinate = affineMatrix * currentDestCoordinate;
            <span class="keywordflow">if</span> src.isInside(currentSrcCoordinate):
                dest[currentDestCoordinate] = src[currentSrcCoordinate]; <span class="comment">// copy an interpolated value</span>
</pre></div><p>
The matrix represent a 2-dimensional affine transform by means of homogeneous coordinates, i.e. it must be a 3x3 matrix whose last row is (0,0,1).<p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="affinegeometry_8hxx-source.html">vigra/affinegeometry.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    Image src(width, height);
    <a class="code" href="classvigra_1_1SplineImageView.html" title="Create a continuous view onto a discrete image using splines.">vigra::SplineImageView&lt;3, Image::value_type&gt;</a> spline(srcImageRange(src));
    
    Image dest1(width, height);
    
    <span class="comment">// equivalent (up to round-off errors) with </span>
    <span class="comment">//     rotateImage(spline, destImage(dest1), 45.0);</span>
    TinyVector&lt;double, 2&gt; center((width-1.0)/2.0, (height-1.0)/2.0);
    <a class="code" href="group__GeometricTransformations.html#g769f3e9b8a983232f7adc5031f393629" title="Warp an image according to an affine transformation.">affineWarpImage</a>(spline, destImageRange(dest1), <a class="code" href="group__GeometricTransformations.html#gcc7041b192dfb4a79de8d168abd495c9" title="Create homogeneous matrix representing a 2D rotation about the coordinate origin...">rotationMatrix2DDegrees</a>(45.0, center));
    
    Image dest2(2*width-1, 2*height-1);
    
    <span class="comment">// equivalent (up to round-off errors) with </span>
    <span class="comment">//     resizeImageSplineInterpolation(srcImageRange(img), destImageRange(dest2));</span>
    <span class="comment">// note that scaleFactor = 0.5, because we must pass the transformation from destination to source</span>
    <a class="code" href="group__GeometricTransformations.html#g769f3e9b8a983232f7adc5031f393629" title="Warp an image according to an affine transformation.">affineWarpImage</a>(spline, destImageRange(dest2), <a class="code" href="group__GeometricTransformations.html#g41cb093e4faa9a00db19571790530b86" title="Create homogeneous matrix representing a 2D uniform scaling about the coordinate...">scalingMatrix2D</a>(0.5));
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    DestImageIterator dest_upperleft;
    
    <span class="keywordtype">double</span> x = ..., y = ...;
    
    <span class="keywordflow">if</span> (spline.isInside(x,y))
        dest_accessor.set(spline(x, y), dest_upperleft);
</pre></div><p>
<b>See also:</b> Functions to specify affine transformation: <a class="el" href="group__GeometricTransformations.html#g18dd969f7e355a60a1ade6517944457d">translationMatrix2D()</a>, <a class="el" href="group__GeometricTransformations.html#g41cb093e4faa9a00db19571790530b86">scalingMatrix2D()</a>, <a class="el" href="group__GeometricTransformations.html#g42a408803035022f33ce0dae2cff5e81">shearMatrix2D()</a>, <a class="el" href="group__GeometricTransformations.html#g814c2b60d8b8579e159e939a76cd6db3">rotationMatrix2DRadians()</a>, <a class="el" href="group__GeometricTransformations.html#gcc7041b192dfb4a79de8d168abd495c9">rotationMatrix2DDegrees()</a> 
</div>
</div><p>
<a class="anchor" name="g39250b79a46084cfd41309921efa0ccb"></a><!-- doxytag: member="vigra::reflectImage" ref="g39250b79a46084cfd41309921efa0ccb" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::reflectImage           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reflect image horizontally or vertically. 
<p>
The reflection direction refers to the reflection axis, i.e. horizontal reflection turns the image upside down, vertical reflection changes left for right. The directions are selected by the enum values <code>vigra::horizontal</code> and <code>vigra::vertical</code>. The two directions can also be "or"ed together to perform both reflections simultaneously (see example below) -- this is the same as a 180 degree rotation.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> 
        <a class="code" href="group__GeometricTransformations.html#g39250b79a46084cfd41309921efa0ccb" title="Reflect image horizontally or vertically.">reflectImage</a>(SrcIterator is, SrcIterator end, SrcAccessor as,
                     DestIterator <span class="keywordtype">id</span>, DestAccessor ad, Reflect axis);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
              <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keyword">inline</span> <span class="keywordtype">void</span> 
        <a class="code" href="group__GeometricTransformations.html#g39250b79a46084cfd41309921efa0ccb" title="Reflect image horizontally or vertically.">reflectImage</a>(triple&lt;SrcImageIterator, SrcImageIterator, SrcAccessor&gt; src,
                     pair&lt;DestImageIterator, DestAccessor&gt; dest, Reflect axis);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="basicgeometry_8hxx-source.html">vigra/basicgeometry.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    Image dest(src.width(), src.height());
    
    <a class="code" href="group__GeometricTransformations.html#g39250b79a46084cfd41309921efa0ccb" title="Reflect image horizontally or vertically.">vigra::reflectImage</a>(srcImageRange(src), destImage(dest), vigra::horizontal | vigra::vertical);
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcImageIterator src_upperleft, src_lowerright;
    DestImageIterator dest_upperleft;
    
    SrcAccessor src_accessor;
    
    dest_accessor.set(src_accessor(src_upperleft), dest_upperleft);
</pre></div><p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">    src_lowerright.x - src_upperleft.x &gt; 1
    src_lowerright.y - src_upperleft.y &gt; 1
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g831ea7f68193828d8fadd7f97539e97c"></a><!-- doxytag: member="vigra::transposeImage" ref="g831ea7f68193828d8fadd7f97539e97c" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::transposeImage           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transpose an image over the major or minor diagonal. 
<p>
The transposition direction refers to the axis, i.e. major transposition turns the upper right corner into the lower left one, whereas minor transposition changes the upper left corner into the lower right one. The directions are selected by the enum values <code>vigra::major</code> and <code>vigra::minor</code>. The two directions can also be "or"ed together to perform both reflections simultaneously (see example below) -- this is the same as a 180 degree rotation.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> 
        <a class="code" href="group__GeometricTransformations.html#g831ea7f68193828d8fadd7f97539e97c" title="Transpose an image over the major or minor diagonal.">transposeImage</a>(SrcIterator is, SrcIterator end, SrcAccessor as,
                       DestIterator <span class="keywordtype">id</span>, DestAccessor ad, Transpose axis);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
              <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keyword">inline</span> <span class="keywordtype">void</span> 
        <a class="code" href="group__GeometricTransformations.html#g831ea7f68193828d8fadd7f97539e97c" title="Transpose an image over the major or minor diagonal.">transposeImage</a>(triple&lt;SrcImageIterator, SrcImageIterator, SrcAccessor&gt; src,
                       pair&lt;DestImageIterator, DestAccessor&gt; dest, Transpose axis);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="basicgeometry_8hxx-source.html">vigra/basicgeometry.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    Image dest(src.width(), src.height());
    
    <a class="code" href="group__GeometricTransformations.html#g831ea7f68193828d8fadd7f97539e97c" title="Transpose an image over the major or minor diagonal.">vigra::transposeImage</a>(srcImageRange(src), destImage(dest), vigra::major | vigra::minor);
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcImageIterator src_upperleft, src_lowerright;
    DestImageIterator dest_upperleft;
    
    SrcAccessor src_accessor;
    
    dest_accessor.set(src_accessor(src_upperleft), dest_upperleft);
</pre></div><p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">    src_lowerright.x - src_upperleft.x &gt; 1
    src_lowerright.y - src_upperleft.y &gt; 1
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g68e08f25b220b037fd59313fde70ffc9"></a><!-- doxytag: member="vigra::resampleImage" ref="g68e08f25b220b037fd59313fde70ffc9" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::resampleImage           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resample image by a given factor. 
<p>
This algorithm is very fast and does not require any arithmetic on the pixel types. The input image must have a size of at least 2x2. Destiniation pixels are directly copied from the appropriate source pixels. The size of the result image is the product of <code>factor</code> and the original size, where we round up if <code>factor &lt; 1.0</code> and down otherwise. This size calculation is the main difference to the convention used in the similar function <a class="el" href="group__GeometricTransformations.html#g8db7c21dc1a3b3f5a7b4e8619345626b">resizeImageNoInterpolation()</a>: there, the result size is calculated as <code>n*(old_width-1)+1</code> and <code>n*(old_height-1)+1</code>. This is because <a class="el" href="group__GeometricTransformations.html#g8db7c21dc1a3b3f5a7b4e8619345626b">resizeImageNoInterpolation()</a> does not replicate the last pixel in every row/column in order to make it compatible with the other functions of the <code>resizeImage...</code> family.<p>
It should also be noted that <a class="el" href="group__GeometricTransformations.html#g68e08f25b220b037fd59313fde70ffc9" title="Resample image by a given factor.">resampleImage()</a> is implemented so that an enlargement followed by the corresponding shrinking reproduces the original image. The function uses accessors.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span> 
        <a class="code" href="group__GeometricTransformations.html#g68e08f25b220b037fd59313fde70ffc9" title="Resample image by a given factor.">resampleImage</a>(SrcIterator is, SrcIterator iend, SrcAccessor sa,
                      DestIterator <span class="keywordtype">id</span>, DestAccessor ad, <span class="keywordtype">double</span> factor);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
              <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keyword">inline</span> <span class="keywordtype">void</span> 
        <a class="code" href="group__GeometricTransformations.html#g68e08f25b220b037fd59313fde70ffc9" title="Resample image by a given factor.">resampleImage</a>(triple&lt;SrcImageIterator, SrcImageIterator, SrcAccessor&gt; src,
                      pair&lt;DestImageIterator, DestAccessor&gt; dest, <span class="keywordtype">double</span> factor);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="basicgeometry_8hxx-source.html">vigra/basicgeometry.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">double</span> factor = 2.0;
    Image dest((<span class="keywordtype">int</span>)(factor*src.width()), (<span class="keywordtype">int</span>)(factor*src.height()));
    
    <a class="code" href="group__GeometricTransformations.html#g68e08f25b220b037fd59313fde70ffc9" title="Resample image by a given factor.">vigra::resampleImage</a>(srcImageRange(src), destImage(dest), factor);
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcImageIterator src_upperleft, src_lowerright;
    DestImageIterator dest_upperleft;
    
    SrcAccessor src_accessor;
    
    dest_accessor.set(src_accessor(src_upperleft), dest_upperleft);
</pre></div><p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">    src_lowerright.x - src_upperleft.x &gt; 1
    src_lowerright.y - src_upperleft.y &gt; 1
</pre></div> 
</div>
</div><p>
<a class="anchor" name="gd77190b060bafe5791f7926502f147ec"></a><!-- doxytag: member="vigra::resizeMultiArraySplineInterpolation" ref="gd77190b060bafe5791f7926502f147ec" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::resizeMultiArraySplineInterpolation           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resize <a class="el" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">MultiArray</a> using B-spline interpolation. 
<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>Shape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>Kernel = BSpline&lt;3, double&gt; &gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__GeometricTransformations.html#gd77190b060bafe5791f7926502f147ec" title="Resize MultiArray using B-spline interpolation.">resizeMultiArraySplineInterpolation</a>(
                              SrcIterator si, Shape <span class="keyword">const</span> &amp; sshape, SrcAccessor src,
                              DestIterator di, Shape <span class="keyword">const</span> &amp; dshape, DestAccessor dest,
                              Kernel <span class="keyword">const</span> &amp; spline = BSpline&lt;3, double&gt;());
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>Shape, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>Kernel = BSpline&lt;3, double&gt; &gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__GeometricTransformations.html#gd77190b060bafe5791f7926502f147ec" title="Resize MultiArray using B-spline interpolation.">resizeMultiArraySplineInterpolation</a>(
                              triple&lt;SrcIterator, Shape, SrcAccessor&gt; src,
                              triple&lt;DestIterator, Shape, DestAccessor&gt; dest,
                              Kernel <span class="keyword">const</span> &amp; spline = BSpline&lt;3, double&gt;());
    }
</pre></div><p>
The function implements separable spline interpolation algorithm described in<p>
M. Unser, A. Aldroubi, M. Eden, <em>"B-Spline Signal Processing"</em> IEEE Transactions on Signal Processing, vol. 41, no. 2, pp. 821-833 (part I), pp. 834-848 (part II), 1993.<p>
to obtain optimal interpolation quality and speed. You may pass the funcion a spline of arbitrary order (e.g. <code><a class="el" href="classvigra_1_1BSpline.html">BSpline&lt;ORDER, double&gt;</a></code> or <code>CatmullRomSpline&lt;double&gt;</code>). The default is a third order spline which gives a twice continuously differentiable interpolant. The implementation ensures that image values are interpolated rather than smoothed by first calling a recursive (sharpening) prefilter as described in the above paper. Then the actual interpolation is done using <a class="el" href="group__ResamplingConvolutionFilters.html#gaaf7088416856e96828f8b1271527d9f">resamplingConvolveLine()</a>.<p>
The range of both the input and output images (resp. regions) must be given. The input image must have a size of at least 4x4, the destination of at least 2x2. The scaling factors are then calculated accordingly. If the source image is larger than the destination, it is smoothed (band limited) using a recursive exponential filter. The source value_type (SrcAccessor::value_type) must be a linear algebra, i.e. it must support addition, subtraction, and multiplication (+, -, *), multiplication with a scalar real number and <a class="el" href="NumericTraits.html">NumericTraits</a>. The function uses accessors.<p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="multi__resize_8hxx-source.html">vigra/multi_resize.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <span class="keyword">typedef</span> <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, float&gt;::difference_type</a> Shape;
    <a class="code" href="classvigra_1_1MultiArray.html" title="Main MultiArray class containing the memory management.">vigra::MultiArray&lt;3, float&gt;</a> src(Shape(5, 7, 10)),
                                dest(Shape(9, 13, 19)); <span class="comment">// double the size</span>

    <span class="comment">// use default cubic spline interpolator</span>
    <a class="code" href="group__GeometricTransformations.html#gd77190b060bafe5791f7926502f147ec" title="Resize MultiArray using B-spline interpolation.">vigra::resizeMultiArraySplineInterpolation</a>(
               srcMultiArrayRange(src),
               destMultiArrayRange(dest));
</pre></div><p>
<b> Required Interface:</b><p>
The source and destination iterators must be compatible with <a class="el" href="classvigra_1_1MultiIterator.html">vigra::MultiIterator</a>. The array value types must be models of <a class="el" href="AlgebraicConcepts.html#LinearSpace">LinearSpace</a>. 
</div>
</div><p>
<a class="anchor" name="g8db7c21dc1a3b3f5a7b4e8619345626b"></a><!-- doxytag: member="vigra::resizeImageNoInterpolation" ref="g8db7c21dc1a3b3f5a7b4e8619345626b" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::resizeImageNoInterpolation           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resize image by repeating the nearest pixel values. 
<p>
This algorithm is very fast and does not require any arithmetic on the pixel types.<p>
The range of both the input and output images (resp. regions) must be given. Both images must have a size of at least 2x2 pixels. The scaling factors are then calculated accordingly. Destination pixels are directly copied from the appropriate source pixels.<p>
The function uses accessors.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__GeometricTransformations.html#g8db7c21dc1a3b3f5a7b4e8619345626b" title="Resize image by repeating the nearest pixel values.">resizeImageNoInterpolation</a>(
              SrcImageIterator is, SrcImageIterator iend, SrcAccessor sa,
              DestImageIterator <span class="keywordtype">id</span>, DestImageIterator idend, DestAccessor da)
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__GeometricTransformations.html#g8db7c21dc1a3b3f5a7b4e8619345626b" title="Resize image by repeating the nearest pixel values.">resizeImageNoInterpolation</a>(
              triple&lt;SrcImageIterator, SrcImageIterator, SrcAccessor&gt; src,
              triple&lt;DestImageIterator, DestImageIterator, DestAccessor&gt; dest)
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="resizeimage_8hxx-source.html">vigra/resizeimage.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__GeometricTransformations.html#g8db7c21dc1a3b3f5a7b4e8619345626b" title="Resize image by repeating the nearest pixel values.">vigra::resizeImageNoInterpolation</a>(
               src.upperLeft(), src.lowerRight(), src.accessor(),
               dest.upperLeft(), dest.lowerRight(), dest.accessor());
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcImageIterator src_upperleft, src_lowerright;
    DestImageIterator dest_upperleft, src_lowerright;

    SrcAccessor src_accessor;
    DestAccessor dest_accessor;

    dest_accessor.set(src_accessor(src_upperleft), dest_upperleft);
</pre></div><p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">    src_lowerright.x - src_upperleft.x &gt; 1
    src_lowerright.y - src_upperleft.y &gt; 1
    dest_lowerright.x - dest_upperleft.x &gt; 1
    dest_lowerright.y - dest_upperleft.y &gt; 1
</pre></div> 
</div>
</div><p>
<a class="anchor" name="gdc90ce771db3f4b57fe6d3135592f74c"></a><!-- doxytag: member="vigra::resizeImageLinearInterpolation" ref="gdc90ce771db3f4b57fe6d3135592f74c" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::resizeImageLinearInterpolation           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resize image using linear interpolation. 
<p>
The function uses the standard separable bilinear interpolation algorithm to obtain a good compromize between quality and speed.<p>
The range must of both the input and output images (resp. regions) must be given. Both images must have a size of at least 2x2. The scaling factors are then calculated accordingly. If the source image is larger than the destination, it is smoothed (band limited) using a recursive exponential filter. The source value_type (SrcAccessor::value_type) must be a linear space, i.e. it must support addition, multiplication with a scalar real number and <a class="el" href="NumericTraits.html">NumericTraits</a>. The function uses accessors.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__GeometricTransformations.html#gdc90ce771db3f4b57fe6d3135592f74c" title="Resize image using linear interpolation.">resizeImageLinearInterpolation</a>(
              SrcImageIterator is, SrcImageIterator iend, SrcAccessor sa,
              DestImageIterator <span class="keywordtype">id</span>, DestImageIterator idend, DestAccessor da)
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__GeometricTransformations.html#gdc90ce771db3f4b57fe6d3135592f74c" title="Resize image using linear interpolation.">resizeImageLinearInterpolation</a>(
              triple&lt;SrcImageIterator, SrcImageIterator, SrcAccessor&gt; src,
              triple&lt;DestImageIterator, DestImageIterator, DestAccessor&gt; dest)
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="resizeimage_8hxx-source.html">vigra/resizeimage.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__GeometricTransformations.html#gdc90ce771db3f4b57fe6d3135592f74c" title="Resize image using linear interpolation.">vigra::resizeImageLinearInterpolation</a>(
               src.upperLeft(), src.lowerRight(), src.accessor(),
               dest.upperLeft(), dest.lowerRight(), dest.accessor());
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcImageIterator src_upperleft, src_lowerright;
    DestImageIterator dest_upperleft, src_lowerright;

    SrcAccessor src_accessor;
    DestAccessor dest_accessor;

    NumericTraits&lt;SrcAccessor::value_type&gt;::RealPromote
                             u = src_accessor(src_upperleft),
                 v = src_accessor(src_upperleft, 1);
    <span class="keywordtype">double</span> d;

    u = d * v;
    u = u + v;

    dest_accessor.set(
        NumericTraits&lt;DestAccessor::value_type&gt;::fromRealPromote(u),
    dest_upperleft);
</pre></div><p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">    src_lowerright.x - src_upperleft.x &gt; 1
    src_lowerright.y - src_upperleft.y &gt; 1
    dest_lowerright.x - dest_upperleft.x &gt; 1
    dest_lowerright.y - dest_upperleft.y &gt; 1
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g02f1c9007ec9b0395accc6b02ea37284"></a><!-- doxytag: member="vigra::resizeImageSplineInterpolation" ref="g02f1c9007ec9b0395accc6b02ea37284" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::resizeImageSplineInterpolation           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resize image using B-spline interpolation. 
<p>
The function implements separable spline interpolation algorithm described in<p>
M. Unser, A. Aldroubi, M. Eden, <em>"B-Spline Signal Processing"</em> IEEE Transactions on Signal Processing, vol. 41, no. 2, pp. 821-833 (part I), pp. 834-848 (part II), 1993.<p>
to obtain optimal interpolation quality and speed. You may pass the funcion a spline of arbitrary order (e.g. <code><a class="el" href="classvigra_1_1BSpline.html">BSpline&lt;ORDER, double&gt;</a></code> or <code>CatmullRomSpline&lt;double&gt;</code>). The default is a third order spline which gives a twice continuously differentiable interpolant. The implementation ensures that image values are interpolated rather than smoothed by first calling a recursive (sharpening) prefilter as described in the above paper. Then the actual interpolation is done using <a class="el" href="group__ResamplingConvolutionFilters.html#gaaf7088416856e96828f8b1271527d9f">resamplingConvolveLine()</a>.<p>
The range of both the input and output images (resp. regions) must be given. The input image must have a size of at least 4x4, the destination of at least 2x2. The scaling factors are then calculated accordingly. If the source image is larger than the destination, it is smoothed (band limited) using a recursive exponential filter. The source value_type (SrcAccessor::value_type) must be a linear algebra, i.e. it must support addition, subtraction, and multiplication (+, -, *), multiplication with a scalar real number and <a class="el" href="NumericTraits.html">NumericTraits</a>. The function uses accessors.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>SPLINE&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__GeometricTransformations.html#g02f1c9007ec9b0395accc6b02ea37284" title="Resize image using B-spline interpolation.">resizeImageSplineInterpolation</a>(
              SrcImageIterator is, SrcImageIterator iend, SrcAccessor sa,
              DestImageIterator <span class="keywordtype">id</span>, DestImageIterator idend, DestAccessor da,
              SPLINE spline = BSpline&lt;3, double&gt;())
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcImageIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestImageIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>SPLINE&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__GeometricTransformations.html#g02f1c9007ec9b0395accc6b02ea37284" title="Resize image using B-spline interpolation.">resizeImageSplineInterpolation</a>(
              triple&lt;SrcImageIterator, SrcImageIterator, SrcAccessor&gt; src,
              triple&lt;DestImageIterator, DestImageIterator, DestAccessor&gt; dest,
              SPLINE spline = BSpline&lt;3, double&gt;())
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="resizeimage_8hxx-source.html">vigra/resizeimage.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__GeometricTransformations.html#g02f1c9007ec9b0395accc6b02ea37284" title="Resize image using B-spline interpolation.">vigra::resizeImageSplineInterpolation</a>(
               src.upperLeft(), src.lowerRight(), src.accessor(),
               dest.upperLeft(), dest.lowerRight(), dest.accessor());
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcImageIterator src_upperleft, src_lowerright;
    DestImageIterator dest_upperleft, src_lowerright;

    SrcAccessor src_accessor;
    DestAccessor dest_accessor;

    NumericTraits&lt;SrcAccessor::value_type&gt;::RealPromote
                             u = src_accessor(src_upperleft),
                 v = src_accessor(src_upperleft, 1);
    <span class="keywordtype">double</span> d;

    u = d * v;
    u = u + v;
    u = u - v;
    u = u * v;
    u += v;
    u -= v;

    dest_accessor.set(
        NumericTraits&lt;DestAccessor::value_type&gt;::fromRealPromote(u),
    dest_upperleft);
</pre></div><p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">    src_lowerright.x - src_upperleft.x &gt; 3
    src_lowerright.y - src_upperleft.y &gt; 3
    dest_lowerright.x - dest_upperleft.x &gt; 1
    dest_lowerright.y - dest_upperleft.y &gt; 1
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g4fe762871977ae7f4b29fc78ea411edc"></a><!-- doxytag: member="vigra::resizeImageCatmullRomInterpolation" ref="g4fe762871977ae7f4b29fc78ea411edc" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::resizeImageCatmullRomInterpolation           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resize image using the Catmull/Rom interpolation function. 
<p>
The function calls like <a class="el" href="group__GeometricTransformations.html#g02f1c9007ec9b0395accc6b02ea37284">resizeImageSplineInterpolation()</a> with <a class="el" href="classvigra_1_1CatmullRomSpline.html">vigra::CatmullRomSpline</a> as an interpolation kernel. The interpolated function has one continuous derivative. (See <a class="el" href="group__GeometricTransformations.html#g02f1c9007ec9b0395accc6b02ea37284">resizeImageSplineInterpolation()</a> for more documentation)<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__GeometricTransformations.html#g4fe762871977ae7f4b29fc78ea411edc" title="Resize image using the Catmull/Rom interpolation function.">resizeImageCatmullRomInterpolation</a>(SrcIterator src_iter, SrcIterator src_iter_end, SrcAccessor src_acc,
                              DestIterator dest_iter, DestIterator dest_iter_end, DestAccessor dest_acc);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__GeometricTransformations.html#g4fe762871977ae7f4b29fc78ea411edc" title="Resize image using the Catmull/Rom interpolation function.">resizeImageCatmullRomInterpolation</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
                              triple&lt;DestIterator, DestIterator, DestAccessor&gt; dest);
    }
</pre></div><p>
<b>#include</b> &lt;<a href="resizeimage_8hxx-source.html">vigra/resizeimage.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
<a class="anchor" name="gb4955d622ab2f110a7e5c72d0d27b59a"></a><!-- doxytag: member="vigra::resizeImageCoscotInterpolation" ref="gb4955d622ab2f110a7e5c72d0d27b59a" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::resizeImageCoscotInterpolation           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resize image using the Coscot interpolation function. 
<p>
The function calls <a class="el" href="group__GeometricTransformations.html#g02f1c9007ec9b0395accc6b02ea37284">resizeImageSplineInterpolation()</a> with <a class="el" href="classvigra_1_1CoscotFunction.html">vigra::CoscotFunction</a> as an interpolation kernel. The interpolated function has one continuous derivative. (See <a class="el" href="group__GeometricTransformations.html#g02f1c9007ec9b0395accc6b02ea37284">resizeImageSplineInterpolation()</a> for more documentation)<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__GeometricTransformations.html#gb4955d622ab2f110a7e5c72d0d27b59a" title="Resize image using the Coscot interpolation function.">resizeImageCoscotInterpolation</a>(SrcIterator src_iter, SrcIterator src_iter_end, SrcAccessor src_acc,
                              DestIterator dest_iter, DestIterator dest_iter_end, DestAccessor dest_acc);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__GeometricTransformations.html#gb4955d622ab2f110a7e5c72d0d27b59a" title="Resize image using the Coscot interpolation function.">resizeImageCoscotInterpolation</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
                              triple&lt;DestIterator, DestIterator, DestAccessor&gt; dest);
    }
</pre></div><p>
<b>#include</b> &lt;<a href="resizeimage_8hxx-source.html">vigra/resizeimage.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a> 
</div>
</div><p>
</div>
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
VIGRA 1.6.0 (13 Aug 2008)
</i>
</tr>
</table>


</BODY>
</HTML>
