<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>VIGRA - VIGRA: Edge Detection</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<table class="main_heading">
<tr>
<td align=left>
<A HREF ="#_details" ><IMG BORDER=0 ALT="details" SRC="documents/pfeilGross.gif"></A>
</td>
<td width="100%">Edge Detection
</td>
<td align=right><a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif"></a></td></tr>
</table><p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvigra_1_1Edgel.html">Edgel</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#gd23b10d3d105e3a9e394e4542a1baa8b">beautifyCrackEdgeImage</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Beautify crack edge image for visualization.  <a href="#gd23b10d3d105e3a9e394e4542a1baa8b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#g587ce18f5e12bfa76e39696a93560a63">cannyEdgeImage</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detect and mark edges in an edge image using Canny's algorithm.  <a href="#g587ce18f5e12bfa76e39696a93560a63"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#g7df0e9b814a556327ca5d071473c0c01">cannyEdgeImageFromGradWithThinning</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detect and mark edges in an edge image using Canny's algorithm.  <a href="#g7df0e9b814a556327ca5d071473c0c01"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#gdb574fc684ae8e15629ca77b0c961f21">cannyEdgeImageWithThinning</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detect and mark edges in an edge image using Canny's algorithm.  <a href="#gdb574fc684ae8e15629ca77b0c961f21"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#g07d8d68b29292a80213bfcd00cff2410">cannyEdgelList</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple implementation of Canny's edge detector.  <a href="#g07d8d68b29292a80213bfcd00cff2410"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#g36f25b87755f840fed095aa28c56f030">cannyEdgelList3x3</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Improved implementation of Canny's edge detector.  <a href="#g36f25b87755f840fed095aa28c56f030"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#gf3413437b6a66fbd9cb2c8327d113465">closeGapsInCrackEdgeImage</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close one-pixel wide gaps in a cell grid edge image.  <a href="#gf3413437b6a66fbd9cb2c8327d113465"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#g03891ba21dd1b7c5d8c3337423dcf34b">differenceOfExponentialCrackEdgeImage</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detect and mark edges in a crack edge image using the Shen/Castan zero-crossing detector.  <a href="#g03891ba21dd1b7c5d8c3337423dcf34b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#ga5d344b259ecef092a63d153b1e6b24c">differenceOfExponentialEdgeImage</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detect and mark edges in an edge image using the Shen/Castan zero-crossing detector.  <a href="#ga5d344b259ecef092a63d153b1e6b24c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;... &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__EdgeDetection.html#g78ffe78118c0d65bf33c0ed2a4db3983">removeShortEdges</a> (...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove short edges from an edge image.  <a href="#g78ffe78118c0d65bf33c0ed2a4db3983"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2 class="details_section">Detailed Description</h2>
Edge detectors based on first and second derivatives, and related post-processing. <hr><h2>Function Documentation</h2>
<a class="anchor" name="ga5d344b259ecef092a63d153b1e6b24c"></a><!-- doxytag: member="vigra::differenceOfExponentialEdgeImage" ref="ga5d344b259ecef092a63d153b1e6b24c" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::differenceOfExponentialEdgeImage           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detect and mark edges in an edge image using the Shen/Castan zero-crossing detector. 
<p>
This operator applies an exponential filter to the source image at the given <code>scale</code> and subtracts the result from the original image. Zero crossings are detected in the resulting difference image. Whenever the gradient at a zero crossing is greater than the given <code>gradient_threshold</code>, an edge point is marked (using <code>edge_marker</code>) in the destination image on the darker side of the zero crossing (note that zero crossings occur <em>between</em> pixels). For example:<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__MathFunctions.html#ga676c74bca158f2556180ad221ef2d31">sign</a> of difference image     resulting edge points (*)

        + - -                          * * .
        + + -               =&gt;         . * *
        + + +                          . . .
</pre></div><p>
Non-edge pixels (<code>.</code>) remain untouched in the destination image. The result can be improved by the post-processing operation <a class="el" href="group__EdgeDetection.html#g78ffe78118c0d65bf33c0ed2a4db3983">removeShortEdges()</a>. A more accurate edge placement can be achieved with the function <a class="el" href="group__EdgeDetection.html#g03891ba21dd1b7c5d8c3337423dcf34b">differenceOfExponentialCrackEdgeImage()</a>.<p>
The source value type (<code>SrcAccessor::value_type</code>) must be a linear algebra, i.e. addition, subtraction and multiplication of the type with itself, and multiplication with double and <a class="el" href="NumericTraits.html">NumericTraits</a> must be defined. In addition, this type must be less-comparable.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
              <span class="keyword">class </span>GradValue,
              <span class="keyword">class </span>DestValue = DestAccessor::value_type&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#ga5d344b259ecef092a63d153b1e6b24c" title="Detect and mark edges in an edge image using the Shen/Castan zero-crossing detector...">differenceOfExponentialEdgeImage</a>(
               SrcIterator sul, SrcIterator slr, SrcAccessor sa,
               DestIterator dul, DestAccessor da,
               <span class="keywordtype">double</span> scale, GradValue gradient_threshold,
               DestValue edge_marker = NumericTraits&lt;DestValue&gt;::one())
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
              <span class="keyword">class </span>GradValue,
              <span class="keyword">class </span>DestValue = DestAccessor::value_type&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#ga5d344b259ecef092a63d153b1e6b24c" title="Detect and mark edges in an edge image using the Shen/Castan zero-crossing detector...">differenceOfExponentialEdgeImage</a>(
               triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
               pair&lt;DestIterator, DestAccessor&gt; dest,
               <span class="keywordtype">double</span> scale, GradValue gradient_threshold,
               DestValue edge_marker = NumericTraits&lt;DestValue&gt;::one())
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="edgedetection_8hxx-source.html">vigra/edgedetection.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::BImage</a> src(w,h), edges(w,h);

    <span class="comment">// empty edge image</span>
    edges = 0;
    ...

    <span class="comment">// find edges at scale 0.8 with gradient larger than 4.0, mark with 1</span>
    <a class="code" href="group__EdgeDetection.html#ga5d344b259ecef092a63d153b1e6b24c" title="Detect and mark edges in an edge image using the Shen/Castan zero-crossing detector...">vigra::differenceOfExponentialEdgeImage</a>(srcImageRange(src), destImage(edges),
                                     0.8, 4.0, 1);
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcImageIterator src_upperleft, src_lowerright;
    DestImageIterator dest_upperleft;

    SrcAccessor src_accessor;
    DestAccessor dest_accessor;

    SrcAccessor::value_type u = src_accessor(src_upperleft);
    <span class="keywordtype">double</span> d;
    GradValue gradient_threshold;

    u = u + u
    u = u - u
    u = u * u
    u = d * u
    u &lt; gradient_threshold

    DestValue edge_marker;
    dest_accessor.set(edge_marker, dest_upperleft);
</pre></div><p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">    scale &gt; 0
    gradient_threshold &gt; 0
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g03891ba21dd1b7c5d8c3337423dcf34b"></a><!-- doxytag: member="vigra::differenceOfExponentialCrackEdgeImage" ref="g03891ba21dd1b7c5d8c3337423dcf34b" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::differenceOfExponentialCrackEdgeImage           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detect and mark edges in a crack edge image using the Shen/Castan zero-crossing detector. 
<p>
This operator applies an exponential filter to the source image at the given <code>scale</code> and subtracts the result from the original image. Zero crossings are detected in the resulting difference image. Whenever the gradient at a zero crossing is greater than the given <code>gradient_threshold</code>, an edge point is marked (using <code>edge_marker</code>) in the destination image <em>between</em> the corresponding original pixels. Topologically, this means we must insert additional pixels between the original ones to represent the boundaries between the pixels (the so called zero- and one-cells, with the original pixels being two-cells). Within VIGRA, such an image is called <a class="el" href="CrackEdgeImage.html">Crack Edge Image</a>. To allow insertion of the zero- and one-cells, the destination image must have twice the size of the original (precisely, <code>(2*w-1)</code> by <code>(2*h-1)</code> pixels). Then the algorithm proceeds as follows:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__MathFunctions.html#ga676c74bca158f2556180ad221ef2d31">sign</a> of difference image     insert zero- and one-cells     resulting edge points (*)

                                     + . - . -                   . * . . .
      + - -                          . . . . .                   . * * * .
      + + -               =&gt;         + . + . -           =&gt;      . . . * .
      + + +                          . . . . .                   . . . * *
                                     + . + . +                   . . . . .
</pre></div><p>
Thus the edge points are marked where they actually are - in between the pixels. An important property of the resulting edge image is that it conforms to the notion of well-composedness as defined by Latecki et al., i.e. connected regions and edges obtained by a subsequent <a class="el" href="group__Labeling.html">Connected Components Labeling</a> do not depend on whether 4- or 8-connectivity is used. The non-edge pixels (<code>.</code>) in the destination image remain unchanged. The result conformes to the requirements of a <a class="el" href="CrackEdgeImage.html">Crack Edge Image</a>. It can be further improved by the post-processing operations <a class="el" href="group__EdgeDetection.html#g78ffe78118c0d65bf33c0ed2a4db3983">removeShortEdges()</a> and <a class="el" href="group__EdgeDetection.html#gf3413437b6a66fbd9cb2c8327d113465">closeGapsInCrackEdgeImage()</a>.<p>
The source value type (<code>SrcAccessor::value_type</code>) must be a linear algebra, i.e. addition, subtraction and multiplication of the type with itself, and multiplication with double and <a class="el" href="NumericTraits.html">NumericTraits</a> must be defined. In addition, this type must be less-comparable.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
              <span class="keyword">class </span>GradValue,
              <span class="keyword">class </span>DestValue = DestAccessor::value_type&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#g03891ba21dd1b7c5d8c3337423dcf34b" title="Detect and mark edges in a crack edge image using the Shen/Castan zero-crossing detector...">differenceOfExponentialCrackEdgeImage</a>(
               SrcIterator sul, SrcIterator slr, SrcAccessor sa,
               DestIterator dul, DestAccessor da,
               <span class="keywordtype">double</span> scale, GradValue gradient_threshold,
               DestValue edge_marker = NumericTraits&lt;DestValue&gt;::one())
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
              <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
              <span class="keyword">class </span>GradValue,
              <span class="keyword">class </span>DestValue = DestAccessor::value_type&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#g03891ba21dd1b7c5d8c3337423dcf34b" title="Detect and mark edges in a crack edge image using the Shen/Castan zero-crossing detector...">differenceOfExponentialCrackEdgeImage</a>(
               triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
               pair&lt;DestIterator, DestAccessor&gt; dest,
               <span class="keywordtype">double</span> scale, GradValue gradient_threshold,
               DestValue edge_marker = NumericTraits&lt;DestValue&gt;::one())
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="edgedetection_8hxx-source.html">vigra/edgedetection.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::BImage</a> src(w,h), edges(2*w-1,2*h-1);

    <span class="comment">// empty edge image</span>
    edges = 0;
    ...

    <span class="comment">// find edges at scale 0.8 with gradient larger than 4.0, mark with 1</span>
    <a class="code" href="group__EdgeDetection.html#g03891ba21dd1b7c5d8c3337423dcf34b" title="Detect and mark edges in a crack edge image using the Shen/Castan zero-crossing detector...">vigra::differenceOfExponentialCrackEdgeImage</a>(srcImageRange(src), destImage(edges),
                                     0.8, 4.0, 1);
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcImageIterator src_upperleft, src_lowerright;
    DestImageIterator dest_upperleft;

    SrcAccessor src_accessor;
    DestAccessor dest_accessor;

    SrcAccessor::value_type u = src_accessor(src_upperleft);
    <span class="keywordtype">double</span> d;
    GradValue gradient_threshold;

    u = u + u
    u = u - u
    u = u * u
    u = d * u
    u &lt; gradient_threshold

    DestValue edge_marker;
    dest_accessor.set(edge_marker, dest_upperleft);
</pre></div><p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">    scale &gt; 0
    gradient_threshold &gt; 0
</pre></div><p>
The destination image must have twice the size of the source: <div class="fragment"><pre class="fragment">    w_dest = 2 * w_src - 1
    h_dest = 2 * h_src - 1
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g78ffe78118c0d65bf33c0ed2a4db3983"></a><!-- doxytag: member="vigra::removeShortEdges" ref="g78ffe78118c0d65bf33c0ed2a4db3983" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::removeShortEdges           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove short edges from an edge image. 
<p>
This algorithm can be applied as a post-processing operation of <a class="el" href="group__EdgeDetection.html#ga5d344b259ecef092a63d153b1e6b24c">differenceOfExponentialEdgeImage()</a> and <a class="el" href="group__EdgeDetection.html#g03891ba21dd1b7c5d8c3337423dcf34b">differenceOfExponentialCrackEdgeImage()</a>. It removes all edges that are shorter than <code>min_edge_length</code>. The corresponding pixels are set to the <code>non_edge_marker</code>. The idea behind this algorithms is that very short edges are probably caused by noise and don't represent interesting image structure. Technically, the algorithms executes a connected components labeling, so the image's value type must be equality comparable.<p>
If the source image fulfills the requirements of a <a class="el" href="CrackEdgeImage.html">Crack Edge Image</a>, it will still do so after application of this algorithm.<p>
Note that this algorithm, unlike most other algorithms in VIGRA, operates in-place, i.e. on only one image. Also, the algorithm assumes that all non-edges pixels are already marked with the given <code>non_edge_marker</code> value.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> Accessor, <span class="keyword">class</span> SrcValue&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#g78ffe78118c0d65bf33c0ed2a4db3983" title="Remove short edges from an edge image.">removeShortEdges</a>(
               Iterator sul, Iterator slr, Accessor sa,
               <span class="keywordtype">int</span> min_edge_length, SrcValue non_edge_marker)
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> Accessor, <span class="keyword">class</span> SrcValue&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#g78ffe78118c0d65bf33c0ed2a4db3983" title="Remove short edges from an edge image.">removeShortEdges</a>(
               triple&lt;Iterator, Iterator, Accessor&gt; src,
               <span class="keywordtype">int</span> min_edge_length, SrcValue non_edge_marker)
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="edgedetection_8hxx-source.html">vigra/edgedetection.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::BImage</a> src(w,h), edges(w,h);

    <span class="comment">// empty edge image</span>
    edges = 0;
    ...

    <span class="comment">// find edges at scale 0.8 with gradient larger than 4.0, mark with 1</span>
    <a class="code" href="group__EdgeDetection.html#ga5d344b259ecef092a63d153b1e6b24c" title="Detect and mark edges in an edge image using the Shen/Castan zero-crossing detector...">vigra::differenceOfExponentialEdgeImage</a>(srcImageRange(src), destImage(edges),
                                     0.8, 4.0, 1);

    <span class="comment">// zero edges shorter than 10 pixels</span>
    <a class="code" href="group__EdgeDetection.html#g78ffe78118c0d65bf33c0ed2a4db3983" title="Remove short edges from an edge image.">vigra::removeShortEdges</a>(srcImageRange(edges), 10, 0);
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcImageIterator src_upperleft, src_lowerright;
    DestImageIterator dest_upperleft;

    SrcAccessor src_accessor;
    DestAccessor dest_accessor;

    SrcAccessor::value_type u = src_accessor(src_upperleft);

    u == u

    SrcValue non_edge_marker;
    src_accessor.set(non_edge_marker, src_upperleft);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="gf3413437b6a66fbd9cb2c8327d113465"></a><!-- doxytag: member="vigra::closeGapsInCrackEdgeImage" ref="gf3413437b6a66fbd9cb2c8327d113465" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::closeGapsInCrackEdgeImage           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close one-pixel wide gaps in a cell grid edge image. 
<p>
This algorithm is typically applied as a post-processing operation of <a class="el" href="group__EdgeDetection.html#g03891ba21dd1b7c5d8c3337423dcf34b">differenceOfExponentialCrackEdgeImage()</a>. The source image must fulfill the requirements of a <a class="el" href="CrackEdgeImage.html">Crack Edge Image</a>, and will still do so after application of this algorithm.<p>
It closes one pixel wide gaps in the edges resulting from this algorithm. Since these gaps are usually caused by zero crossing slightly below the gradient threshold used in edge detection, this algorithms acts like a weak hysteresis thresholding. The newly found edge pixels are marked with the given <code>edge_marker</code>. The image's value type must be equality comparable.<p>
Note that this algorithm, unlike most other algorithms in VIGRA, operates in-place, i.e. on only one image.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> SrcIterator, <span class="keyword">class</span> SrcAccessor, <span class="keyword">class</span> SrcValue&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#gf3413437b6a66fbd9cb2c8327d113465" title="Close one-pixel wide gaps in a cell grid edge image.">closeGapsInCrackEdgeImage</a>(
               SrcIterator sul, SrcIterator slr, SrcAccessor sa,
               SrcValue edge_marker)
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> SrcIterator, <span class="keyword">class</span> SrcAccessor, <span class="keyword">class</span> SrcValue&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#gf3413437b6a66fbd9cb2c8327d113465" title="Close one-pixel wide gaps in a cell grid edge image.">closeGapsInCrackEdgeImage</a>(
               triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
               SrcValue edge_marker)
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="edgedetection_8hxx-source.html">vigra/edgedetection.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::BImage</a> src(w,h), edges(2*w-1, 2*h-1);

    <span class="comment">// empty edge image</span>
    edges = 0;
    ...

    <span class="comment">// find edges at scale 0.8 with gradient larger than 4.0, mark with 1</span>
    <a class="code" href="group__EdgeDetection.html#g03891ba21dd1b7c5d8c3337423dcf34b" title="Detect and mark edges in a crack edge image using the Shen/Castan zero-crossing detector...">vigra::differenceOfExponentialCrackEdgeImage</a>(srcImageRange(src), destImage(edges),
                                         0.8, 4.0, 1);

    <span class="comment">// close gaps, mark with 1</span>
    <a class="code" href="group__EdgeDetection.html#gf3413437b6a66fbd9cb2c8327d113465" title="Close one-pixel wide gaps in a cell grid edge image.">vigra::closeGapsInCrackEdgeImage</a>(srcImageRange(edges), 1);

    <span class="comment">// zero edges shorter than 20 pixels</span>
    <a class="code" href="group__EdgeDetection.html#g78ffe78118c0d65bf33c0ed2a4db3983" title="Remove short edges from an edge image.">vigra::removeShortEdges</a>(srcImageRange(edges), 10, 0);
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcImageIterator src_upperleft, src_lowerright;

    SrcAccessor src_accessor;
    DestAccessor dest_accessor;

    SrcAccessor::value_type u = src_accessor(src_upperleft);

    u == u
    u != u

    SrcValue edge_marker;
    src_accessor.set(edge_marker, src_upperleft);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="gd23b10d3d105e3a9e394e4542a1baa8b"></a><!-- doxytag: member="vigra::beautifyCrackEdgeImage" ref="gd23b10d3d105e3a9e394e4542a1baa8b" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::beautifyCrackEdgeImage           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Beautify crack edge image for visualization. 
<p>
This algorithm is applied as a post-processing operation of <a class="el" href="group__EdgeDetection.html#g03891ba21dd1b7c5d8c3337423dcf34b">differenceOfExponentialCrackEdgeImage()</a>. The source image must fulfill the requirements of a <a class="el" href="CrackEdgeImage.html">Crack Edge Image</a>, but will <b> not</b> do so after application of this algorithm. In particular, the algorithm removes zero-cells marked as edges to avoid staircase effects on diagonal lines like this:<p>
<div class="fragment"><pre class="fragment">    original edge points (*)     resulting edge points

          . * . . .                   . * . . .
          . * * * .                   . . * . .
          . . . * .           =&gt;      . . . * .
          . . . * *                   . . . . *
          . . . . .                   . . . . .
</pre></div><p>
Therfore, this algorithm should only be applied as a vizualization aid, i.e. for human inspection. The algorithm assumes that edges are marked with <code>edge_marker</code>, and background pixels with <code>background_marker</code>. The image's value type must be equality comparable.<p>
Note that this algorithm, unlike most other algorithms in VIGRA, operates in-place, i.e. on only one image.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> SrcIterator, <span class="keyword">class</span> SrcAccessor, <span class="keyword">class</span> SrcValue&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#gd23b10d3d105e3a9e394e4542a1baa8b" title="Beautify crack edge image for visualization.">beautifyCrackEdgeImage</a>(
               SrcIterator sul, SrcIterator slr, SrcAccessor sa,
               SrcValue edge_marker, SrcValue background_marker)
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> SrcIterator, <span class="keyword">class</span> SrcAccessor, <span class="keyword">class</span> SrcValue&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#gd23b10d3d105e3a9e394e4542a1baa8b" title="Beautify crack edge image for visualization.">beautifyCrackEdgeImage</a>(
                   triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
               SrcValue edge_marker, SrcValue background_marker)
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="edgedetection_8hxx-source.html">vigra/edgedetection.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::BImage</a> src(w,h), edges(2*w-1, 2*h-1);

    <span class="comment">// empty edge image</span>
    edges = 0;
    ...

    <span class="comment">// find edges at scale 0.8 with gradient larger than 4.0, mark with 1</span>
    <a class="code" href="group__EdgeDetection.html#g03891ba21dd1b7c5d8c3337423dcf34b" title="Detect and mark edges in a crack edge image using the Shen/Castan zero-crossing detector...">vigra::differenceOfExponentialCrackEdgeImage</a>(srcImageRange(src), destImage(edges),
                                         0.8, 4.0, 1);

    <span class="comment">// beautify edge image for visualization</span>
    <a class="code" href="group__EdgeDetection.html#gd23b10d3d105e3a9e394e4542a1baa8b" title="Beautify crack edge image for visualization.">vigra::beautifyCrackEdgeImage</a>(destImageRange(edges), 1, 0);

    <span class="comment">// show to the user</span>
    window.open(edges);
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcImageIterator src_upperleft, src_lowerright;

    SrcAccessor src_accessor;
    DestAccessor dest_accessor;

    SrcAccessor::value_type u = src_accessor(src_upperleft);

    u == u
    u != u

    SrcValue background_marker;
    src_accessor.set(background_marker, src_upperleft);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g07d8d68b29292a80213bfcd00cff2410"></a><!-- doxytag: member="vigra::cannyEdgelList" ref="g07d8d68b29292a80213bfcd00cff2410" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::cannyEdgelList           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Simple implementation of Canny's edge detector. 
<p>
This operator first calculates the gradient vector for each pixel of the image using first derivatives of a <a class="el" href="classvigra_1_1Gaussian.html">Gaussian</a> at the given scale. Then a very simple non-maxima supression is performed: for each 3x3 neighborhood, it is determined whether the center pixel has larger gradient magnitude than its two neighbors in gradient direction (where the direction is rounded into octands). If this is the case, a new <a class="el" href="classvigra_1_1Edgel.html">Edgel</a> is appended to the given vector of <code>edgels</code>. The subpixel edgel position is determined by fitting a parabola to the three gradient magnitude values mentioned above. The sub-pixel location of the parabola's tip and the gradient magnitude and direction (from the pixel center) are written in the newly created edgel.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> SrcIterator, <span class="keyword">class</span> SrcAccessor, <span class="keyword">class</span> BackInsertable&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#g07d8d68b29292a80213bfcd00cff2410" title="Simple implementation of Canny&amp;#39;s edge detector.">cannyEdgelList</a>(SrcIterator ul, SrcIterator lr, SrcAccessor src,
                            BackInsertable &amp; edgels, <span class="keywordtype">double</span> scale);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> SrcIterator, <span class="keyword">class</span> SrcAccessor, <span class="keyword">class</span> BackInsertable&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__EdgeDetection.html#g07d8d68b29292a80213bfcd00cff2410" title="Simple implementation of Canny&amp;#39;s edge detector.">cannyEdgelList</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
                       BackInsertable &amp; edgels, <span class="keywordtype">double</span> scale);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="edgedetection_8hxx-source.html">vigra/edgedetection.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::BImage</a> src(w,h);

    <span class="comment">// empty edgel list</span>
    std::vector&lt;vigra::Edgel&gt; edgels;
    ...

    <span class="comment">// find edgels at scale 0.8</span>
    <a class="code" href="group__EdgeDetection.html#g07d8d68b29292a80213bfcd00cff2410" title="Simple implementation of Canny&amp;#39;s edge detector.">vigra::cannyEdgelList</a>(srcImageRange(src), edgels, 0.8);
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcImageIterator src_upperleft;
    SrcAccessor src_accessor;

    src_accessor(src_upperleft);

    BackInsertable edgels;
    edgels.push_back(Edgel());
</pre></div><p>
SrcAccessor::value_type must be a type convertible to float<p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">    scale &gt; 0
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g587ce18f5e12bfa76e39696a93560a63"></a><!-- doxytag: member="vigra::cannyEdgeImage" ref="g587ce18f5e12bfa76e39696a93560a63" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::cannyEdgeImage           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detect and mark edges in an edge image using Canny's algorithm. 
<p>
This operator first calls <a class="el" href="group__EdgeDetection.html#g07d8d68b29292a80213bfcd00cff2410">cannyEdgelList()</a> to generate an edgel list for the given image. Then it scans this list and selects edgels whose strength is above the given <code>gradient_threshold</code>. For each of these edgels, the edgel's location is rounded to the nearest pixel, and that pixel marked with the given <code>edge_marker</code>.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>GradValue, <span class="keyword">class </span>DestValue&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#g587ce18f5e12bfa76e39696a93560a63" title="Detect and mark edges in an edge image using Canny&amp;#39;s algorithm.">cannyEdgeImage</a>(
                   SrcIterator sul, SrcIterator slr, SrcAccessor sa,
                   DestIterator dul, DestAccessor da,
                   <span class="keywordtype">double</span> scale, GradValue gradient_threshold, DestValue edge_marker);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>GradValue, <span class="keyword">class </span>DestValue&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#g587ce18f5e12bfa76e39696a93560a63" title="Detect and mark edges in an edge image using Canny&amp;#39;s algorithm.">cannyEdgeImage</a>(
                   triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
                   pair&lt;DestIterator, DestAccessor&gt; dest,
                   <span class="keywordtype">double</span> scale, GradValue gradient_threshold, DestValue edge_marker);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="edgedetection_8hxx-source.html">vigra/edgedetection.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::BImage</a> src(w,h), edges(w,h);

    <span class="comment">// empty edge image</span>
    edges = 0;
    ...

    <span class="comment">// find edges at scale 0.8 with gradient larger than 4.0, mark with 1</span>
    <a class="code" href="group__EdgeDetection.html#g587ce18f5e12bfa76e39696a93560a63" title="Detect and mark edges in an edge image using Canny&amp;#39;s algorithm.">vigra::cannyEdgeImage</a>(srcImageRange(src), destImage(edges),
                                     0.8, 4.0, 1);
</pre></div><p>
<b> Required Interface:</b><p>
see also: <a class="el" href="group__EdgeDetection.html#g07d8d68b29292a80213bfcd00cff2410">cannyEdgelList()</a>.<p>
<div class="fragment"><pre class="fragment">    DestImageIterator dest_upperleft;
    DestAccessor dest_accessor;
    DestValue edge_marker;

    dest_accessor.set(edge_marker, dest_upperleft, <a class="code" href="classvigra_1_1Diff2D.html" title="Two dimensional difference vector.">vigra::Diff2D</a>(1,1));
</pre></div><p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">    scale &gt; 0
    gradient_threshold &gt; 0
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g7df0e9b814a556327ca5d071473c0c01"></a><!-- doxytag: member="vigra::cannyEdgeImageFromGradWithThinning" ref="g7df0e9b814a556327ca5d071473c0c01" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::cannyEdgeImageFromGradWithThinning           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detect and mark edges in an edge image using Canny's algorithm. 
<p>
The input pixels of this algorithms must be vectors of length 2 (see Required Interface below). It first searches for all pixels whose gradient magnitude is larger than the given <code>gradient_threshold</code> and larger than the magnitude of its two neighbors in gradient direction (where these neighbors are determined by nearest neighbor interpolation, i.e. according to the octant where the gradient points into). The resulting edge pixel candidates are then subjected to topological thinning so that the remaining edge pixels can be linked into edgel chains with a provable, non-heuristic algorithm. Thinning is performed so that the pixels with highest gradient magnitude survive. Optionally, the outermost pixels are marked as edge pixels as well when <code>addBorder</code> is true. The remaining pixels will be marked in the destination image with the value of <code>edge_marker</code> (all non-edge pixels remain untouched).<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>GradValue, <span class="keyword">class </span>DestValue&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#g7df0e9b814a556327ca5d071473c0c01" title="Detect and mark edges in an edge image using Canny&amp;#39;s algorithm.">cannyEdgeImageFromGradWithThinning</a>(
                   SrcIterator sul, SrcIterator slr, SrcAccessor sa,
                   DestIterator dul, DestAccessor da,
                   GradValue gradient_threshold,
                   DestValue edge_marker, <span class="keywordtype">bool</span> addBorder = <span class="keyword">true</span>);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>GradValue, <span class="keyword">class </span>DestValue&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#g7df0e9b814a556327ca5d071473c0c01" title="Detect and mark edges in an edge image using Canny&amp;#39;s algorithm.">cannyEdgeImageFromGradWithThinning</a>(
                   triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
                   pair&lt;DestIterator, DestAccessor&gt; dest,
                   GradValue gradient_threshold,
                   DestValue edge_marker, <span class="keywordtype">bool</span> addBorder = <span class="keyword">true</span>);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="edgedetection_8hxx-source.html">vigra/edgedetection.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::BImage</a> src(w,h), edges(w,h);

    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::FVector2Image</a> grad(w,h);
    <span class="comment">// compute the image gradient at scale 0.8</span>
    <a class="code" href="group__CommonConvolutionFilters.html#g45f3ac60c35b246600df26492e0a538e" title="Calculate the gradient vector by means of a 1st derivatives of Gaussian filter.">vigra::gaussianGradient</a>(srcImageRange(src), destImage(grad), 0.8);

    <span class="comment">// empty edge image</span>
    edges = 0;
    <span class="comment">// find edges gradient larger than 4.0, mark with 1, and add border</span>
    <a class="code" href="group__EdgeDetection.html#g7df0e9b814a556327ca5d071473c0c01" title="Detect and mark edges in an edge image using Canny&amp;#39;s algorithm.">vigra::cannyEdgeImageFromGradWithThinning</a>(srcImageRange(grad), destImage(edges),
                                              4.0, 1, <span class="keyword">true</span>);
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    <span class="comment">// the input pixel type must be a vector with two elements</span>
    SrcImageIterator src_upperleft;
    SrcAccessor src_accessor;
    <span class="keyword">typedef</span> SrcAccessor::value_type SrcPixel;
    <span class="keyword">typedef</span> NormTraits&lt;SrcPixel&gt;::SquaredNormType SrcSquaredNormType;

    SrcPixel g = src_accessor(src_upperleft);
    SrcPixel::value_type g0 = g[0];
    SrcSquaredNormType gn = <a class="code" href="group__FFTWComplexOperators.html#g4b9b13c33069b3f5c3901a543a00083e" title="squared norm (= squared magnitude)">squaredNorm</a>(g);

    DestImageIterator dest_upperleft;
    DestAccessor dest_accessor;
    DestValue edge_marker;

    dest_accessor.set(edge_marker, dest_upperleft, <a class="code" href="classvigra_1_1Diff2D.html" title="Two dimensional difference vector.">vigra::Diff2D</a>(1,1));
</pre></div><p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">    gradient_threshold &gt; 0
</pre></div> 
</div>
</div><p>
<a class="anchor" name="gdb574fc684ae8e15629ca77b0c961f21"></a><!-- doxytag: member="vigra::cannyEdgeImageWithThinning" ref="gdb574fc684ae8e15629ca77b0c961f21" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::cannyEdgeImageWithThinning           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detect and mark edges in an edge image using Canny's algorithm. 
<p>
This operator first calls <a class="el" href="group__CommonConvolutionFilters.html#g45f3ac60c35b246600df26492e0a538e">gaussianGradient()</a> to compute the gradient of the input image, ad then <a class="el" href="group__EdgeDetection.html#g7df0e9b814a556327ca5d071473c0c01">cannyEdgeImageFromGradWithThinning()</a> to generate an edge image. See there for more detailed documentation.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>GradValue, <span class="keyword">class </span>DestValue&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#gdb574fc684ae8e15629ca77b0c961f21" title="Detect and mark edges in an edge image using Canny&amp;#39;s algorithm.">cannyEdgeImageWithThinning</a>(
                   SrcIterator sul, SrcIterator slr, SrcAccessor sa,
                   DestIterator dul, DestAccessor da,
                   <span class="keywordtype">double</span> scale, GradValue gradient_threshold,
                   DestValue edge_marker, <span class="keywordtype">bool</span> addBorder = <span class="keyword">true</span>);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class </span>SrcIterator, <span class="keyword">class </span>SrcAccessor,
                  <span class="keyword">class </span>DestIterator, <span class="keyword">class </span>DestAccessor,
                  <span class="keyword">class </span>GradValue, <span class="keyword">class </span>DestValue&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#gdb574fc684ae8e15629ca77b0c961f21" title="Detect and mark edges in an edge image using Canny&amp;#39;s algorithm.">cannyEdgeImageWithThinning</a>(
                   triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
                   pair&lt;DestIterator, DestAccessor&gt; dest,
                   <span class="keywordtype">double</span> scale, GradValue gradient_threshold,
                   DestValue edge_marker, <span class="keywordtype">bool</span> addBorder = <span class="keyword">true</span>);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="edgedetection_8hxx-source.html">vigra/edgedetection.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::BImage</a> src(w,h), edges(w,h);

    <span class="comment">// empty edge image</span>
    edges = 0;
    ...

    <span class="comment">// find edges at scale 0.8 with gradient larger than 4.0, mark with 1, annd add border</span>
    <a class="code" href="group__EdgeDetection.html#gdb574fc684ae8e15629ca77b0c961f21" title="Detect and mark edges in an edge image using Canny&amp;#39;s algorithm.">vigra::cannyEdgeImageWithThinning</a>(srcImageRange(src), destImage(edges),
                                     0.8, 4.0, 1, <span class="keyword">true</span>);
</pre></div><p>
<b> Required Interface:</b><p>
see also: <a class="el" href="group__EdgeDetection.html#g07d8d68b29292a80213bfcd00cff2410">cannyEdgelList()</a>.<p>
<div class="fragment"><pre class="fragment">    DestImageIterator dest_upperleft;
    DestAccessor dest_accessor;
    DestValue edge_marker;

    dest_accessor.set(edge_marker, dest_upperleft, <a class="code" href="classvigra_1_1Diff2D.html" title="Two dimensional difference vector.">vigra::Diff2D</a>(1,1));
</pre></div><p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">    scale &gt; 0
    gradient_threshold &gt; 0
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g36f25b87755f840fed095aa28c56f030"></a><!-- doxytag: member="vigra::cannyEdgelList3x3" ref="g36f25b87755f840fed095aa28c56f030" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td colspan="4" class="memtemplate">template&lt;... &gt; </td></tr><tr>
          <td class="memname">void vigra::cannyEdgelList3x3           </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Improved implementation of Canny's edge detector. 
<p>
This operator first computes pixels which are crossed by the edge using <a class="el" href="group__EdgeDetection.html#gdb574fc684ae8e15629ca77b0c961f21" title="Detect and mark edges in an edge image using Canny&#39;s algorithm.">cannyEdgeImageWithThinning()</a>. The gradient magnitude in the 3x3 neighborhood of these pixels are then projected onto the normal of the edge (as determined by the gradient direction). The edgel's subpixel location is found by fitting a parabola through the 9 gradient values and determining the parabola's tip. A new <a class="el" href="classvigra_1_1Edgel.html">Edgel</a> is appended to the given vector of <code>edgels</code>. Since the parabola is fitted to 9 points rather than 3 points as in <a class="el" href="group__EdgeDetection.html#g07d8d68b29292a80213bfcd00cff2410" title="Simple implementation of Canny&#39;s edge detector.">cannyEdgelList()</a>, the accuracy is higher.<p>
<b> Declarations:</b><p>
pass arguments explicitly: <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> SrcIterator, <span class="keyword">class</span> SrcAccessor, <span class="keyword">class</span> BackInsertable&gt;
        <span class="keywordtype">void</span> <a class="code" href="group__EdgeDetection.html#g36f25b87755f840fed095aa28c56f030" title="Improved implementation of Canny&amp;#39;s edge detector.">cannyEdgelList3x3</a>(SrcIterator ul, SrcIterator lr, SrcAccessor src,
                               BackInsertable &amp; edgels, <span class="keywordtype">double</span> scale);
    }
</pre></div><p>
use argument objects in conjunction with <a class="el" href="ArgumentObjectFactories.html">Argument Object Factories</a> : <div class="fragment"><pre class="fragment">    <span class="keyword">namespace </span>vigra {
        <span class="keyword">template</span> &lt;<span class="keyword">class</span> SrcIterator, <span class="keyword">class</span> SrcAccessor, <span class="keyword">class</span> BackInsertable&gt;
        <span class="keywordtype">void</span>
        <a class="code" href="group__EdgeDetection.html#g36f25b87755f840fed095aa28c56f030" title="Improved implementation of Canny&amp;#39;s edge detector.">cannyEdgelList3x3</a>(triple&lt;SrcIterator, SrcIterator, SrcAccessor&gt; src,
                          BackInsertable &amp; edgels, <span class="keywordtype">double</span> scale);
    }
</pre></div><p>
<b> Usage:</b><p>
<b>#include</b> &lt;<a href="edgedetection_8hxx-source.html">vigra/edgedetection.hxx</a>&gt;<br>
 Namespace: <a class="el" href="namespacevigra.html">vigra</a><p>
<div class="fragment"><pre class="fragment">    <a class="code" href="classvigra_1_1BasicImage.html" title="Fundamental class template for images.">vigra::BImage</a> src(w,h);

    <span class="comment">// empty edgel list</span>
    std::vector&lt;vigra::Edgel&gt; edgels;
    ...

    <span class="comment">// find edgels at scale 0.8</span>
    <a class="code" href="group__EdgeDetection.html#g36f25b87755f840fed095aa28c56f030" title="Improved implementation of Canny&amp;#39;s edge detector.">vigra::cannyEdgelList3x3</a>(srcImageRange(src), edgels, 0.8);
</pre></div><p>
<b> Required Interface:</b><p>
<div class="fragment"><pre class="fragment">    SrcImageIterator src_upperleft;
    SrcAccessor src_accessor;

    src_accessor(src_upperleft);

    BackInsertable edgels;
    edgels.push_back(Edgel());
</pre></div><p>
SrcAccessor::value_type must be a type convertible to float<p>
<b> Preconditions:</b><p>
<div class="fragment"><pre class="fragment">    scale &gt; 0
</pre></div> 
</div>
</div><p>
</div>
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
VIGRA 1.6.0 (13 Aug 2008)
</i>
</tr>
</table>


</BODY>
</HTML>
