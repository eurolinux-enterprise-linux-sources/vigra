<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><TITLE>VIGRA - VIGRA: template&lt;&gt; struct NumericTraits&lt;ArithmeticType&gt;</TITLE>
<link rel=stylesheet type="text/css" href="vigra.css">
</head>
<body  bgcolor="#f8f0e0" link="#0040b0" vlink="#a00040">
<basefont face="Helvetica,Arial,sans-serif" size=3>
<p align=right>
[ <a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/">VIGRA Homepage</a> |
 <a href="functionindex.html">Function Index</a> |
 <a href="classes.html">Class Index</a> |
 <a href="namespaces.html">Namespaces</a> |
 <a href="files.html">File List</a> |
 <a href="index.html">Main Page</a> ]
</p>
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<table class="main_heading">
<tr>
<td width="100%"><a class="anchor" name="NumericTraits">template&lt;&gt; struct NumericTraits&lt;ArithmeticType&gt; </a>
</td>
<td align=right><a href="http://kogs-www.informatik.uni-hamburg.de/~koethe/vigra/"><IMG border=0 ALT="VIGRA" SRC="documents/vigra.gif"></a></td></tr>
</table><p>
Unary traits for promotion, conversion, creation of arithmetic objects.<p>
<b>#include</b> &lt;<a href="numerictraits_8hxx-source.html">vigra/numerictraits.hxx</a>&gt;<p>
This traits class is used derive important properties of an arithmetic type. Consider the following algorithm:<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// calculate the sum of a sequence of bytes</span>
    <span class="keywordtype">int</span> sumBytes(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * begin, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * end)
    {
        <span class="keywordtype">int</span> result = 0;
        <span class="keywordflow">for</span>(; begin != end; ++begin)  result += *begin;
        <span class="keywordflow">return</span> result;
    }
</pre></div><p>
The return type of this function can not be 'unsigned char' because the summation would very likely overflow. Since we know the source type, we can easily choose 'int' as an appropriate return type. Likewise, we would have choosen 'float' if we had to sum a sequence of floats. If we want to make this algorithm generic, we would like to derive the appropriate return type automatically. This can be done with NumericTraits. The code would look like this (we use <a class="el" href="group__DataAccessors.html">Data Accessors</a> to read the data from the sequence):<p>
<div class="fragment"><pre class="fragment">    <span class="comment">// calculate the sum of any sequence</span>
    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator, <span class="keyword">class</span> Accessor&gt;
    <span class="keyword">typename</span> vigra::NumericTraits&lt;typename Accessor::value_type&gt;::Promote
    sumSequence(Iterator begin, Iterator end, Accessor a)
    {
        <span class="comment">// an abbreviation</span>
        <span class="keyword">typedef</span> vigra::NumericTraits&lt;typename Accessor::value_type&gt;  SrcTraits;
        
        <span class="comment">// find out result type</span>
        <span class="keyword">typedef</span> <span class="keyword">typename</span> SrcTraits::Promote ResultType;
      
        <span class="comment">// init result to zero</span>
        ResultType result = vigra::NumericTraits&lt;ResultType&gt;::zero();
    
        <span class="keywordflow">for</span>(; begin != end; ++begin)
        {  
            <span class="comment">// cast current item to ResultType and add</span>
            result += SrcTraits::toPromote(a(begin));
        }
        
        <span class="keywordflow">return</span> result;
    }
</pre></div><p>
In this example NumericTraits is not only used to deduce the ReturnType of the operation, but also to initialize it with the constant 'zero'. This is necessary since we do not know in general, which expression must be used to obtain a zero of some arbitrary type - '<code>ResultType result = 0;</code>' would only work if the ResultType had an constructor taking an '<code>int</code>' argument, and we would not even have any guarantee as to what the semantics of this constructor are. In addition, the traits are used to cast the source type into the promote type.<p>
Similarly, an algorithm that needs multiplication would use the return type <code>RealPromote</code> and the functions <code>one()</code> and <code>toRealPromote()</code>. The following members are defined in <b> <code>NumericTraits&lt;ArithmeticType&gt;</code></b>:<p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><b> <code>typedef ... Type;</code></b> </td><td><p>
the type itself<p>
</td></tr>
<tr>
<td><b> <code>typedef ... Promote;</code></b> </td><td><p>
promote type for addition and subtraction<p>
</td></tr>
<tr>
<td><b> <code>typedef ... RealPromote;</code></b> </td><td>promote type for multiplication and division with a real number<p>
(only defined if <code>ArithmeticType</code> supports these operations)<p>
</td></tr>
<tr>
<td><b> <code>typedef ... ComplexPromote;</code></b> </td><td><p>
promote type for complex arithmetic<p>
</td></tr>
<tr>
<td><b> <code>typedef ... ValueType;</code></b> </td><td><p>
for scalar types: the type itself<br>
 otherwise: typename Type::value_type (if defined)<p>
</td></tr>
<tr>
<td><b> <code>static Promote toPromote(ArithmeticType v);</code></b> </td><td>convert to <code>Promote</code> type<p>
</td></tr>
<tr>
<td><b> <code>static RealPromote toRealPromote(ArithmeticType v);</code></b> </td><td>convert to <code>RealPromote</code> type<p>
(only defined if <code>ArithmeticType</code> supports multiplication)<p>
</td></tr>
<tr>
<td><b> <code>static ArithmeticType fromPromote(Promote v);</code></b> </td><td>convert from <code>Promote</code> type<p>
if <code>v</code> is outside the range of <code>ArithmeticType</code> it is clipped;<p>
</td></tr>
<tr>
<td><b> <code>static ArithmeticType fromRealPromote(RealPromote v);</code></b> </td><td>convert from <code>RealPromote</code> type<p>
(only defined if <code>ArithmeticType</code> supports multiplication)<p>
if <code>ArithmeticType</code> is an integral type, the result is rounded<p>
if <code>v</code> is outside the range of <code>ArithmeticType</code> it is clipped<p>
</td></tr>
<tr>
<td><b> <code>static ArithmeticType zero();</code></b> </td><td>create neutral element of addition<p>
i.e. <code>(ArithmeticType a = ...,</code> <code> a + NumericTraits&lt;ArithmeticType&gt;::zero() == a)</code> must always yield <code>true</code><p>
</td></tr>
<tr>
<td><b> <code>static ArithmeticType nonZero();</code></b> </td><td>create a non-zero element (if multiplication is defined, this yields one())<p>
i.e. <code>(ArithmeticType a = ...,</code> <code> a + NumericTraits&lt;ArithmeticType&gt;::nonZero() == a)</code> must always yield <code>false</code><p>
</td></tr>
<tr>
<td><b> <code>static ArithmeticType min();</code></b> </td><td>the smallest number representable in this type.<br>
 Only available if isOrdered is VigraTrueType. For integral types, this equals <code>INT_MIN</code> etc., for real valued types it is <code>-FLT_MAX</code> etc. (<b>not</b> <code>FLT_MIN</code> -- this is the smallest positive <code>float</code>)<p>
</td></tr>
<tr>
<td><b> <code>static ArithmeticType max();</code></b> </td><td>the largest number representable in this type.<br>
 Only available if isOrdered is VigraTrueType. For integral types, this equals <code>INT_MAX</code> etc., for real valued types it is <code>FLT_MAX</code> etc.<p>
</td></tr>
<tr>
<td><b> <code>static ArithmeticType one();</code></b> </td><td>create neutral element of multiplication<p>
(only defined if <code>ArithmeticType</code> supports multiplication)<p>
i.e. <code>(ArithmeticType a = ...,</code> <code> a * NumericTraits&lt;ArithmeticType&gt;::one() == a)</code> must always yield <code>true</code><p>
</td></tr>
<tr>
<td><b> <code>typedef ... isIntegral;</code></b> </td><td>VigraTrueType if <code>ArithmeticType</code> is an integral type, VigraFalseType otherwise<p>
</td></tr>
<tr>
<td><b> <code>typedef ... isScalar;</code></b> </td><td>VigraTrueType if <code>ArithmeticType</code> is a scalar type, VigraFalseType otherwise<p>
</td></tr>
<tr>
<td></td></tr>
<tr>
<td><b> <code>typedef ... isSigned;</code></b> </td><td>VigraTrueType if <code>ArithmeticType</code> is a signed type, VigraFalseType otherwise<p>
</td></tr>
<tr>
<td></td></tr>
<tr>
<td><b> <code>typedef ... isOrdered;</code></b> </td><td>VigraTrueType if <code>ArithmeticType</code> supports <a class="el" href="group__FixedPointOperations.html#gabd4258d516eb8c9e38f9f97f3160868" title="less than">operator&lt;()</a>, VigraFalseType otherwise<p>
</td></tr>
<tr>
<td><b> <code>typedef ... isComplex;</code></b> </td><td>VigraTrueType if <code>ArithmeticType</code> is a complex number, VigraFalseType otherwise<p>
</td></tr>
<tr>
<td></td></tr>
</table>
<p>
NumericTraits for the built-in types are defined in <b>#include</b> &lt;<a href="numerictraits_8hxx-source.html">vigra/numerictraits.hxx</a>&gt;<p>
Namespace: <a class="el" href="namespacevigra.html">vigra</a> </div>
<!-- footer.html -->
<p>
<table border=0 cellspacing=0 width="100%"  bgcolor="#e0d0a0" cellpadding=5>
<tr>
<td>
<p>
<i>&copy; <A HREF="http://hci.iwr.uni-heidelberg.de/people/ukoethe/">Ullrich K&ouml;the</A>     (<A
HREF="mailto:ullrich.koethe@iwr.uni-heidelberg.de">ullrich.koethe@iwr.uni-heidelberg.de</A>)</i> <br>
<i><A HREF="http://hci.iwr.uni-heidelberg.de/">
Heidelberg Collaboratory for Image Processing</a>,
University of Heidelberg, Germany</i>
<td>
<p align=right>
<I>html generated using <A HREF="http://www.doxygen.org">doxygen</A> and <A HREF="http://www.python.org">Python</A></I>
<br>
<i>
VIGRA 1.6.0 (13 Aug 2008)
</i>
</tr>
</table>


</BODY>
</HTML>
